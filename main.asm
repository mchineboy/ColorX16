; 6502 assembly code for 'main'
; generated by prog8.codegen.cpu6502.ProgramAndVarsGen on 2026-01-16T10:12:53
; assembler syntax is for the 64tasm cross-assembler
; output options: output=PRG launcher=BASIC zp=KERNALSAFE

.cpu  '6502'
.enc  'none'
P8ZP_SCRATCH_B1 = 116
P8ZP_SCRATCH_REG = 117
P8ZP_SCRATCH_W1 = 251    ; word
P8ZP_SCRATCH_W2 = 253    ; word
P8ZP_SCRATCH_PTR = 11  ; word
.weak
.endweak
; ---- basic program with sys call ----
* = $1c01
prog8_program_start	; start of program label
	.word  (+), 2026
	.null  $9e, format(' %d ', prog8_entrypoint), $3a, $8f, ' prog8'
+	.word  0
prog8_entrypoint
	cld
	tsx  ; save stackpointer for sys.exit()
	stx  prog8_lib.orig_stackpointer
	jsr  p8_sys_startup.init_system
	jsr  p8_sys_startup.init_system_phase2
	; zeropage is clobbered so we need to reset the machine at exit
	lda  #>sys.reset_system
	pha
	lda  #<sys.reset_system
	pha
	jsr  p8b_main.p8s_start
	jmp  p8_sys_startup.cleanup_at_exit

; ---- block: 'p8b_main' ----
p8b_main	.proc
	; source: main.p8:12   main {


	; source: main.p8:13   sub start() {

p8s_start	.proc
	jsr  prog8_lib.program_startup_clear_bss
	jsr  p8b_config.prog8_init_vars
	jsr  diskio.prog8_init_vars
	jsr  p8b_com.prog8_init_vars
	jsr  p8b_session.prog8_init_vars
	jsr  p8b_login.prog8_init_vars
	jsr  p8b_userdb.prog8_init_vars
	jsr  p8b_menu.prog8_init_vars
	jsr  p8b_boards.prog8_init_vars
	jsr  p8b_messaging.prog8_init_vars
	jsr  p8b_files.prog8_init_vars
+
; statements
	; source: main.p8:81   bool running = true
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:11   chrout(147)
	lda  #$93
	jsr  txt.chrout
	; source: main.p8:17   if not config.load() {
	jsr  p8b_config.p8s_load
	cmp  #0
	bne  p8_label_gen_200_afterif
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: main.p8:20   txt.print("=== Configuration Required ===")
	ldy  #>prog8_interned_strings.string_1
	lda  #<prog8_interned_strings.string_1
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	lda  #13
	jsr  txt.chrout
	; source: main.p8:23   txt.print("No configuration file found.")
	ldy  #>prog8_interned_strings.string_2
	lda  #<prog8_interned_strings.string_2
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: main.p8:25   txt.print("Entering setup mode...")
	ldy  #>prog8_interned_strings.string_3
	lda  #<prog8_interned_strings.string_3
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	lda  #13
	jsr  txt.chrout
	; source: main.p8:28   sys.wait(60)  ; Wait 1 second
	ldy  #>$3c
	lda  #<$3c
	jsr  sys.wait
	; source: main.p8:31   setup.run()
	jsr  p8b_setup.p8s_run
	; source: main.p8:34   if not config.load() {
	jsr  p8b_config.p8s_load
	cmp  #0
	bne  p8_label_gen_201_afterif
	; source: main.p8:35   txt.print("FATAL: Could not load configuration after setup!")
	ldy  #>prog8_interned_strings.string_4
	lda  #<prog8_interned_strings.string_4
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: main.p8:37   txt.print("Exiting...")
	ldy  #>prog8_interned_strings.string_5
	lda  #<prog8_interned_strings.string_5
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jmp  txt.chrout
	; source: main.p8:39   return
p8_label_gen_201_afterif
p8_label_gen_200_afterif
	; source: main.p8:44   txt.print("BBS starting...")
	ldy  #>prog8_interned_strings.string_6
	lda  #<prog8_interned_strings.string_6
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: main.p8:48   txt.print("Initializing serial communication...")
	ldy  #>prog8_interned_strings.string_7
	lda  #<prog8_interned_strings.string_7
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: main.p8:50   if not com.init() {
	jsr  p8b_com.p8s_init
	cmp  #0
	bne  p8_label_gen_202_afterif
	; source: main.p8:51   txt.print("ERROR: Failed to initialize serial communication!")
	ldy  #>prog8_interned_strings.string_8
	lda  #<prog8_interned_strings.string_8
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: main.p8:53   txt.print("Exiting...")
	ldy  #>prog8_interned_strings.string_5
	lda  #<prog8_interned_strings.string_5
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jmp  txt.chrout
	; source: main.p8:55   return
p8_label_gen_202_afterif
	; source: main.p8:58   txt.print("Serial communication ready on Device 2")
	ldy  #>prog8_interned_strings.string_9
	lda  #<prog8_interned_strings.string_9
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	lda  #13
	jsr  txt.chrout
	; source: main.p8:63   session.init()
	jsr  p8b_session.p8s_init
	; source: main.p8:66   login.init()
	jsr  p8b_login.p8s_init
	; source: main.p8:69   boards.init()
	jsr  p8b_boards.p8s_init
	; source: main.p8:72   messaging.init()
	jsr  p8b_messaging.p8s_init
	; source: main.p8:75   txt.print("BBS is now online and waiting for connections.")
	ldy  #>prog8_interned_strings.string_10
	lda  #<prog8_interned_strings.string_10
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: main.p8:77   txt.print("Press STOP key to shutdown.")
	ldy  #>prog8_interned_strings.string_11
	lda  #<prog8_interned_strings.string_11
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	lda  #13
	jsr  txt.chrout
	; source: main.p8:81   bool running = true
	lda  #1
	sta  p8v_running
	; source: main.p8:82   while running {
p8_label_gen_1_whileloop
	lda  p8v_running
	beq  p8_label_gen_2_afterwhile
	; source: main.p8:84   if session.wait_for_connection() {
	jsr  p8b_session.p8s_wait_for_connection
	cmp  #0
	beq  p8_label_gen_204_else
	; source: main.p8:86   session.handle_session()
	jsr  p8b_session.p8s_handle_session
	; source: main.p8:89   txt.print("Session ended. Waiting for next connection...")
	ldy  #>prog8_interned_strings.string_12
	lda  #<prog8_interned_strings.string_12
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: main.p8:91   sys.wait(60)  ; 1 second delay
	ldy  #>$3c
	lda  #<$3c
	jsr  sys.wait
	jmp  p8_label_gen_203_afterif
p8_label_gen_204_else
	; source: main.p8:94   txt.print("No connection received. Continue waiting? (Y/N)")
	ldy  #>prog8_interned_strings.string_13
	lda  #<prog8_interned_strings.string_13
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: main.p8:97   sys.wait(60)
	ldy  #>$3c
	lda  #<$3c
	jsr  sys.wait
p8_label_gen_203_afterif
	; source: main.p8:82   while running {
	jmp  p8_label_gen_1_whileloop
p8_label_gen_2_afterwhile
	; source: main.p8:105   txt.print("Shutting down BBS...")
	ldy  #>prog8_interned_strings.string_14
	lda  #<prog8_interned_strings.string_14
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: main.p8:107   session.init()  ; Reset session state
	jsr  p8b_session.p8s_init
	; source: main.p8:108   com.close()
	jsr  p8b_com.p8s_close
	; source: main.p8:109   txt.print("BBS shutdown complete.")
	ldy  #>prog8_interned_strings.string_15
	lda  #<prog8_interned_strings.string_15
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jmp  txt.chrout
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_running	.byte  ?
	.send BSS
	.pend
	.pend

; ---- block: 'p8_sys_startup' ----
p8_sys_startup	.proc
	; source: library:/prog8lib/c128/syslib.p8:1289   p8_sys_startup {


	; source: library:/prog8lib/c128/syslib.p8:1292   asmsub  init_system()  {

init_system	.proc
	; source: library:/prog8lib/c128/syslib.p8:1299   %asm {{
        sei
        lda  #0
        sta  $ff00      ; select default bank 15
        jsr  cbm.IOINIT
        jsr  cbm.RESTOR
        jsr  cbm.CINT
        lda  #%00001110
        sta  $ff00      ; bank out basic rom so we have ram from $1c00-$bfff
        lda  #6
        sta  c64.EXTCOL
        lda  #7
        sta  cbm.COLOR
        lda  #0
        sta  c64.BGCOL0
        jsr  disable_runstop_and_charsetswitch
        ; basic is not banked in, adjust MEMTOP
        ldx  #<$c000
        ldy  #>$c000
        clc
        jsr  cbm.MEMTOP
        cli
        rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:1325   asmsub  init_system_phase2()  {

init_system_phase2	.proc
	; source: library:/prog8lib/c128/syslib.p8:1326   %asm {{
        cld
        clc
        clv
        rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:1334   asmsub  cleanup_at_exit() {

cleanup_at_exit	.proc
	; source: library:/prog8lib/c128/syslib.p8:1336   %asm {{
        lda  #0
        sta  $ff00          ; default bank 15
        jsr  cbm.CLRCHN		; reset i/o channels
        jsr  enable_runstop_and_charsetswitch
        ldx  #<$ff00
        ldy  #>$ff00
        clc
        jsr  cbm.MEMTOP     ; adjust MEMTOP to original value again
        lda  _exitcarry
        lsr  a
        lda  _exitcode
        ldx  _exitcodeX
        ldy  _exitcodeY
        rts

        .section BSS
_exitcarry  .byte ?
_exitcode   .byte ?
_exitcodeX  .byte ?
_exitcodeY  .byte ?
        .send BSS

        ; !notreached!
	.pend
	; source: library:/prog8lib/c128/syslib.p8:1363   asmsub  disable_runstop_and_charsetswitch() clobbers(A) {

disable_runstop_and_charsetswitch	.proc
	; source: library:/prog8lib/c128/syslib.p8:1364   %asm {{
        lda  #$80
        sta  247    ; disable charset switching
        lda  #112
        sta  808    ; disable run/stop key
        rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:1373   asmsub  enable_runstop_and_charsetswitch() clobbers(A) {

enable_runstop_and_charsetswitch	.proc
	; source: library:/prog8lib/c128/syslib.p8:1374   %asm {{
        lda  #0
        sta  247    ; enable charset switching
        lda  #110
        sta  808    ; enable run/stop key
        rts
	.pend
	.pend

; ---- block: 'prog8_interned_strings' ----
prog8_interned_strings	.proc

; non-zeropage variables with init value
string_1	; PETSCII:"=== Configuration Required ==="
	.byte  $3d, $3d, $3d, $20, $c3, $4f, $4e, $46, $49, $47, $55, $52, $41, $54, $49, $4f
	.byte  $4e, $20, $d2, $45, $51, $55, $49, $52, $45, $44, $20, $3d, $3d, $3d, $00
string_10	; PETSCII:"BBS is now online and waiting for connections."
	.byte  $c2, $c2, $d3, $20, $49, $53, $20, $4e, $4f, $57, $20, $4f, $4e, $4c, $49, $4e
	.byte  $45, $20, $41, $4e, $44, $20, $57, $41, $49, $54, $49, $4e, $47, $20, $46, $4f
	.byte  $52, $20, $43, $4f, $4e, $4e, $45, $43, $54, $49, $4f, $4e, $53, $2e, $00
string_100	; PETSCII:"=== SysOp Functions ==="
	.byte  $3d, $3d, $3d, $20, $d3, $59, $53, $cf, $50, $20, $c6, $55, $4e, $43, $54, $49
	.byte  $4f, $4e, $53, $20, $3d, $3d, $3d, $00
string_101	; PETSCII:"SysOp functions are not yet implemented."
	.byte  $d3, $59, $53, $cf, $50, $20, $46, $55, $4e, $43, $54, $49, $4f, $4e, $53, $20
	.byte  $41, $52, $45, $20, $4e, $4f, $54, $20, $59, $45, $54, $20, $49, $4d, $50, $4c
	.byte  $45, $4d, $45, $4e, $54, $45, $44, $2e, $00
string_102	; PETSCII:"=== BBS Information ==="
	.byte  $3d, $3d, $3d, $20, $c2, $c2, $d3, $20, $c9, $4e, $46, $4f, $52, $4d, $41, $54
	.byte  $49, $4f, $4e, $20, $3d, $3d, $3d, $00
string_103	; PETSCII:"SysOp: "
	.byte  $d3, $59, $53, $cf, $50, $3a, $20, $00
string_104	; PETSCII:"Status: Online"
	.byte  $d3, $54, $41, $54, $55, $53, $3a, $20, $cf, $4e, $4c, $49, $4e, $45, $00
string_105	; PETSCII:"Logged in as: "
	.byte  $cc, $4f, $47, $47, $45, $44, $20, $49, $4e, $20, $41, $53, $3a, $20, $00
string_106	; PETSCII:"User Level: "
	.byte  $d5, $53, $45, $52, $20, $cc, $45, $56, $45, $4c, $3a, $20, $00
string_107	; PETSCII:"Creating message boards database..."
	.byte  $c3, $52, $45, $41, $54, $49, $4e, $47, $20, $4d, $45, $53, $53, $41, $47, $45
	.byte  $20, $42, $4f, $41, $52, $44, $53, $20, $44, $41, $54, $41, $42, $41, $53, $45
	.byte  $2e, $2e, $2e, $00
string_108	; PETSCII:"bbsmsgs,L,128,R,500"
	.byte  $42, $42, $53, $4d, $53, $47, $53, $2c, $cc, $2c, $31, $32, $38, $2c, $d2, $2c
	.byte  $35, $30, $30, $00
string_109	; PETSCII:"Error creating message boards file: "
	.byte  $c5, $52, $52, $4f, $52, $20, $43, $52, $45, $41, $54, $49, $4e, $47, $20, $4d
	.byte  $45, $53, $53, $41, $47, $45, $20, $42, $4f, $41, $52, $44, $53, $20, $46, $49
	.byte  $4c, $45, $3a, $20, $00
string_11	; PETSCII:"Press STOP key to shutdown."
	.byte  $d0, $52, $45, $53, $53, $20, $d3, $d4, $cf, $d0, $20, $4b, $45, $59, $20, $54
	.byte  $4f, $20, $53, $48, $55, $54, $44, $4f, $57, $4e, $2e, $00
string_110	; PETSCII:"Message boards database created successfully"
	.byte  $cd, $45, $53, $53, $41, $47, $45, $20, $42, $4f, $41, $52, $44, $53, $20, $44
	.byte  $41, $54, $41, $42, $41, $53, $45, $20, $43, $52, $45, $41, $54, $45, $44, $20
	.byte  $53, $55, $43, $43, $45, $53, $53, $46, $55, $4c, $4c, $59, $00
string_111	; PETSCII:"=== Message Board ==="
	.byte  $3d, $3d, $3d, $20, $cd, $45, $53, $53, $41, $47, $45, $20, $c2, $4f, $41, $52
	.byte  $44, $20, $3d, $3d, $3d, $00
string_112	; PETSCII:"Board: "
	.byte  $c2, $4f, $41, $52, $44, $3a, $20, $00
string_113	; PETSCII:"No messages in this board."
	.byte  $ce, $4f, $20, $4d, $45, $53, $53, $41, $47, $45, $53, $20, $49, $4e, $20, $54
	.byte  $48, $49, $53, $20, $42, $4f, $41, $52, $44, $2e, $00
string_114	; PETSCII:"Messages: "
	.byte  $cd, $45, $53, $53, $41, $47, $45, $53, $3a, $20, $00
string_115	; PETSCII:"["
	.byte  $5b, $00
string_116	; PETSCII:"] "
	.byte  $5d, $20, $00
string_117	; PETSCII:" by "
	.byte  $20, $42, $59, $20, $00
string_118	; PETSCII:"=== Message ==="
	.byte  $3d, $3d, $3d, $20, $cd, $45, $53, $53, $41, $47, $45, $20, $3d, $3d, $3d, $00
string_119	; PETSCII:"Subject: "
	.byte  $d3, $55, $42, $4a, $45, $43, $54, $3a, $20, $00
string_12	; PETSCII:"Session ended. Waiting for next connection..."
	.byte  $d3, $45, $53, $53, $49, $4f, $4e, $20, $45, $4e, $44, $45, $44, $2e, $20, $d7
	.byte  $41, $49, $54, $49, $4e, $47, $20, $46, $4f, $52, $20, $4e, $45, $58, $54, $20
	.byte  $43, $4f, $4e, $4e, $45, $43, $54, $49, $4f, $4e, $2e, $2e, $2e, $00
string_120	; PETSCII:"From: "
	.byte  $c6, $52, $4f, $4d, $3a, $20, $00
string_121	; PETSCII:"Error: Message database full!"
	.byte  $c5, $52, $52, $4f, $52, $3a, $20, $cd, $45, $53, $53, $41, $47, $45, $20, $44
	.byte  $41, $54, $41, $42, $41, $53, $45, $20, $46, $55, $4c, $4c, $21, $00
string_122	; PETSCII:"Message posted successfully!"
	.byte  $cd, $45, $53, $53, $41, $47, $45, $20, $50, $4f, $53, $54, $45, $44, $20, $53
	.byte  $55, $43, $43, $45, $53, $53, $46, $55, $4c, $4c, $59, $21, $00
string_123	; PETSCII:"=== Message Boards ==="
	.byte  $3d, $3d, $3d, $20, $cd, $45, $53, $53, $41, $47, $45, $20, $c2, $4f, $41, $52
	.byte  $44, $53, $20, $3d, $3d, $3d, $00
string_124	; PETSCII:"1. General Discussion"
	.byte  $31, $2e, $20, $c7, $45, $4e, $45, $52, $41, $4c, $20, $c4, $49, $53, $43, $55
	.byte  $53, $53, $49, $4f, $4e, $00
string_125	; PETSCII:"2. Announcements"
	.byte  $32, $2e, $20, $c1, $4e, $4e, $4f, $55, $4e, $43, $45, $4d, $45, $4e, $54, $53
	.byte  $00
string_126	; PETSCII:"3. Help & Support"
	.byte  $33, $2e, $20, $c8, $45, $4c, $50, $20, $26, $20, $d3, $55, $50, $50, $4f, $52
	.byte  $54, $00
string_127	; PETSCII:"0. Return to Main Menu"
	.byte  $30, $2e, $20, $d2, $45, $54, $55, $52, $4e, $20, $54, $4f, $20, $cd, $41, $49
	.byte  $4e, $20, $cd, $45, $4e, $55, $00
string_128	; PETSCII:"General"
	.byte  $c7, $45, $4e, $45, $52, $41, $4c, $00
string_129	; PETSCII:"Announce"
	.byte  $c1, $4e, $4e, $4f, $55, $4e, $43, $45, $00
string_13	; PETSCII:"No connection received. Continue waiting? (Y/N)"
	.byte  $ce, $4f, $20, $43, $4f, $4e, $4e, $45, $43, $54, $49, $4f, $4e, $20, $52, $45
	.byte  $43, $45, $49, $56, $45, $44, $2e, $20, $c3, $4f, $4e, $54, $49, $4e, $55, $45
	.byte  $20, $57, $41, $49, $54, $49, $4e, $47, $3f, $20, $28, $d9, $2f, $ce, $29, $00
string_130	; PETSCII:"Help"
	.byte  $c8, $45, $4c, $50, $00
string_131	; PETSCII:"Options:"
	.byte  $cf, $50, $54, $49, $4f, $4e, $53, $3a, $00
string_132	; PETSCII:"1. Read message"
	.byte  $31, $2e, $20, $d2, $45, $41, $44, $20, $4d, $45, $53, $53, $41, $47, $45, $00
string_133	; PETSCII:"2. Post new message"
	.byte  $32, $2e, $20, $d0, $4f, $53, $54, $20, $4e, $45, $57, $20, $4d, $45, $53, $53
	.byte  $41, $47, $45, $00
string_134	; PETSCII:"3. Reply to message"
	.byte  $33, $2e, $20, $d2, $45, $50, $4c, $59, $20, $54, $4f, $20, $4d, $45, $53, $53
	.byte  $41, $47, $45, $00
string_135	; PETSCII:"0. Back to boards"
	.byte  $30, $2e, $20, $c2, $41, $43, $4b, $20, $54, $4f, $20, $42, $4f, $41, $52, $44
	.byte  $53, $00
string_136	; PETSCII:"Enter message ID: "
	.byte  $c5, $4e, $54, $45, $52, $20, $4d, $45, $53, $53, $41, $47, $45, $20, $c9, $c4
	.byte  $3a, $20, $00
string_137	; PETSCII:"Message not found."
	.byte  $cd, $45, $53, $53, $41, $47, $45, $20, $4e, $4f, $54, $20, $46, $4f, $55, $4e
	.byte  $44, $2e, $00
string_138	; PETSCII:"Message: "
	.byte  $cd, $45, $53, $53, $41, $47, $45, $3a, $20, $00
string_139	; PETSCII:"Reply to message ID: "
	.byte  $d2, $45, $50, $4c, $59, $20, $54, $4f, $20, $4d, $45, $53, $53, $41, $47, $45
	.byte  $20, $c9, $c4, $3a, $20, $00
string_14	; PETSCII:"Shutting down BBS..."
	.byte  $d3, $48, $55, $54, $54, $49, $4e, $47, $20, $44, $4f, $57, $4e, $20, $c2, $c2
	.byte  $d3, $2e, $2e, $2e, $00
string_140	; PETSCII:"Creating messaging database..."
	.byte  $c3, $52, $45, $41, $54, $49, $4e, $47, $20, $4d, $45, $53, $53, $41, $47, $49
	.byte  $4e, $47, $20, $44, $41, $54, $41, $42, $41, $53, $45, $2e, $2e, $2e, $00
string_141	; PETSCII:"bbsmail,L,128,R,1000"
	.byte  $42, $42, $53, $4d, $41, $49, $4c, $2c, $cc, $2c, $31, $32, $38, $2c, $d2, $2c
	.byte  $31, $30, $30, $30, $00
string_142	; PETSCII:"Error creating messaging file: "
	.byte  $c5, $52, $52, $4f, $52, $20, $43, $52, $45, $41, $54, $49, $4e, $47, $20, $4d
	.byte  $45, $53, $53, $41, $47, $49, $4e, $47, $20, $46, $49, $4c, $45, $3a, $20, $00
string_143	; PETSCII:"Messaging database created successfully"
	.byte  $cd, $45, $53, $53, $41, $47, $49, $4e, $47, $20, $44, $41, $54, $41, $42, $41
	.byte  $53, $45, $20, $43, $52, $45, $41, $54, $45, $44, $20, $53, $55, $43, $43, $45
	.byte  $53, $53, $46, $55, $4c, $4c, $59, $00
string_144	; PETSCII:"=== Inbox ==="
	.byte  $3d, $3d, $3d, $20, $c9, $4e, $42, $4f, $58, $20, $3d, $3d, $3d, $00
string_145	; PETSCII:" ("
	.byte  $20, $28, $00
string_146	; PETSCII:" unread)"
	.byte  $20, $55, $4e, $52, $45, $41, $44, $29, $00
string_147	; PETSCII:"No messages."
	.byte  $ce, $4f, $20, $4d, $45, $53, $53, $41, $47, $45, $53, $2e, $00
string_148	; PETSCII:"* "
	.byte  $2a, $20, $00
string_149	; PETSCII:"  "
	.byte  $20, $20, $00
string_15	; PETSCII:"BBS shutdown complete."
	.byte  $c2, $c2, $d3, $20, $53, $48, $55, $54, $44, $4f, $57, $4e, $20, $43, $4f, $4d
	.byte  $50, $4c, $45, $54, $45, $2e, $00
string_150	; PETSCII:" from "
	.byte  $20, $46, $52, $4f, $4d, $20, $00
string_151	; PETSCII:"Message sent successfully!"
	.byte  $cd, $45, $53, $53, $41, $47, $45, $20, $53, $45, $4e, $54, $20, $53, $55, $43
	.byte  $43, $45, $53, $53, $46, $55, $4c, $4c, $59, $21, $00
string_152	; PETSCII:"=== Private Messages ==="
	.byte  $3d, $3d, $3d, $20, $d0, $52, $49, $56, $41, $54, $45, $20, $cd, $45, $53, $53
	.byte  $41, $47, $45, $53, $20, $3d, $3d, $3d, $00
string_153	; PETSCII:"1. Read Inbox"
	.byte  $31, $2e, $20, $d2, $45, $41, $44, $20, $c9, $4e, $42, $4f, $58, $00
string_154	; PETSCII:"2. Send Message"
	.byte  $32, $2e, $20, $d3, $45, $4e, $44, $20, $cd, $45, $53, $53, $41, $47, $45, $00
string_155	; PETSCII:"3. Delete Message"
	.byte  $33, $2e, $20, $c4, $45, $4c, $45, $54, $45, $20, $cd, $45, $53, $53, $41, $47
	.byte  $45, $00
string_156	; PETSCII:"Enter message number to read (or 0 to go back): "
	.byte  $c5, $4e, $54, $45, $52, $20, $4d, $45, $53, $53, $41, $47, $45, $20, $4e, $55
	.byte  $4d, $42, $45, $52, $20, $54, $4f, $20, $52, $45, $41, $44, $20, $28, $4f, $52
	.byte  $20, $30, $20, $54, $4f, $20, $47, $4f, $20, $42, $41, $43, $4b, $29, $3a, $20
	.byte  $00
string_157	; PETSCII:"Message not found or access denied."
	.byte  $cd, $45, $53, $53, $41, $47, $45, $20, $4e, $4f, $54, $20, $46, $4f, $55, $4e
	.byte  $44, $20, $4f, $52, $20, $41, $43, $43, $45, $53, $53, $20, $44, $45, $4e, $49
	.byte  $45, $44, $2e, $00
string_158	; PETSCII:"To: "
	.byte  $d4, $4f, $3a, $20, $00
string_159	; PETSCII:"Enter message number to delete (or 0 to cancel): "
	.byte  $c5, $4e, $54, $45, $52, $20, $4d, $45, $53, $53, $41, $47, $45, $20, $4e, $55
	.byte  $4d, $42, $45, $52, $20, $54, $4f, $20, $44, $45, $4c, $45, $54, $45, $20, $28
	.byte  $4f, $52, $20, $30, $20, $54, $4f, $20, $43, $41, $4e, $43, $45, $4c, $29, $3a
	.byte  $20, $00
string_160	; PETSCII:"Message deleted."
	.byte  $cd, $45, $53, $53, $41, $47, $45, $20, $44, $45, $4c, $45, $54, $45, $44, $2e
	.byte  $00
string_161	; PETSCII:"Error deleting message."
	.byte  $c5, $52, $52, $4f, $52, $20, $44, $45, $4c, $45, $54, $49, $4e, $47, $20, $4d
	.byte  $45, $53, $53, $41, $47, $45, $2e, $00
string_162	; PETSCII:"=== File Listing ==="
	.byte  $3d, $3d, $3d, $20, $c6, $49, $4c, $45, $20, $cc, $49, $53, $54, $49, $4e, $47
	.byte  $20, $3d, $3d, $3d, $00
string_163	; PETSCII:"Files:"
	.byte  $c6, $49, $4c, $45, $53, $3a, $00
string_164	; PETSCII:")"
	.byte  $29, $00
string_165	; PETSCII:"... (more files available)"
	.byte  $2e, $2e, $2e, $20, $28, $4d, $4f, $52, $45, $20, $46, $49, $4c, $45, $53, $20
	.byte  $41, $56, $41, $49, $4c, $41, $42, $4c, $45, $29, $00
string_166	; PETSCII:"Total: "
	.byte  $d4, $4f, $54, $41, $4c, $3a, $20, $00
string_167	; PETSCII:" files"
	.byte  $20, $46, $49, $4c, $45, $53, $00
string_168	; PETSCII:"Error listing files."
	.byte  $c5, $52, $52, $4f, $52, $20, $4c, $49, $53, $54, $49, $4e, $47, $20, $46, $49
	.byte  $4c, $45, $53, $2e, $00
string_169	; PETSCII:"Downloading: "
	.byte  $c4, $4f, $57, $4e, $4c, $4f, $41, $44, $49, $4e, $47, $3a, $20, $00
string_170	; PETSCII:"File not found."
	.byte  $c6, $49, $4c, $45, $20, $4e, $4f, $54, $20, $46, $4f, $55, $4e, $44, $2e, $00
string_171	; PETSCII:"Error opening file."
	.byte  $c5, $52, $52, $4f, $52, $20, $4f, $50, $45, $4e, $49, $4e, $47, $20, $46, $49
	.byte  $4c, $45, $2e, $00
string_172	; PETSCII:"File transfer starting..."
	.byte  $c6, $49, $4c, $45, $20, $54, $52, $41, $4e, $53, $46, $45, $52, $20, $53, $54
	.byte  $41, $52, $54, $49, $4e, $47, $2e, $2e, $2e, $00
string_173	; PETSCII:"Transfer error occurred."
	.byte  $d4, $52, $41, $4e, $53, $46, $45, $52, $20, $45, $52, $52, $4f, $52, $20, $4f
	.byte  $43, $43, $55, $52, $52, $45, $44, $2e, $00
string_174	; PETSCII:"Transfer complete: "
	.byte  $d4, $52, $41, $4e, $53, $46, $45, $52, $20, $43, $4f, $4d, $50, $4c, $45, $54
	.byte  $45, $3a, $20, $00
string_175	; PETSCII:"Upload: "
	.byte  $d5, $50, $4c, $4f, $41, $44, $3a, $20, $00
string_176	; PETSCII:"Maximum size: "
	.byte  $cd, $41, $58, $49, $4d, $55, $4d, $20, $53, $49, $5a, $45, $3a, $20, $00
string_177	; PETSCII:"Send file now (or type 'cancel' to abort):"
	.byte  $d3, $45, $4e, $44, $20, $46, $49, $4c, $45, $20, $4e, $4f, $57, $20, $28, $4f
	.byte  $52, $20, $54, $59, $50, $45, $20, $27, $43, $41, $4e, $43, $45, $4c, $27, $20
	.byte  $54, $4f, $20, $41, $42, $4f, $52, $54, $29, $3a, $00
string_178	; PETSCII:"Upload permission denied."
	.byte  $d5, $50, $4c, $4f, $41, $44, $20, $50, $45, $52, $4d, $49, $53, $53, $49, $4f
	.byte  $4e, $20, $44, $45, $4e, $49, $45, $44, $2e, $00
string_179	; PETSCII:"Error creating file."
	.byte  $c5, $52, $52, $4f, $52, $20, $43, $52, $45, $41, $54, $49, $4e, $47, $20, $46
	.byte  $49, $4c, $45, $2e, $00
string_18	; PETSCII:"Loading config..."
	.byte  $cc, $4f, $41, $44, $49, $4e, $47, $20, $43, $4f, $4e, $46, $49, $47, $2e, $2e
	.byte  $2e, $00
string_180	; PETSCII:"Ready to receive file..."
	.byte  $d2, $45, $41, $44, $59, $20, $54, $4f, $20, $52, $45, $43, $45, $49, $56, $45
	.byte  $20, $46, $49, $4c, $45, $2e, $2e, $2e, $00
string_181	; PETSCII:"."
	.byte  $2e, $00
string_182	; PETSCII:"Upload cancelled."
	.byte  $d5, $50, $4c, $4f, $41, $44, $20, $43, $41, $4e, $43, $45, $4c, $4c, $45, $44
	.byte  $2e, $00
string_183	; PETSCII:"Upload complete: "
	.byte  $d5, $50, $4c, $4f, $41, $44, $20, $43, $4f, $4d, $50, $4c, $45, $54, $45, $3a
	.byte  $20, $00
string_184	; PETSCII:"=== File Areas ==="
	.byte  $3d, $3d, $3d, $20, $c6, $49, $4c, $45, $20, $c1, $52, $45, $41, $53, $20, $3d
	.byte  $3d, $3d, $00
string_185	; PETSCII:"1. List Files"
	.byte  $31, $2e, $20, $cc, $49, $53, $54, $20, $c6, $49, $4c, $45, $53, $00
string_186	; PETSCII:"2. Download File"
	.byte  $32, $2e, $20, $c4, $4f, $57, $4e, $4c, $4f, $41, $44, $20, $c6, $49, $4c, $45
	.byte  $00
string_187	; PETSCII:"3. Upload File"
	.byte  $33, $2e, $20, $d5, $50, $4c, $4f, $41, $44, $20, $c6, $49, $4c, $45, $00
string_188	; PETSCII:"Enter file pattern (or * for all): "
	.byte  $c5, $4e, $54, $45, $52, $20, $46, $49, $4c, $45, $20, $50, $41, $54, $54, $45
	.byte  $52, $4e, $20, $28, $4f, $52, $20, $2a, $20, $46, $4f, $52, $20, $41, $4c, $4c
	.byte  $29, $3a, $20, $00
string_189	; PETSCII:"*"
	.byte  $2a, $00
string_19	; PETSCII:"Config file not found."
	.byte  $c3, $4f, $4e, $46, $49, $47, $20, $46, $49, $4c, $45, $20, $4e, $4f, $54, $20
	.byte  $46, $4f, $55, $4e, $44, $2e, $00
string_190	; PETSCII:"Enter filename: "
	.byte  $c5, $4e, $54, $45, $52, $20, $46, $49, $4c, $45, $4e, $41, $4d, $45, $3a, $20
	.byte  $00
string_191	; PETSCII:"Upload permission denied. Level 2+ required."
	.byte  $d5, $50, $4c, $4f, $41, $44, $20, $50, $45, $52, $4d, $49, $53, $53, $49, $4f
	.byte  $4e, $20, $44, $45, $4e, $49, $45, $44, $2e, $20, $cc, $45, $56, $45, $4c, $20
	.byte  $32, $2b, $20, $52, $45, $51, $55, $49, $52, $45, $44, $2e, $00
string_194	; PETSCII:"bbsconfig"
	.byte  $42, $42, $53, $43, $4f, $4e, $46, $49, $47, $00
string_195	; PETSCII:"bbsusers"
	.byte  $42, $42, $53, $55, $53, $45, $52, $53, $00
string_196	; PETSCII:"bbsmsgs"
	.byte  $42, $42, $53, $4d, $53, $47, $53, $00
string_197	; PETSCII:"bbsmail"
	.byte  $42, $42, $53, $4d, $41, $49, $4c, $00
string_198	; PETSCII:"files"
	.byte  $46, $49, $4c, $45, $53, $00
string_2	; PETSCII:"No configuration file found."
	.byte  $ce, $4f, $20, $43, $4f, $4e, $46, $49, $47, $55, $52, $41, $54, $49, $4f, $4e
	.byte  $20, $46, $49, $4c, $45, $20, $46, $4f, $55, $4e, $44, $2e, $00
string_20	; PETSCII:"Error: Could not load config file"
	.byte  $c5, $52, $52, $4f, $52, $3a, $20, $c3, $4f, $55, $4c, $44, $20, $4e, $4f, $54
	.byte  $20, $4c, $4f, $41, $44, $20, $43, $4f, $4e, $46, $49, $47, $20, $46, $49, $4c
	.byte  $45, $00
string_21	; PETSCII:"Loaded: "
	.byte  $cc, $4f, $41, $44, $45, $44, $3a, $20, $00
string_22	; PETSCII:" bytes"
	.byte  $20, $42, $59, $54, $45, $53, $00
string_23	; PETSCII:""
	.byte  $00
string_24	; PETSCII:"Error: Config file too large or malformed"
	.byte  $c5, $52, $52, $4f, $52, $3a, $20, $c3, $4f, $4e, $46, $49, $47, $20, $46, $49
	.byte  $4c, $45, $20, $54, $4f, $4f, $20, $4c, $41, $52, $47, $45, $20, $4f, $52, $20
	.byte  $4d, $41, $4c, $46, $4f, $52, $4d, $45, $44, $00
string_25	; PETSCII:"Config loaded: "
	.byte  $c3, $4f, $4e, $46, $49, $47, $20, $4c, $4f, $41, $44, $45, $44, $3a, $20, $00
string_26	; PETSCII:" entries"
	.byte  $20, $45, $4e, $54, $52, $49, $45, $53, $00
string_27	; PETSCII:"Saving config..."
	.byte  $d3, $41, $56, $49, $4e, $47, $20, $43, $4f, $4e, $46, $49, $47, $2e, $2e, $2e
	.byte  $00
string_28	; PETSCII:"Error: Could not open config file for writing"
	.byte  $c5, $52, $52, $4f, $52, $3a, $20, $c3, $4f, $55, $4c, $44, $20, $4e, $4f, $54
	.byte  $20, $4f, $50, $45, $4e, $20, $43, $4f, $4e, $46, $49, $47, $20, $46, $49, $4c
	.byte  $45, $20, $46, $4f, $52, $20, $57, $52, $49, $54, $49, $4e, $47, $00
string_29	; PETSCII:"Config saved successfully"
	.byte  $c3, $4f, $4e, $46, $49, $47, $20, $53, $41, $56, $45, $44, $20, $53, $55, $43
	.byte  $43, $45, $53, $53, $46, $55, $4c, $4c, $59, $00
string_3	; PETSCII:"Entering setup mode..."
	.byte  $c5, $4e, $54, $45, $52, $49, $4e, $47, $20, $53, $45, $54, $55, $50, $20, $4d
	.byte  $4f, $44, $45, $2e, $2e, $2e, $00
string_30	; PETSCII:"$"
	.byte  $24, $00
string_36	; PETSCII:"=== ColorX128 BBS Setup ==="
	.byte  $3d, $3d, $3d, $20, $c3, $4f, $4c, $4f, $52, $d8, $31, $32, $38, $20, $c2, $c2
	.byte  $d3, $20, $d3, $45, $54, $55, $50, $20, $3d, $3d, $3d, $00
string_37	; PETSCII:"Welcome to the BBS setup wizard."
	.byte  $d7, $45, $4c, $43, $4f, $4d, $45, $20, $54, $4f, $20, $54, $48, $45, $20, $c2
	.byte  $c2, $d3, $20, $53, $45, $54, $55, $50, $20, $57, $49, $5a, $41, $52, $44, $2e
	.byte  $00
string_38	; PETSCII:"This will help you configure your BBS."
	.byte  $d4, $48, $49, $53, $20, $57, $49, $4c, $4c, $20, $48, $45, $4c, $50, $20, $59
	.byte  $4f, $55, $20, $43, $4f, $4e, $46, $49, $47, $55, $52, $45, $20, $59, $4f, $55
	.byte  $52, $20, $c2, $c2, $d3, $2e, $00
string_39	; PETSCII:"BBS Name: "
	.byte  $c2, $c2, $d3, $20, $ce, $41, $4d, $45, $3a, $20, $00
string_4	; PETSCII:"FATAL: Could not load configuration after setup!"
	.byte  $c6, $c1, $d4, $c1, $cc, $3a, $20, $c3, $4f, $55, $4c, $44, $20, $4e, $4f, $54
	.byte  $20, $4c, $4f, $41, $44, $20, $43, $4f, $4e, $46, $49, $47, $55, $52, $41, $54
	.byte  $49, $4f, $4e, $20, $41, $46, $54, $45, $52, $20, $53, $45, $54, $55, $50, $21
	.byte  $00
string_40	; PETSCII:"bbsname"
	.byte  $42, $42, $53, $4e, $41, $4d, $45, $00
string_41	; PETSCII:"ColorX128 BBS"
	.byte  $c3, $4f, $4c, $4f, $52, $d8, $31, $32, $38, $20, $c2, $c2, $d3, $00
string_42	; PETSCII:"SysOp Name: "
	.byte  $d3, $59, $53, $cf, $50, $20, $ce, $41, $4d, $45, $3a, $20, $00
string_43	; PETSCII:"sysopname"
	.byte  $53, $59, $53, $4f, $50, $4e, $41, $4d, $45, $00
string_44	; PETSCII:"SysOp"
	.byte  $d3, $59, $53, $cf, $50, $00
string_45	; PETSCII:"Disk Drive Number (8-11): "
	.byte  $c4, $49, $53, $4b, $20, $c4, $52, $49, $56, $45, $20, $ce, $55, $4d, $42, $45
	.byte  $52, $20, $28, $38, $2d, $31, $31, $29, $3a, $20, $00
string_46	; PETSCII:"drive"
	.byte  $44, $52, $49, $56, $45, $00
string_47	; PETSCII:"Maximum Users: "
	.byte  $cd, $41, $58, $49, $4d, $55, $4d, $20, $d5, $53, $45, $52, $53, $3a, $20, $00
string_48	; PETSCII:"maxusers"
	.byte  $4d, $41, $58, $55, $53, $45, $52, $53, $00
string_49	; PETSCII:"100"
	.byte  $31, $30, $30, $00
string_5	; PETSCII:"Exiting..."
	.byte  $c5, $58, $49, $54, $49, $4e, $47, $2e, $2e, $2e, $00
string_50	; PETSCII:"Time Limit (minutes, 0=unlimited): "
	.byte  $d4, $49, $4d, $45, $20, $cc, $49, $4d, $49, $54, $20, $28, $4d, $49, $4e, $55
	.byte  $54, $45, $53, $2c, $20, $30, $3d, $55, $4e, $4c, $49, $4d, $49, $54, $45, $44
	.byte  $29, $3a, $20, $00
string_51	; PETSCII:"timelimit"
	.byte  $54, $49, $4d, $45, $4c, $49, $4d, $49, $54, $00
string_52	; PETSCII:"60"
	.byte  $36, $30, $00
string_53	; PETSCII:"Default User Level (0-9): "
	.byte  $c4, $45, $46, $41, $55, $4c, $54, $20, $d5, $53, $45, $52, $20, $cc, $45, $56
	.byte  $45, $4c, $20, $28, $30, $2d, $39, $29, $3a, $20, $00
string_54	; PETSCII:"defaultlevel"
	.byte  $44, $45, $46, $41, $55, $4c, $54, $4c, $45, $56, $45, $4c, $00
string_55	; PETSCII:"0"
	.byte  $30, $00
string_56	; PETSCII:"Setup complete!"
	.byte  $d3, $45, $54, $55, $50, $20, $43, $4f, $4d, $50, $4c, $45, $54, $45, $21, $00
string_57	; PETSCII:"Saving configuration..."
	.byte  $d3, $41, $56, $49, $4e, $47, $20, $43, $4f, $4e, $46, $49, $47, $55, $52, $41
	.byte  $54, $49, $4f, $4e, $2e, $2e, $2e, $00
string_58	; PETSCII:"Configuration saved successfully."
	.byte  $c3, $4f, $4e, $46, $49, $47, $55, $52, $41, $54, $49, $4f, $4e, $20, $53, $41
	.byte  $56, $45, $44, $20, $53, $55, $43, $43, $45, $53, $53, $46, $55, $4c, $4c, $59
	.byte  $2e, $00
string_59	; PETSCII:"Press any key to continue..."
	.byte  $d0, $52, $45, $53, $53, $20, $41, $4e, $59, $20, $4b, $45, $59, $20, $54, $4f
	.byte  $20, $43, $4f, $4e, $54, $49, $4e, $55, $45, $2e, $2e, $2e, $00
string_6	; PETSCII:"BBS starting..."
	.byte  $c2, $c2, $d3, $20, $53, $54, $41, $52, $54, $49, $4e, $47, $2e, $2e, $2e, $00
string_60	; PETSCII:"ERROR: Failed to save configuration!"
	.byte  $c5, $d2, $d2, $cf, $d2, $3a, $20, $c6, $41, $49, $4c, $45, $44, $20, $54, $4f
	.byte  $20, $53, $41, $56, $45, $20, $43, $4f, $4e, $46, $49, $47, $55, $52, $41, $54
	.byte  $49, $4f, $4e, $21, $00
string_61	; PETSCII:"Press any key to exit..."
	.byte  $d0, $52, $45, $53, $53, $20, $41, $4e, $59, $20, $4b, $45, $59, $20, $54, $4f
	.byte  $20, $45, $58, $49, $54, $2e, $2e, $2e, $00
string_62	; PETSCII:"Error initializing serial device: "
	.byte  $c5, $52, $52, $4f, $52, $20, $49, $4e, $49, $54, $49, $41, $4c, $49, $5a, $49
	.byte  $4e, $47, $20, $53, $45, $52, $49, $41, $4c, $20, $44, $45, $56, $49, $43, $45
	.byte  $3a, $20, $00
string_63	; PETSCII:"Waiting for connection..."
	.byte  $d7, $41, $49, $54, $49, $4e, $47, $20, $46, $4f, $52, $20, $43, $4f, $4e, $4e
	.byte  $45, $43, $54, $49, $4f, $4e, $2e, $2e, $2e, $00
string_64	; PETSCII:"Connection detected!"
	.byte  $c3, $4f, $4e, $4e, $45, $43, $54, $49, $4f, $4e, $20, $44, $45, $54, $45, $43
	.byte  $54, $45, $44, $21, $00
string_65	; PETSCII:"Connection timeout"
	.byte  $c3, $4f, $4e, $4e, $45, $43, $54, $49, $4f, $4e, $20, $54, $49, $4d, $45, $4f
	.byte  $55, $54, $00
string_66	; PETSCII:"Welcome to "
	.byte  $d7, $45, $4c, $43, $4f, $4d, $45, $20, $54, $4f, $20, $00
string_67	; PETSCII:"!"
	.byte  $21, $00
string_68	; PETSCII:"Login failed. Disconnecting..."
	.byte  $cc, $4f, $47, $49, $4e, $20, $46, $41, $49, $4c, $45, $44, $2e, $20, $c4, $49
	.byte  $53, $43, $4f, $4e, $4e, $45, $43, $54, $49, $4e, $47, $2e, $2e, $2e, $00
string_69	; PETSCII:"Welcome, "
	.byte  $d7, $45, $4c, $43, $4f, $4d, $45, $2c, $20, $00
string_7	; PETSCII:"Initializing serial communication..."
	.byte  $c9, $4e, $49, $54, $49, $41, $4c, $49, $5a, $49, $4e, $47, $20, $53, $45, $52
	.byte  $49, $41, $4c, $20, $43, $4f, $4d, $4d, $55, $4e, $49, $43, $41, $54, $49, $4f
	.byte  $4e, $2e, $2e, $2e, $00
string_70	; PETSCII:"Connection closed."
	.byte  $c3, $4f, $4e, $4e, $45, $43, $54, $49, $4f, $4e, $20, $43, $4c, $4f, $53, $45
	.byte  $44, $2e, $00
string_71	; PETSCII:"WARNING: Could not initialize user database!"
	.byte  $d7, $c1, $d2, $ce, $c9, $ce, $c7, $3a, $20, $c3, $4f, $55, $4c, $44, $20, $4e
	.byte  $4f, $54, $20, $49, $4e, $49, $54, $49, $41, $4c, $49, $5a, $45, $20, $55, $53
	.byte  $45, $52, $20, $44, $41, $54, $41, $42, $41, $53, $45, $21, $00
string_72	; PETSCII:"=== Login Required ==="
	.byte  $3d, $3d, $3d, $20, $cc, $4f, $47, $49, $4e, $20, $d2, $45, $51, $55, $49, $52
	.byte  $45, $44, $20, $3d, $3d, $3d, $00
string_73	; PETSCII:"Username: "
	.byte  $d5, $53, $45, $52, $4e, $41, $4d, $45, $3a, $20, $00
string_74	; PETSCII:"Username cannot be empty."
	.byte  $d5, $53, $45, $52, $4e, $41, $4d, $45, $20, $43, $41, $4e, $4e, $4f, $54, $20
	.byte  $42, $45, $20, $45, $4d, $50, $54, $59, $2e, $00
string_75	; PETSCII:"Password: "
	.byte  $d0, $41, $53, $53, $57, $4f, $52, $44, $3a, $20, $00
string_76	; PETSCII:"Login successful!"
	.byte  $cc, $4f, $47, $49, $4e, $20, $53, $55, $43, $43, $45, $53, $53, $46, $55, $4c
	.byte  $21, $00
string_77	; PETSCII:"Invalid username or password."
	.byte  $c9, $4e, $56, $41, $4c, $49, $44, $20, $55, $53, $45, $52, $4e, $41, $4d, $45
	.byte  $20, $4f, $52, $20, $50, $41, $53, $53, $57, $4f, $52, $44, $2e, $00
string_78	; PETSCII:"Attempts remaining: "
	.byte  $c1, $54, $54, $45, $4d, $50, $54, $53, $20, $52, $45, $4d, $41, $49, $4e, $49
	.byte  $4e, $47, $3a, $20, $00
string_79	; PETSCII:"Maximum login attempts exceeded."
	.byte  $cd, $41, $58, $49, $4d, $55, $4d, $20, $4c, $4f, $47, $49, $4e, $20, $41, $54
	.byte  $54, $45, $4d, $50, $54, $53, $20, $45, $58, $43, $45, $45, $44, $45, $44, $2e
	.byte  $00
string_8	; PETSCII:"ERROR: Failed to initialize serial communication!"
	.byte  $c5, $d2, $d2, $cf, $d2, $3a, $20, $c6, $41, $49, $4c, $45, $44, $20, $54, $4f
	.byte  $20, $49, $4e, $49, $54, $49, $41, $4c, $49, $5a, $45, $20, $53, $45, $52, $49
	.byte  $41, $4c, $20, $43, $4f, $4d, $4d, $55, $4e, $49, $43, $41, $54, $49, $4f, $4e
	.byte  $21, $00
string_80	; PETSCII:"Connection terminated."
	.byte  $c3, $4f, $4e, $4e, $45, $43, $54, $49, $4f, $4e, $20, $54, $45, $52, $4d, $49
	.byte  $4e, $41, $54, $45, $44, $2e, $00
string_81	; PETSCII:"Creating user database..."
	.byte  $c3, $52, $45, $41, $54, $49, $4e, $47, $20, $55, $53, $45, $52, $20, $44, $41
	.byte  $54, $41, $42, $41, $53, $45, $2e, $2e, $2e, $00
string_83	; PETSCII:"bbsusers,L,64,R,100"
	.byte  $42, $42, $53, $55, $53, $45, $52, $53, $2c, $cc, $2c, $36, $34, $2c, $d2, $2c
	.byte  $31, $30, $30, $00
string_84	; PETSCII:"Error creating REL file: "
	.byte  $c5, $52, $52, $4f, $52, $20, $43, $52, $45, $41, $54, $49, $4e, $47, $20, $d2
	.byte  $c5, $cc, $20, $46, $49, $4c, $45, $3a, $20, $00
string_85	; PETSCII:"User database created successfully"
	.byte  $d5, $53, $45, $52, $20, $44, $41, $54, $41, $42, $41, $53, $45, $20, $43, $52
	.byte  $45, $41, $54, $45, $44, $20, $53, $55, $43, $43, $45, $53, $53, $46, $55, $4c
	.byte  $4c, $59, $00
string_86	; PETSCII:"=== Main Menu ==="
	.byte  $3d, $3d, $3d, $20, $cd, $41, $49, $4e, $20, $cd, $45, $4e, $55, $20, $3d, $3d
	.byte  $3d, $00
string_87	; PETSCII:"1. Message Boards"
	.byte  $31, $2e, $20, $cd, $45, $53, $53, $41, $47, $45, $20, $c2, $4f, $41, $52, $44
	.byte  $53, $00
string_88	; PETSCII:"2. Private Messages"
	.byte  $32, $2e, $20, $d0, $52, $49, $56, $41, $54, $45, $20, $cd, $45, $53, $53, $41
	.byte  $47, $45, $53, $00
string_89	; PETSCII:"3. File Areas"
	.byte  $33, $2e, $20, $c6, $49, $4c, $45, $20, $c1, $52, $45, $41, $53, $00
string_9	; PETSCII:"Serial communication ready on Device 2"
	.byte  $d3, $45, $52, $49, $41, $4c, $20, $43, $4f, $4d, $4d, $55, $4e, $49, $43, $41
	.byte  $54, $49, $4f, $4e, $20, $52, $45, $41, $44, $59, $20, $4f, $4e, $20, $c4, $45
	.byte  $56, $49, $43, $45, $20, $32, $00
string_90	; PETSCII:"4. Games"
	.byte  $34, $2e, $20, $c7, $41, $4d, $45, $53, $00
string_91	; PETSCII:"5. SysOp Functions"
	.byte  $35, $2e, $20, $d3, $59, $53, $cf, $50, $20, $c6, $55, $4e, $43, $54, $49, $4f
	.byte  $4e, $53, $00
string_92	; PETSCII:"0. Logout"
	.byte  $30, $2e, $20, $cc, $4f, $47, $4f, $55, $54, $00
string_93	; PETSCII:"Enter choice: "
	.byte  $c5, $4e, $54, $45, $52, $20, $43, $48, $4f, $49, $43, $45, $3a, $20, $00
string_94	; PETSCII:"Invalid choice. Please enter a number."
	.byte  $c9, $4e, $56, $41, $4c, $49, $44, $20, $43, $48, $4f, $49, $43, $45, $2e, $20
	.byte  $d0, $4c, $45, $41, $53, $45, $20, $45, $4e, $54, $45, $52, $20, $41, $20, $4e
	.byte  $55, $4d, $42, $45, $52, $2e, $00
string_95	; PETSCII:"Logging out..."
	.byte  $cc, $4f, $47, $47, $49, $4e, $47, $20, $4f, $55, $54, $2e, $2e, $2e, $00
string_96	; PETSCII:"Invalid choice."
	.byte  $c9, $4e, $56, $41, $4c, $49, $44, $20, $43, $48, $4f, $49, $43, $45, $2e, $00
string_97	; PETSCII:"=== Games ==="
	.byte  $3d, $3d, $3d, $20, $c7, $41, $4d, $45, $53, $20, $3d, $3d, $3d, $00
string_98	; PETSCII:"Games are not yet implemented."
	.byte  $c7, $41, $4d, $45, $53, $20, $41, $52, $45, $20, $4e, $4f, $54, $20, $59, $45
	.byte  $54, $20, $49, $4d, $50, $4c, $45, $4d, $45, $4e, $54, $45, $44, $2e, $00
string_99	; PETSCII:"Press Enter to continue..."
	.byte  $d0, $52, $45, $53, $53, $20, $c5, $4e, $54, $45, $52, $20, $54, $4f, $20, $43
	.byte  $4f, $4e, $54, $49, $4e, $55, $45, $2e, $2e, $2e, $00

	; source: main.p8:20   txt.print("=== Configuration Required ===")
	; source: main.p8:23   txt.print("No configuration file found.")
	; source: main.p8:25   txt.print("Entering setup mode...")
	; source: main.p8:35   txt.print("FATAL: Could not load configuration after setup!")
	; source: main.p8:37   txt.print("Exiting...")
	; source: main.p8:44   txt.print("BBS starting...")
	; source: main.p8:48   txt.print("Initializing serial communication...")
	; source: main.p8:51   txt.print("ERROR: Failed to initialize serial communication!")
	; source: main.p8:58   txt.print("Serial communication ready on Device 2")
	; source: main.p8:75   txt.print("BBS is now online and waiting for connections.")
	; source: main.p8:77   txt.print("Press STOP key to shutdown.")
	; source: main.p8:89   txt.print("Session ended. Waiting for next connection...")
	; source: main.p8:94   txt.print("No connection received. Continue waiting? (Y/N)")
	; source: main.p8:105   txt.print("Shutting down BBS...")
	; source: main.p8:109   txt.print("BBS shutdown complete.")
	; source: config.p8:18   txt.print("Loading config...")
	; source: config.p8:26   txt.print("Config file not found.")
	; source: config.p8:37   txt.print("Error: Could not load config file")
	; source: config.p8:43   txt.print("Loaded: ")
	; source: config.p8:45   txt.print(" bytes")
	; source: config.p8:49   configword = ""
	; source: config.p8:84   txt.print("Error: Config file too large or malformed")
	; source: config.p8:90   txt.print("Config loaded: ")
	; source: config.p8:92   txt.print(" entries")
	; source: config.p8:101   txt.print("Saving config...")
	; source: config.p8:109   txt.print("Error: Could not open config file for writing")
	; source: config.p8:161   txt.print("Config saved successfully")
	; source: library:/prog8lib/shared_cbm_diskio.p8:35   cbm.SETNAM(1, "$")
	; source: setup.p8:12   txt.print("=== ColorX128 BBS Setup ===")
	; source: setup.p8:15   txt.print("Welcome to the BBS setup wizard.")
	; source: setup.p8:17   txt.print("This will help you configure your BBS.")
	; source: setup.p8:25   txt.print("BBS Name: ")
	; source: setup.p8:28   config.setdirective("bbsname", bbs_name)
	; source: setup.p8:30   config.setdirective("bbsname", "ColorX128 BBS")
	; source: setup.p8:35   txt.print("SysOp Name: ")
	; source: setup.p8:38   config.setdirective("sysopname", sysop_name)
	; source: setup.p8:40   config.setdirective("sysopname", "SysOp")
	; source: setup.p8:45   txt.print("Disk Drive Number (8-11): ")
	; source: setup.p8:55   config.setdirective("drive", conv.str_ub(drive_num))
	; source: setup.p8:60   txt.print("Maximum Users: ")
	; source: setup.p8:63   config.setdirective("maxusers", max_users_input)
	; source: setup.p8:65   config.setdirective("maxusers", "100")
	; source: setup.p8:70   txt.print("Time Limit (minutes, 0=unlimited): ")
	; source: setup.p8:73   config.setdirective("timelimit", time_limit_input)
	; source: setup.p8:75   config.setdirective("timelimit", "60")
	; source: setup.p8:80   txt.print("Default User Level (0-9): ")
	; source: setup.p8:83   config.setdirective("defaultlevel", user_level_input)
	; source: setup.p8:85   config.setdirective("defaultlevel", "0")
	; source: setup.p8:90   txt.print("Setup complete!")
	; source: setup.p8:92   txt.print("Saving configuration...")
	; source: setup.p8:97   txt.print("Configuration saved successfully.")
	; source: setup.p8:100   txt.print("Press any key to continue...")
	; source: setup.p8:104   txt.print("ERROR: Failed to save configuration!")
	; source: setup.p8:106   txt.print("Press any key to exit...")
	; source: com.p8:37   txt.print("Error initializing serial device: ")
	; source: session.p8:44   txt.print("Waiting for connection...")
	; source: session.p8:55   txt.print("Connection detected!")
	; source: session.p8:66   txt.print("Connection timeout")
	; source: session.p8:81   com.write_str("Welcome to ")
	; source: session.p8:83   com.write_str("!")
	; source: session.p8:197   send_line("Login failed. Disconnecting...")
	; source: session.p8:207   send_string("Welcome, ")
	; source: session.p8:220   send_line("Connection closed.")
	; source: login.p8:27   txt.print("WARNING: Could not initialize user database!")
	; source: login.p8:40   session.send_line("=== Login Required ===")
	; source: login.p8:45   session.send_string("Username: ")
	; source: login.p8:54   session.send_line("Username cannot be empty.")
	; source: login.p8:59   session.send_string("Password: ")
	; source: login.p8:78   session.send_line("Login successful!")
	; source: login.p8:87   session.send_line("Invalid username or password.")
	; source: login.p8:89   session.send_string("Attempts remaining: ")
	; source: login.p8:94   session.send_line("Maximum login attempts exceeded.")
	; source: login.p8:95   session.send_line("Connection terminated.")
	; source: userdb.p8:42   txt.print("Creating user database...")
	; source: userdb.p8:62   uword rel_filename = "bbsusers,L,64,R,100"
	; source: userdb.p8:71   txt.print("Error creating REL file: ")
	; source: userdb.p8:81   txt.print("User database created successfully")
	; source: menu.p8:29   session.send_line("=== Main Menu ===")
	; source: menu.p8:31   session.send_line("1. Message Boards")
	; source: menu.p8:32   session.send_line("2. Private Messages")
	; source: menu.p8:33   session.send_line("3. File Areas")
	; source: menu.p8:34   session.send_line("4. Games")
	; source: menu.p8:39   session.send_line("5. SysOp Functions")
	; source: menu.p8:43   session.send_line("0. Logout")
	; source: menu.p8:45   session.send_string("Enter choice: ")
	; source: menu.p8:60   session.send_line("Invalid choice. Please enter a number.")
	; source: menu.p8:69   session.send_line("Logging out...")
	; source: menu.p8:94   session.send_line("Invalid choice.")
	; source: menu.p8:118   session.send_line("=== Games ===")
	; source: menu.p8:120   session.send_line("Games are not yet implemented.")
	; source: menu.p8:122   session.send_string("Press Enter to continue...")
	; source: menu.p8:129   session.send_line("=== SysOp Functions ===")
	; source: menu.p8:131   session.send_line("SysOp functions are not yet implemented.")
	; source: menu.p8:167   session.send_line("=== BBS Information ===")
	; source: menu.p8:182   session.send_string("SysOp: ")
	; source: menu.p8:186   session.send_line("Status: Online")
	; source: menu.p8:191   session.send_string("Logged in as: ")
	; source: menu.p8:194   session.send_string("User Level: ")
	; source: boards.p8:47   txt.print("Creating message boards database...")
	; source: boards.p8:55   uword rel_filename = "bbsmsgs,L,128,R,500"
	; source: boards.p8:64   txt.print("Error creating message boards file: ")
	; source: boards.p8:74   txt.print("Message boards database created successfully")
	; source: boards.p8:222   session.send_line("=== Message Board ===")
	; source: boards.p8:223   session.send_string("Board: ")
	; source: boards.p8:262   session.send_line("No messages in this board.")
	; source: boards.p8:267   session.send_string("Messages: ")
	; source: boards.p8:303   session.send_string("[")
	; source: boards.p8:306   session.send_string("] ")
	; source: boards.p8:308   session.send_string(" by ")
	; source: boards.p8:334   session.send_line("=== Message ===")
	; source: boards.p8:341   session.send_string("Subject: ")
	; source: boards.p8:344   session.send_string("From: ")
	; source: boards.p8:366   session.send_line("Error: Message database full!")
	; source: boards.p8:439   session.send_line("Message posted successfully!")
	; source: boards.p8:452   session.send_line("=== Message Boards ===")
	; source: boards.p8:454   session.send_line("1. General Discussion")
	; source: boards.p8:455   session.send_line("2. Announcements")
	; source: boards.p8:456   session.send_line("3. Help & Support")
	; source: boards.p8:458   session.send_line("0. Return to Main Menu")
	; source: boards.p8:481   show_board("General")
	; source: boards.p8:484   show_board("Announce")
	; source: boards.p8:487   show_board("Help")
	; source: boards.p8:505   session.send_line("Options:")
	; source: boards.p8:506   session.send_line("1. Read message")
	; source: boards.p8:507   session.send_line("2. Post new message")
	; source: boards.p8:508   session.send_line("3. Reply to message")
	; source: boards.p8:510   session.send_line("0. Back to boards")
	; source: boards.p8:534   session.send_string("Enter message ID: ")
	; source: boards.p8:539   session.send_line("Message not found.")
	; source: boards.p8:548   session.send_string("Message: ")
	; source: boards.p8:557   session.send_string("Reply to message ID: ")
	; source: messaging.p8:44   txt.print("Creating messaging database...")
	; source: messaging.p8:51   uword rel_filename = "bbsmail,L,128,R,1000"
	; source: messaging.p8:60   txt.print("Error creating messaging file: ")
	; source: messaging.p8:70   txt.print("Messaging database created successfully")
	; source: messaging.p8:276   session.send_line("=== Inbox ===")
	; source: messaging.p8:285   session.send_string(" (")
	; source: messaging.p8:288   session.send_string(" unread)")
	; source: messaging.p8:293   session.send_line("No messages.")
	; source: messaging.p8:329   session.send_string("* ")  ; Unread
	; source: messaging.p8:331   session.send_string("  ")  ; Read
	; source: messaging.p8:339   session.send_string(" from ")
	; source: messaging.p8:482   session.send_line("Message sent successfully!")
	; source: messaging.p8:530   session.send_line("=== Private Messages ===")
	; source: messaging.p8:532   session.send_line("1. Read Inbox")
	; source: messaging.p8:533   session.send_line("2. Send Message")
	; source: messaging.p8:534   session.send_line("3. Delete Message")
	; source: messaging.p8:561   session.send_string("Enter message number to read (or 0 to go back): ")
	; source: messaging.p8:567   session.send_line("Message not found or access denied.")
	; source: messaging.p8:574   session.send_string("To: ")
	; source: messaging.p8:591   session.send_string("Enter message number to delete (or 0 to cancel): ")
	; source: messaging.p8:597   session.send_line("Message deleted.")
	; source: messaging.p8:599   session.send_line("Error deleting message.")
	; source: files.p8:28   session.send_line("=== File Listing ===")
	; source: files.p8:37   session.send_line("Files:")
	; source: files.p8:49   session.send_string(")")
	; source: files.p8:56   session.send_line("... (more files available)")
	; source: files.p8:64   session.send_string("Total: ")
	; source: files.p8:67   session.send_line(" files")
	; source: files.p8:69   session.send_line("Error listing files.")
	; source: files.p8:78   session.send_string("Downloading: ")
	; source: files.p8:86   session.send_line("File not found.")
	; source: files.p8:92   session.send_line("Error opening file.")
	; source: files.p8:96   session.send_line("File transfer starting...")
	; source: files.p8:131   session.send_line("Transfer error occurred.")
	; source: files.p8:136   session.send_string("Transfer complete: ")
	; source: files.p8:148   session.send_string("Upload: ")
	; source: files.p8:151   session.send_string("Maximum size: ")
	; source: files.p8:156   session.send_line("Send file now (or type 'cancel' to abort):")
	; source: files.p8:162   session.send_line("Upload permission denied.")
	; source: files.p8:170   session.send_line("Error creating file.")
	; source: files.p8:174   session.send_line("Ready to receive file...")
	; source: files.p8:217   session.send_string(".")
	; source: files.p8:237   session.send_line("Upload cancelled.")
	; source: files.p8:242   session.send_string("Upload complete: ")
	; source: files.p8:257   session.send_line("=== File Areas ===")
	; source: files.p8:259   session.send_line("1. List Files")
	; source: files.p8:260   session.send_line("2. Download File")
	; source: files.p8:261   session.send_line("3. Upload File")
	; source: files.p8:287   session.send_string("Enter file pattern (or * for all): ")
	; source: files.p8:291   pattern = "*"
	; source: files.p8:298   session.send_string("Enter filename: ")
	; source: files.p8:310   session.send_line("Upload permission denied. Level 2+ required.")
	; source: config.p8:8   uword configfilename = "bbsconfig"
	; source: userdb.p8:15   uword REL_FILENAME = "bbsusers"
	; source: boards.p8:18   uword REL_FILENAME = "bbsmsgs"
	; source: files.p8:17   uword @shared file_area = "files"  ; Default file area directory
	.pend

; ---- block: 'txt' ----
txt	.proc
	; source: library:/prog8lib/c128/textio.p8:10   txt {
	DEFAULT_HEIGHT = $19
	DEFAULT_WIDTH = $28

	chrout = $ffd2

	; source: library:/prog8lib/c128/textio.p8:13   const ubyte DEFAULT_WIDTH = 40
	; source: library:/prog8lib/c128/textio.p8:14   const ubyte DEFAULT_HEIGHT = 25
	; source: library:/prog8lib/c128/textio.p8:11   %option no_symbol_prefixing, ignore_unused
	; source: library:/prog8lib/c128/textio.p8:16   extsub $FFD2 = chrout(ubyte character @ A)    ; for consistency. You can also use cbm.CHROUT directly ofcourse. Note: takes a PETSCII encoded character.

	; source: library:/prog8lib/c128/textio.p8:23   asmsub column(ubyte col @A) clobbers(A, X, Y) {

column	.proc
	; source: library:/prog8lib/c128/textio.p8:25   %asm {{
        pha
        sec
        jsr  cbm.PLOT
        pla
        tay
        clc
        jmp  cbm.PLOT
	.pend
	; source: library:/prog8lib/c128/textio.p8:37   asmsub get_column() -> ubyte @Y {

get_column	.proc
	; source: library:/prog8lib/c128/textio.p8:38   %asm {{
        sec
        jmp cbm.PLOT
	.pend
	; source: library:/prog8lib/c128/textio.p8:44   asmsub row(ubyte rownum @A) clobbers(A, X, Y) {

row	.proc
	; source: library:/prog8lib/c128/textio.p8:46   %asm {{
        pha
        sec
        jsr  cbm.PLOT
        pla
        tax
        clc
        jmp  cbm.PLOT
	.pend
	; source: library:/prog8lib/c128/textio.p8:57   asmsub get_row() -> ubyte @X {

get_row	.proc
	; source: library:/prog8lib/c128/textio.p8:58   %asm {{
        sec
        jmp cbm.PLOT
	.pend
	; source: library:/prog8lib/c128/textio.p8:64   asmsub get_cursor() -> ubyte @X, ubyte @Y {

get_cursor	.proc
	; source: library:/prog8lib/c128/textio.p8:65   %asm {{
        sec
        jsr  cbm.PLOT
        stx  P8ZP_SCRATCH_REG  ; swap X and Y
        tya
        tax
        ldy  P8ZP_SCRATCH_REG
        rts
	.pend
	; source: library:/prog8lib/c128/textio.p8:77   asmsub  fill_screen (ubyte char @ A, ubyte color @ Y) clobbers(A)  {

fill_screen	.proc
	; source: library:/prog8lib/c128/textio.p8:81   %asm {{
		pha
		tya
		jsr  clear_screencolors
		pla
		jmp  clear_screenchars
	.pend
	; source: library:/prog8lib/c128/textio.p8:92   asmsub  clear_screenchars (ubyte char @ A) clobbers(Y)  {

clear_screenchars	.proc
	; source: library:/prog8lib/c128/textio.p8:95   %asm {{
		ldy  #250
-		sta  cbm.Screen+250*0-1,y
		sta  cbm.Screen+250*1-1,y
		sta  cbm.Screen+250*2-1,y
		sta  cbm.Screen+250*3-1,y
		dey
		bne  -
		rts
	.pend
	; source: library:/prog8lib/c128/textio.p8:107   asmsub  clear_screencolors (ubyte color @ A) clobbers(Y)  {

clear_screencolors	.proc
	; source: library:/prog8lib/c128/textio.p8:110   %asm {{
		ldy  #250
-		sta  cbm.Colors+250*0-1,y
		sta  cbm.Colors+250*1-1,y
		sta  cbm.Colors+250*2-1,y
		sta  cbm.Colors+250*3-1,y
		dey
		bne  -
		rts
	.pend
	; source: library:/prog8lib/c128/textio.p8:136   asmsub  scroll_left  (bool alsocolors @ Pc) clobbers(A, X, Y)  {

scroll_left	.proc
	; source: library:/prog8lib/c128/textio.p8:141   %asm {{
		bcc _scroll_screen

+               ; scroll the screen and the color memory
		ldx  #0
		ldy  #38
-
        .for row=0, row<=24, row+=1
            lda  cbm.Screen + 40*row + 1,x
            sta  cbm.Screen + 40*row + 0,x
            lda  cbm.Colors + 40*row + 1,x
            sta  cbm.Colors + 40*row + 0,x
        .next
		inx
		dey
		bpl  -
		rts

_scroll_screen  ; scroll only the screen memory
		ldx  #0
		ldy  #38
-
        .for row=0, row<=24, row+=1
            lda  cbm.Screen + 40*row + 1,x
            sta  cbm.Screen + 40*row + 0,x
        .next
		inx
		dey
		bpl  -

		rts
	.pend
	; source: library:/prog8lib/c128/textio.p8:175   asmsub  scroll_right  (bool alsocolors @ Pc) clobbers(A,X)  {

scroll_right	.proc
	; source: library:/prog8lib/c128/textio.p8:179   %asm {{
		bcc  _scroll_screen

+               ; scroll the screen and the color memory
		ldx  #38
-
        .for row=0, row<=24, row+=1
            lda  cbm.Screen + 40*row + 0,x
            sta  cbm.Screen + 40*row + 1,x
            lda  cbm.Colors + 40*row + 0,x
            sta  cbm.Colors + 40*row + 1,x
        .next
		dex
		bpl  -
		rts

_scroll_screen  ; scroll only the screen memory
		ldx  #38
-
        .for row=0, row<=24, row+=1
            lda  cbm.Screen + 40*row + 0,x
            sta  cbm.Screen + 40*row + 1,x
        .next
		dex
		bpl  -

		rts
	.pend
	; source: library:/prog8lib/c128/textio.p8:209   asmsub  scroll_up  (bool alsocolors @ Pc) clobbers(A,X)  {

scroll_up	.proc
	; source: library:/prog8lib/c128/textio.p8:213   %asm {{
		bcc  _scroll_screen

+               ; scroll the screen and the color memory
		ldx #39
-
        .for row=1, row<=24, row+=1
            lda  cbm.Screen + 40*row,x
            sta  cbm.Screen + 40*(row-1),x
            lda  cbm.Colors + 40*row,x
            sta  cbm.Colors + 40*(row-1),x
        .next
		dex
		bpl  -
		rts

_scroll_screen  ; scroll only the screen memory
		ldx #39
-
        .for row=1, row<=24, row+=1
            lda  cbm.Screen + 40*row,x
            sta  cbm.Screen + 40*(row-1),x
        .next
		dex
		bpl  -

		rts
	.pend
	; source: library:/prog8lib/c128/textio.p8:243   asmsub  scroll_down  (bool alsocolors @ Pc) clobbers(A,X)  {

scroll_down	.proc
	; source: library:/prog8lib/c128/textio.p8:247   %asm {{
		bcc  _scroll_screen

+               ; scroll the screen and the color memory
		ldx #39
-
        .for row=23, row>=0, row-=1
            lda  cbm.Colors + 40*row,x
            sta  cbm.Colors + 40*(row+1),x
            lda  cbm.Screen + 40*row,x
            sta  cbm.Screen + 40*(row+1),x
        .next
		dex
		bpl  -
		rts

_scroll_screen  ; scroll only the screen memory
		ldx #39
-
        .for row=23, row>=0, row-=1
            lda  cbm.Screen + 40*row,x
            sta  cbm.Screen + 40*(row+1),x
        .next
		dex
		bpl  -

		rts
	.pend
	; source: library:/prog8lib/c128/textio.p8:277   asmsub  setchr  (ubyte col @X, ubyte row @Y, ubyte character @A) clobbers(A, Y)  {

setchr	.proc
	; source: library:/prog8lib/c128/textio.p8:279   %asm {{
		pha
		tya
		asl  a
		tay
		lda  _screenrows+1,y
		sta  P8ZP_SCRATCH_W1+1
		txa
		clc
		adc  _screenrows,y
		sta  P8ZP_SCRATCH_W1
		bcc  +
		inc  P8ZP_SCRATCH_W1+1
+		pla
        ldy  #0
		sta  (P8ZP_SCRATCH_W1),y
		rts

_screenrows	.word  cbm.Screen + range(0, 1000, 40)
        ; !notreached!
	.pend
	; source: library:/prog8lib/c128/textio.p8:302   asmsub  getchr  (ubyte col @A, ubyte row @Y) clobbers(Y) -> ubyte @ A {

getchr	.proc
	; source: library:/prog8lib/c128/textio.p8:304   %asm  {{
		pha
		tya
		asl  a
		tay
		lda  setchr._screenrows+1,y
		sta  P8ZP_SCRATCH_W1+1
		pla
		clc
		adc  setchr._screenrows,y
		sta  P8ZP_SCRATCH_W1
		bcc  +
		inc  P8ZP_SCRATCH_W1+1
+		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		rts
	.pend
	; source: library:/prog8lib/c128/textio.p8:323   asmsub  setclr  (ubyte col @X, ubyte row @Y, ubyte color @A) clobbers(A, Y)  {

setclr	.proc
	; source: library:/prog8lib/c128/textio.p8:325   %asm {{
		pha
		tya
		asl  a
		tay
		lda  _colorrows+1,y
		sta  P8ZP_SCRATCH_W1+1
		txa
		clc
		adc  _colorrows,y
		sta  P8ZP_SCRATCH_W1
		bcc  +
		inc  P8ZP_SCRATCH_W1+1
+		pla
		ldy  #0
		sta  (P8ZP_SCRATCH_W1),y
		rts

_colorrows	.word  $d800 + range(0, 1000, 40)
        ; !notreached!
	.pend
	; source: library:/prog8lib/c128/textio.p8:348   asmsub  getclr  (ubyte col @A, ubyte row @Y) clobbers(Y) -> ubyte @ A {

getclr	.proc
	; source: library:/prog8lib/c128/textio.p8:350   %asm  {{
		pha
		tya
		asl  a
		tay
		lda  setclr._colorrows+1,y
		sta  P8ZP_SCRATCH_W1+1
		pla
		clc
		adc  setclr._colorrows,y
		sta  P8ZP_SCRATCH_W1
		bcc  +
		inc  P8ZP_SCRATCH_W1+1
+		ldy  #0
        lda  (P8ZP_SCRATCH_W1),y
		rts
	.pend
	; source: library:/prog8lib/c128/textio.p8:398   asmsub  plot  (ubyte col @ Y, ubyte row @ X) {

plot	.proc
	; source: library:/prog8lib/c128/textio.p8:399   %asm  {{
		clc
		jmp  cbm.PLOT
	.pend
	; source: library:/prog8lib/c128/textio.p8:405   asmsub width() clobbers(X,Y) -> ubyte @A {

width	.proc
	; source: library:/prog8lib/c128/textio.p8:407   %asm {{
        jsr  cbm.SCREEN
        inx
        txa
        rts
	.pend
	; source: library:/prog8lib/c128/textio.p8:415   asmsub height() clobbers(X, Y) -> ubyte @A {

height	.proc
	; source: library:/prog8lib/c128/textio.p8:417   %asm {{
        jsr  cbm.SCREEN
        iny
        tya
        rts
	.pend
	; source: library:/prog8lib/c128/textio.p8:425   asmsub size() clobbers(A) -> ubyte @X, ubyte @Y {

size	.proc
	; source: library:/prog8lib/c128/textio.p8:427   %asm {{
        jsr  cbm.SCREEN
        inx
        iny
        rts
	.pend
	; source: library:/prog8lib/c128/textio.p8:435   asmsub waitkey() -> ubyte @A {

waitkey	.proc
	; source: library:/prog8lib/c128/textio.p8:436   %asm {{
-       jsr cbm.GETIN
        beq -
        rts
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:35   asmsub  print (str text @ AY) clobbers(A,Y)  {

print	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:40   %asm {{
    		sta  P8ZP_SCRATCH_W2
    		sty  P8ZP_SCRATCH_W2+1
    		ldy  #0
-	    	lda  (P8ZP_SCRATCH_W2),y
    		beq  +
    		jsr  cbm.CHROUT
    		iny
    		bne  -
+	    	rts
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:53   asmsub  print_ubhex  (ubyte value @ A, bool prefix @ Pc) clobbers(A,X,Y)  {

print_ubhex	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:55   %asm {{
            bcc  +
            pha
            lda  #'$'
            jsr  cbm.CHROUT
            pla
+           jsr  conv.internal_ubyte2hex
            jsr  cbm.CHROUT
            tya
            jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:68   asmsub  print_ubbin  (ubyte value @ A, bool prefix @ Pc) clobbers(A,X,Y)  {

print_ubbin	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:70   %asm {{
            sta  P8ZP_SCRATCH_B1
            bcc  +
            lda  #'%'
            jsr  cbm.CHROUT
+           ldy  #8
-           lda  #'0'
            asl  P8ZP_SCRATCH_B1
            bcc  +
            lda  #'1'
+           jsr  cbm.CHROUT
            dey
            bne  -
            rts
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:87   asmsub  print_uwbin  (uword value @ AY, bool prefix @ Pc) clobbers(A,X,Y)  {

print_uwbin	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:89   %asm {{
            pha
            tya
            jsr  print_ubbin
            pla
            clc
            jmp  print_ubbin
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:99   asmsub  print_uwhex  (uword value @ AY, bool prefix @ Pc) clobbers(A,X,Y)  {

print_uwhex	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:102   %asm {{
            pha
            tya
            jsr  print_ubhex
            pla
            clc
            jmp  print_ubhex
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:118   asmsub  print_uw0  (uword value @ AY) clobbers(A,X,Y)  {

print_uw0	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:120   %asm {{
            jsr  conv.internal_uword2decimal
            ldy  #0
-           lda  conv.internal_uword2decimal.decTenThousands,y
            beq  +
            jsr  cbm.CHROUT
            iny
            bne  -
+           rts
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:132   asmsub  print_uw  (uword value @ AY) clobbers(A,X,Y)  {

print_uw	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:134   %asm {{
            jsr  conv.internal_uword2decimal
            ldy  #0
-           lda  conv.internal_uword2decimal.decTenThousands,y
            beq  _allzero
            cmp  #'0'
            bne  _gotdigit
            iny
            bne  -
_gotdigit   jsr  cbm.CHROUT
            iny
            lda  conv.internal_uword2decimal.decTenThousands,y
            bne  _gotdigit
            rts
_allzero    lda  #'0'
            jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:153   asmsub  print_w  (word value @ AY) clobbers(A,X,Y)  {

print_w	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:155   %asm {{
            cpy  #0
            bpl  +
            pha
            lda  #'-'
            jsr  cbm.CHROUT
            tya
            eor  #255
            tay
            pla
            eor  #255
            clc
            adc  #1
            bcc  +
            iny
+           jmp  print_uw
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:179   asmsub  input_chars  (^^ubyte buffer @ AY) clobbers(A) -> ubyte @ Y  {

input_chars	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:184   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0				; char counter = 0
-           jsr  cbm.CHRIN
            cmp  #$0d			; return (ascii 13) pressed?
            beq  +				; yes, end.
            sta  (P8ZP_SCRATCH_W1),y	; else store char in buffer
            iny
            bne  -
+           lda  #0
            sta  (P8ZP_SCRATCH_W1),y	; finish string with 0 byte
            rts
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:200   asmsub petscii2scr(ubyte petscii_char @A) -> ubyte @A {

petscii2scr	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:202   %asm {{
            sta  P8ZP_SCRATCH_REG
            lsr  a
            lsr  a
            lsr  a
            lsr  a
            lsr  a
            tax
            lda  _offsets,x
            eor  P8ZP_SCRATCH_REG
            rts
_offsets    .byte  128, 0, 64, 32, 64, 192, 128, 128
            ; !notreached!
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:218   asmsub petscii2scr_str(str petscii_string @AY) {

petscii2scr_str	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:220   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  +
            jsr  petscii2scr
            sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
+           rts
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:242   asmsub  print_ub0  (ubyte value @ A) clobbers(A,X,Y)  {

print_ub0	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:244   %asm {{
            jsr  conv.internal_ubyte2decimal
            pha
            tya
            jsr  cbm.CHROUT
            txa
            jsr  cbm.CHROUT
            pla
            jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:256   asmsub  print_ub  (ubyte value @ A) clobbers(A,X,Y)  {

print_ub	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:258   %asm {{
            jsr  conv.internal_ubyte2decimal
_print_byte_digits
            pha
            cpy  #'0'
            beq  +
            tya
            jsr  cbm.CHROUT
            txa
            jsr  cbm.CHROUT
            jmp  _ones
+           cpx  #'0'
            beq  _ones
            txa
            jsr  cbm.CHROUT
_ones       pla
            jmp  cbm.CHROUT
	.pend
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:278   asmsub  print_b  (byte value @ A) clobbers(A,X,Y)  {

print_b	.proc
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:280   %asm {{
            pha
            cmp  #0
            bpl  +
            lda  #'-'
            jsr  cbm.CHROUT
+		    pla
            jsr  conv.internal_byte2decimal
            jmp  print_ub._print_byte_digits
	.pend
	.pend

; ---- block: 'cbm' ----
cbm	.proc
	; source: library:/prog8lib/c128/syslib.p8:6   cbm {
	STATUS = $90
	STKEY = $91
	TIME_HI = $a0
	TIME_MID = $a1
	TIME_LO = $a2
	SHFLAG = $d3
	SFDX = $d4
	COLOR = $f1
	IERROR = $0300
	IMAIN = $0302
	ICRNCH = $0304
	IQPLOP = $0306
	IGONE = $0308
	IEVAL = $030a
	ICRNCH2 = $030c
	IQPLOP2 = $030e
	IGONE2 = $0310
	CINV = $0314
	CBINV = $0316
	NMINV = $0318
	IOPEN = $031a
	ICLOSE = $031c
	ICHKIN = $031e
	ICKOUT = $0320
	ICLRCH = $0322
	IBASIN = $0324
	IBSOUT = $0326
	ISTOP = $0328
	IGETIN = $032a
	ICLALL = $032c
	IEXMON = $032e
	ILOAD = $0330
	ISAVE = $0332
	NMI_VEC = $fffa
	RESET_VEC = $fffc
	IRQ_VEC = $fffe
	Colors = $d800
	Screen = $0400

	IRQDFRT = $fa65
	IRQDFEND = $ff33
	CINT = $ff81
	IOINIT = $ff84
	RAMTAS = $ff87
	RESTOR = $ff8a
	VECTOR = $ff8d
	SETMSG = $ff90
	SECOND = $ff93
	TKSA = $ff96
	MEMTOP = $ff99
	MEMBOT = $ff9c
	SCNKEY = $ff9f
	SETTMO = $ffa2
	ACPTR = $ffa5
	CIOUT = $ffa8
	UNTLK = $ffab
	UNLSN = $ffae
	LISTEN = $ffb1
	TALK = $ffb4
	READST = $ffb7
	SETLFS = $ffba
	SETNAM = $ffbd
	OPEN = $ffc0
	CLOSE = $ffc3
	CHKIN = $ffc6
	CHKOUT = $ffc9
	CLRCHN = $ffcc
	CHRIN = $ffcf
	CHROUT = $ffd2
	LOAD = $ffd5
	SAVE = $ffd8
	SETTIM = $ffdb
	RDTIM = $ffde
	STOP = $ffe1
	GETIN = $ffe4
	CLALL = $ffe7
	UDTIM = $ffea
	SCREEN = $ffed
	SCRORG = $ffed
	PLOT = $fff0
	IOBASE = $fff3

	; source: library:/prog8lib/c128/syslib.p8:9   &ubyte  TIME_HI         = $a0       ; software jiffy clock, hi byte
	; source: library:/prog8lib/c128/syslib.p8:10   &ubyte  TIME_MID        = $a1       ;  .. mid byte
	; source: library:/prog8lib/c128/syslib.p8:11   &ubyte  TIME_LO         = $a2       ;    .. lo byte. Updated by IRQ every 1/60 sec
	; source: library:/prog8lib/c128/syslib.p8:12   &ubyte  STATUS          = $90       ; kernal status variable for I/O
	; source: library:/prog8lib/c128/syslib.p8:13   &ubyte  STKEY           = $91       ; various keyboard statuses (updated by IRQ)
	; source: library:/prog8lib/c128/syslib.p8:14   &ubyte  SHFLAG          = $d3       ; various modifier key status (updated by IRQ)
	; source: library:/prog8lib/c128/syslib.p8:15   &ubyte  SFDX            = $d4       ; current key pressed (matrix value) (updated by IRQ)
	; source: library:/prog8lib/c128/syslib.p8:16   &ubyte  COLOR           = $f1       ; cursor color
	; source: library:/prog8lib/c128/syslib.p8:18   &uword  IERROR          = $0300
	; source: library:/prog8lib/c128/syslib.p8:19   &uword  IMAIN           = $0302
	; source: library:/prog8lib/c128/syslib.p8:20   &uword  ICRNCH          = $0304
	; source: library:/prog8lib/c128/syslib.p8:21   &uword  IQPLOP          = $0306
	; source: library:/prog8lib/c128/syslib.p8:22   &uword  IGONE           = $0308
	; source: library:/prog8lib/c128/syslib.p8:23   &uword  IEVAL           = $030a
	; source: library:/prog8lib/c128/syslib.p8:24   &uword  ICRNCH2         = $030c
	; source: library:/prog8lib/c128/syslib.p8:25   &uword  IQPLOP2         = $030e
	; source: library:/prog8lib/c128/syslib.p8:26   &uword  IGONE2          = $0310
	; source: library:/prog8lib/c128/syslib.p8:28   &uword  CINV            = $0314     ; IRQ vector (in ram)
	; source: library:/prog8lib/c128/syslib.p8:29   &uword  CBINV           = $0316     ; BRK vector (in ram)
	; source: library:/prog8lib/c128/syslib.p8:30   &uword  NMINV           = $0318     ; NMI vector (in ram)
	; source: library:/prog8lib/c128/syslib.p8:31   &uword  IOPEN           = $031a
	; source: library:/prog8lib/c128/syslib.p8:32   &uword  ICLOSE          = $031c
	; source: library:/prog8lib/c128/syslib.p8:33   &uword  ICHKIN          = $031e
	; source: library:/prog8lib/c128/syslib.p8:34   &uword  ICKOUT          = $0320
	; source: library:/prog8lib/c128/syslib.p8:35   &uword  ICLRCH          = $0322
	; source: library:/prog8lib/c128/syslib.p8:36   &uword  IBASIN          = $0324
	; source: library:/prog8lib/c128/syslib.p8:37   &uword  IBSOUT          = $0326
	; source: library:/prog8lib/c128/syslib.p8:38   &uword  ISTOP           = $0328
	; source: library:/prog8lib/c128/syslib.p8:39   &uword  IGETIN          = $032a
	; source: library:/prog8lib/c128/syslib.p8:40   &uword  ICLALL          = $032c
	; source: library:/prog8lib/c128/syslib.p8:41   &uword  IEXMON          = $032e
	; source: library:/prog8lib/c128/syslib.p8:42   &uword  ILOAD           = $0330
	; source: library:/prog8lib/c128/syslib.p8:43   &uword  ISAVE           = $0332
	; source: library:/prog8lib/c128/syslib.p8:45   &uword  NMI_VEC         = $FFFA     ; 6502 nmi vector, determined by the kernal if banked in
	; source: library:/prog8lib/c128/syslib.p8:46   &uword  RESET_VEC       = $FFFC     ; 6502 reset vector, determined by the kernal if banked in
	; source: library:/prog8lib/c128/syslib.p8:47   &uword  IRQ_VEC         = $FFFE     ; 6502 interrupt vector, determined by the kernal if banked in
	; source: library:/prog8lib/c128/syslib.p8:50   const  uword  Screen    = $0400     ; to have this as an array[40*25] the compiler would have to support array size > 255
	; source: library:/prog8lib/c128/syslib.p8:51   const  uword  Colors    = $d800     ; to have this as an array[40*25] the compiler would have to support array size > 255
	; source: library:/prog8lib/c128/syslib.p8:6   cbm {
	; source: library:/prog8lib/c128/syslib.p8:59   extsub $FA65 = IRQDFRT() clobbers(A,X,Y)                        ; default IRQ routine

	; source: library:/prog8lib/c128/syslib.p8:60   extsub $FF33 = IRQDFEND() clobbers(A,X,Y)                       ; default IRQ end/cleanup

	; source: library:/prog8lib/c128/syslib.p8:62   extsub $FF81 = CINT() clobbers(A,X,Y)                           ; (alias: SCINIT) initialize screen editor and video chip

	; source: library:/prog8lib/c128/syslib.p8:63   extsub $FF84 = IOINIT() clobbers(A, X)                          ; initialize I/O devices (CIA, SID, IRQ)

	; source: library:/prog8lib/c128/syslib.p8:64   extsub $FF87 = RAMTAS() clobbers(A,X,Y)                         ; initialize RAM, tape buffer, screen

	; source: library:/prog8lib/c128/syslib.p8:65   extsub $FF8A = RESTOR() clobbers(A,X,Y)                         ; restore default I/O vectors

	; source: library:/prog8lib/c128/syslib.p8:66   extsub $FF8D = VECTOR(uword userptr @ XY, bool dir @ Pc) clobbers(A,Y)     ; read/set I/O vector table

	; source: library:/prog8lib/c128/syslib.p8:67   extsub $FF90 = SETMSG(ubyte value @ A)                          ; set Kernal message control flag

	; source: library:/prog8lib/c128/syslib.p8:68   extsub $FF93 = SECOND(ubyte address @ A) clobbers(A)            ; (alias: LSTNSA) send secondary address after LISTEN

	; source: library:/prog8lib/c128/syslib.p8:69   extsub $FF96 = TKSA(ubyte address @ A) clobbers(A)              ; (alias: TALKSA) send secondary address after TALK

	; source: library:/prog8lib/c128/syslib.p8:70   extsub $FF99 = MEMTOP(uword address @ XY, bool dir @ Pc) -> uword @ XY     ; read/set top of memory  pointer

	; source: library:/prog8lib/c128/syslib.p8:71   extsub $FF9C = MEMBOT(uword address @ XY, bool dir @ Pc) -> uword @ XY     ; read/set bottom of memory  pointer

	; source: library:/prog8lib/c128/syslib.p8:72   extsub $FF9F = SCNKEY() clobbers(A,X,Y)                         ; scan the keyboard

	; source: library:/prog8lib/c128/syslib.p8:73   extsub $FFA2 = SETTMO(ubyte timeout @ A)                        ; set time-out flag for IEEE bus

	; source: library:/prog8lib/c128/syslib.p8:74   extsub $FFA5 = ACPTR() -> ubyte @ A                             ; (alias: IECIN) input byte from serial bus

	; source: library:/prog8lib/c128/syslib.p8:75   extsub $FFA8 = CIOUT(ubyte databyte @ A)                        ; (alias: IECOUT) output byte to serial bus

	; source: library:/prog8lib/c128/syslib.p8:76   extsub $FFAB = UNTLK() clobbers(A)                              ; command serial bus device to UNTALK

	; source: library:/prog8lib/c128/syslib.p8:77   extsub $FFAE = UNLSN() clobbers(A)                              ; command serial bus device to UNLISTEN

	; source: library:/prog8lib/c128/syslib.p8:78   extsub $FFB1 = LISTEN(ubyte device @ A) clobbers(A)             ; command serial bus device to LISTEN

	; source: library:/prog8lib/c128/syslib.p8:79   extsub $FFB4 = TALK(ubyte device @ A) clobbers(A)               ; command serial bus device to TALK

	; source: library:/prog8lib/c128/syslib.p8:80   extsub $FFB7 = READST() -> ubyte @ A                            ; read I/O status word  (use CLEARST to reset it to 0)

	; source: library:/prog8lib/c128/syslib.p8:81   extsub $FFBA = SETLFS(ubyte logical @ A, ubyte device @ X, ubyte secondary @ Y)   ; set logical file parameters

	; source: library:/prog8lib/c128/syslib.p8:82   extsub $FFBD = SETNAM(ubyte namelen @ A, str filename @ XY)     ; set filename parameters

	; source: library:/prog8lib/c128/syslib.p8:83   extsub $FFC0 = OPEN() clobbers(X,Y) -> bool @Pc, ubyte @A      ; (via 794 ($31A)) open a logical file

	; source: library:/prog8lib/c128/syslib.p8:84   extsub $FFC3 = CLOSE(ubyte logical @ A) clobbers(A,X,Y)         ; (via 796 ($31C)) close a logical file

	; source: library:/prog8lib/c128/syslib.p8:85   extsub $FFC6 = CHKIN(ubyte logical @ X) clobbers(A,X) -> bool @Pc    ; (via 798 ($31E)) define an input channel

	; source: library:/prog8lib/c128/syslib.p8:86   extsub $FFC9 = CHKOUT(ubyte logical @ X) clobbers(A,X)          ; (via 800 ($320)) define an output channel

	; source: library:/prog8lib/c128/syslib.p8:87   extsub $FFCC = CLRCHN() clobbers(A,X)                           ; (via 802 ($322)) restore default devices

	; source: library:/prog8lib/c128/syslib.p8:88   extsub $FFCF = CHRIN() clobbers(X, Y) -> ubyte @ A   ; (via 804 ($324)) input a character (for keyboard, read a whole line from the screen) A=byte read.

	; source: library:/prog8lib/c128/syslib.p8:89   extsub $FFD2 = CHROUT(ubyte character @ A)                           ; (via 806 ($326)) output a character

	; source: library:/prog8lib/c128/syslib.p8:90   extsub $FFD5 = LOAD(ubyte verify @ A, uword address @ XY) -> bool @Pc, ubyte @ A, uword @ XY     ; (via 816 ($330)) load from device

	; source: library:/prog8lib/c128/syslib.p8:91   extsub $FFD8 = SAVE(ubyte zp_startaddr @ A, uword endaddr @ XY) -> bool @ Pc, ubyte @ A          ; (via 818 ($332)) save to a device

	; source: library:/prog8lib/c128/syslib.p8:92   extsub $FFDB = SETTIM(ubyte low @ A, ubyte middle @ X, ubyte high @ Y)      ; set the software clock

	; source: library:/prog8lib/c128/syslib.p8:93   extsub $FFDE = RDTIM() -> ubyte @ A, ubyte @ X, ubyte @ Y       ; read the software clock (A=lo,X=mid,Y=high)

	; source: library:/prog8lib/c128/syslib.p8:94   extsub $FFE1 = STOP() clobbers(X) -> bool @ Pz, ubyte @ A       ; (via 808 ($328)) check the STOP key (and some others in A)     also see STOP2

	; source: library:/prog8lib/c128/syslib.p8:95   extsub $FFE4 = GETIN() clobbers(X,Y) -> bool @Pc, ubyte @ A     ; (via 810 ($32A)) get a character       also see GETIN2

	; source: library:/prog8lib/c128/syslib.p8:96   extsub $FFE7 = CLALL() clobbers(A,X)                            ; (via 812 ($32C)) close all files

	; source: library:/prog8lib/c128/syslib.p8:97   extsub $FFEA = UDTIM() clobbers(A,X)                            ; update the software clock

	; source: library:/prog8lib/c128/syslib.p8:98   extsub $FFED = SCREEN() -> ubyte @ X, ubyte @ Y                 ; get current window dimensions into X (columns) and Y (rows)  NOTE: changed behavior compared to VIC/C64/PET SCREEN() routine!

	; source: library:/prog8lib/c128/syslib.p8:99   extsub $FFED = SCRORG() -> ubyte @ X, ubyte @ Y                 ; get current window dimensions into X (columns) and Y (rows)  NOTE: changed behavior compared to VIC/C64/PET SCREEN() routine!

	; source: library:/prog8lib/c128/syslib.p8:100   extsub $FFF0 = PLOT(ubyte col @ Y, ubyte row @ X, bool dir @ Pc) clobbers(A) -> ubyte @ Y, ubyte @ X       ; read/set position of cursor on screen (Y=column, X=row).  Also see txt.plot

	; source: library:/prog8lib/c128/syslib.p8:101   extsub $FFF3 = IOBASE() -> uword @ XY                           ; read base address of I/O devices

	; source: library:/prog8lib/c128/syslib.p8:107   inline asmsub STOP2() clobbers(X,A) -> bool @Pz  {
	; source: library:/prog8lib/c128/syslib.p8:115   inline asmsub GETIN2() clobbers(X,Y) -> ubyte @A {
	; source: library:/prog8lib/c128/syslib.p8:124   asmsub RDTIM16() clobbers(X) -> uword @AY {

RDTIM16	.proc
	; source: library:/prog8lib/c128/syslib.p8:126   %asm {{
        jsr  cbm.RDTIM
        pha
        txa
        tay
        pla
        rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:136   asmsub SETTIML(long jiffies @R0R1_32) {

SETTIML	.proc
	; source: library:/prog8lib/c128/syslib.p8:138   %asm {{
        lda  cx16.r0
        ldx  cx16.r0+1
        ldy  cx16.r0+2
        jmp  SETTIM
	.pend
	; source: library:/prog8lib/c128/syslib.p8:146   asmsub RDTIML() clobbers(X) -> long @R0R1_32 {

RDTIML	.proc
	; source: library:/prog8lib/c128/syslib.p8:148   %asm {{
        jsr  RDTIM
        sta  cx16.r0
        stx  cx16.r0+1
        sty  cx16.r0+2
        lda  #0
        sta  cx16.r0+3
        rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:168   asmsub kbdbuf_clear() {

kbdbuf_clear	.proc
	; source: library:/prog8lib/c128/syslib.p8:170   %asm {{
-       jsr  GETIN
        cmp  #0
        bne  -
        rts
	.pend
	.pend

; ---- block: 'c64' ----
c64	.proc
	; source: library:/prog8lib/c128/syslib.p8:180   c64 {
	SPRPTR0 = $07f8
	SPRPTR = $07f8
	SPRPTR1 = $07f9
	SPRPTR2 = $07fa
	SPRPTR3 = $07fb
	SPRPTR4 = $07fc
	SPRPTR5 = $07fd
	SPRPTR6 = $07fe
	SPRPTR7 = $07ff
	SP0X = $d000
	SPXY = $d000
	SPXYW = $d000
	SP0Y = $d001
	SP1X = $d002
	SP1Y = $d003
	SP2X = $d004
	SP2Y = $d005
	SP3X = $d006
	SP3Y = $d007
	SP4X = $d008
	SP4Y = $d009
	SP5X = $d00a
	SP5Y = $d00b
	SP6X = $d00c
	SP6Y = $d00d
	SP7X = $d00e
	SP7Y = $d00f
	MSIGX = $d010
	SCROLY = $d011
	RASTER = $d012
	LPENX = $d013
	LPENY = $d014
	SPENA = $d015
	SCROLX = $d016
	YXPAND = $d017
	VMCSB = $d018
	VICIRQ = $d019
	IREQMASK = $d01a
	SPBGPR = $d01b
	SPMC = $d01c
	XXPAND = $d01d
	SPSPCL = $d01e
	SPBGCL = $d01f
	EXTCOL = $d020
	BGCOL0 = $d021
	BGCOL1 = $d022
	BGCOL2 = $d023
	BGCOL4 = $d024
	SPMC0 = $d025
	SPMC1 = $d026
	SP0COL = $d027
	SPCOL = $d027
	SP1COL = $d028
	SP2COL = $d029
	SP3COL = $d02a
	SP4COL = $d02b
	SP5COL = $d02c
	SP6COL = $d02d
	SP7COL = $d02e
	FREQLO1 = $d400
	FREQ1 = $d400
	FREQHI1 = $d401
	PWLO1 = $d402
	PW1 = $d402
	PWHI1 = $d403
	CR1 = $d404
	AD1 = $d405
	SR1 = $d406
	FREQLO2 = $d407
	FREQ2 = $d407
	FREQHI2 = $d408
	PWLO2 = $d409
	PW2 = $d409
	PWHI2 = $d40a
	CR2 = $d40b
	AD2 = $d40c
	SR2 = $d40d
	FREQLO3 = $d40e
	FREQ3 = $d40e
	FREQHI3 = $d40f
	PWLO3 = $d410
	PW3 = $d410
	PWHI3 = $d411
	CR3 = $d412
	AD3 = $d413
	SR3 = $d414
	FCLO = $d415
	FC = $d415
	FCHI = $d416
	RESFILT = $d417
	MVOL = $d418
	POTX = $d419
	POTY = $d41a
	OSC3 = $d41b
	ENV3 = $d41c
	CIA1PRA = $dc00
	CIA1PRB = $dc01
	CIA1DDRA = $dc02
	CIA1DDRB = $dc03
	CIA1TAL = $dc04
	CIA1TAH = $dc05
	CIA1TBL = $dc06
	CIA1TBH = $dc07
	CIA1TOD10 = $dc08
	CIA1TODSEC = $dc09
	CIA1TODMMIN = $dc0a
	CIA1TODHR = $dc0b
	CIA1SDR = $dc0c
	CIA1ICR = $dc0d
	CIA1CRA = $dc0e
	CIA1CRB = $dc0f
	CIA2PRA = $dd00
	CIA2PRB = $dd01
	CIA2DDRA = $dd02
	CIA2DDRB = $dd03
	CIA2TAL = $dd04
	CIA2TAH = $dd05
	CIA2TBL = $dd06
	CIA2TBH = $dd07
	CIA2TOD10 = $dd08
	CIA2TODSEC = $dd09
	CIA2TODMIN = $dd0a
	CIA2TODHR = $dd0b
	CIA2SDR = $dd0c
	CIA2ICR = $dd0d
	CIA2CRA = $dd0e
	CIA2CRB = $dd0f


	; source: library:/prog8lib/c128/syslib.p8:184   &ubyte  SPRPTR0         = 2040
	; source: library:/prog8lib/c128/syslib.p8:185   &ubyte  SPRPTR1         = 2041
	; source: library:/prog8lib/c128/syslib.p8:186   &ubyte  SPRPTR2         = 2042
	; source: library:/prog8lib/c128/syslib.p8:187   &ubyte  SPRPTR3         = 2043
	; source: library:/prog8lib/c128/syslib.p8:188   &ubyte  SPRPTR4         = 2044
	; source: library:/prog8lib/c128/syslib.p8:189   &ubyte  SPRPTR5         = 2045
	; source: library:/prog8lib/c128/syslib.p8:190   &ubyte  SPRPTR6         = 2046
	; source: library:/prog8lib/c128/syslib.p8:191   &ubyte  SPRPTR7         = 2047
	; source: library:/prog8lib/c128/syslib.p8:192   &ubyte[8]  SPRPTR       = 2040      ; the 8 sprite pointers as an array.
	; source: library:/prog8lib/c128/syslib.p8:197   &ubyte  SP0X            = $d000
	; source: library:/prog8lib/c128/syslib.p8:198   &ubyte  SP0Y            = $d001
	; source: library:/prog8lib/c128/syslib.p8:199   &ubyte  SP1X            = $d002
	; source: library:/prog8lib/c128/syslib.p8:200   &ubyte  SP1Y            = $d003
	; source: library:/prog8lib/c128/syslib.p8:201   &ubyte  SP2X            = $d004
	; source: library:/prog8lib/c128/syslib.p8:202   &ubyte  SP2Y            = $d005
	; source: library:/prog8lib/c128/syslib.p8:203   &ubyte  SP3X            = $d006
	; source: library:/prog8lib/c128/syslib.p8:204   &ubyte  SP3Y            = $d007
	; source: library:/prog8lib/c128/syslib.p8:205   &ubyte  SP4X            = $d008
	; source: library:/prog8lib/c128/syslib.p8:206   &ubyte  SP4Y            = $d009
	; source: library:/prog8lib/c128/syslib.p8:207   &ubyte  SP5X            = $d00a
	; source: library:/prog8lib/c128/syslib.p8:208   &ubyte  SP5Y            = $d00b
	; source: library:/prog8lib/c128/syslib.p8:209   &ubyte  SP6X            = $d00c
	; source: library:/prog8lib/c128/syslib.p8:210   &ubyte  SP6Y            = $d00d
	; source: library:/prog8lib/c128/syslib.p8:211   &ubyte  SP7X            = $d00e
	; source: library:/prog8lib/c128/syslib.p8:212   &ubyte  SP7Y            = $d00f
	; source: library:/prog8lib/c128/syslib.p8:213   &ubyte[16]  SPXY        = $d000        ; the 8 sprite X and Y registers as an array.
	; source: library:/prog8lib/c128/syslib.p8:214   &uword[8] @nosplit SPXYW  = $d000        ; the 8 sprite X and Y registers as a combined xy word array.
	; source: library:/prog8lib/c128/syslib.p8:216   &ubyte  MSIGX           = $d010
	; source: library:/prog8lib/c128/syslib.p8:217   &ubyte  SCROLY          = $d011
	; source: library:/prog8lib/c128/syslib.p8:218   &ubyte  RASTER          = $d012
	; source: library:/prog8lib/c128/syslib.p8:219   &ubyte  LPENX           = $d013
	; source: library:/prog8lib/c128/syslib.p8:220   &ubyte  LPENY           = $d014
	; source: library:/prog8lib/c128/syslib.p8:221   &ubyte  SPENA           = $d015
	; source: library:/prog8lib/c128/syslib.p8:222   &ubyte  SCROLX          = $d016
	; source: library:/prog8lib/c128/syslib.p8:223   &ubyte  YXPAND          = $d017
	; source: library:/prog8lib/c128/syslib.p8:224   &ubyte  VMCSB           = $d018
	; source: library:/prog8lib/c128/syslib.p8:225   &ubyte  VICIRQ          = $d019
	; source: library:/prog8lib/c128/syslib.p8:226   &ubyte  IREQMASK        = $d01a
	; source: library:/prog8lib/c128/syslib.p8:227   &ubyte  SPBGPR          = $d01b
	; source: library:/prog8lib/c128/syslib.p8:228   &ubyte  SPMC            = $d01c
	; source: library:/prog8lib/c128/syslib.p8:229   &ubyte  XXPAND          = $d01d
	; source: library:/prog8lib/c128/syslib.p8:230   &ubyte  SPSPCL          = $d01e
	; source: library:/prog8lib/c128/syslib.p8:231   &ubyte  SPBGCL          = $d01f
	; source: library:/prog8lib/c128/syslib.p8:233   &ubyte  EXTCOL          = $d020        ; border color
	; source: library:/prog8lib/c128/syslib.p8:234   &ubyte  BGCOL0          = $d021        ; screen color
	; source: library:/prog8lib/c128/syslib.p8:235   &ubyte  BGCOL1          = $d022
	; source: library:/prog8lib/c128/syslib.p8:236   &ubyte  BGCOL2          = $d023
	; source: library:/prog8lib/c128/syslib.p8:237   &ubyte  BGCOL4          = $d024
	; source: library:/prog8lib/c128/syslib.p8:238   &ubyte  SPMC0           = $d025
	; source: library:/prog8lib/c128/syslib.p8:239   &ubyte  SPMC1           = $d026
	; source: library:/prog8lib/c128/syslib.p8:240   &ubyte  SP0COL          = $d027
	; source: library:/prog8lib/c128/syslib.p8:241   &ubyte  SP1COL          = $d028
	; source: library:/prog8lib/c128/syslib.p8:242   &ubyte  SP2COL          = $d029
	; source: library:/prog8lib/c128/syslib.p8:243   &ubyte  SP3COL          = $d02a
	; source: library:/prog8lib/c128/syslib.p8:244   &ubyte  SP4COL          = $d02b
	; source: library:/prog8lib/c128/syslib.p8:245   &ubyte  SP5COL          = $d02c
	; source: library:/prog8lib/c128/syslib.p8:246   &ubyte  SP6COL          = $d02d
	; source: library:/prog8lib/c128/syslib.p8:247   &ubyte  SP7COL          = $d02e
	; source: library:/prog8lib/c128/syslib.p8:248   &ubyte[8]  SPCOL        = $d027
	; source: library:/prog8lib/c128/syslib.p8:255   &ubyte  CIA1PRA         = $DC00        ; CIA 1 DRA, keyboard column drive (and joystick control port #2)
	; source: library:/prog8lib/c128/syslib.p8:256   &ubyte  CIA1PRB         = $DC01        ; CIA 1 DRB, keyboard row port (and joystick control port #1)
	; source: library:/prog8lib/c128/syslib.p8:257   &ubyte  CIA1DDRA        = $DC02        ; CIA 1 DDRA, keyboard column
	; source: library:/prog8lib/c128/syslib.p8:258   &ubyte  CIA1DDRB        = $DC03        ; CIA 1 DDRB, keyboard row
	; source: library:/prog8lib/c128/syslib.p8:259   &ubyte  CIA1TAL         = $DC04        ; CIA 1 timer A low byte
	; source: library:/prog8lib/c128/syslib.p8:260   &ubyte  CIA1TAH         = $DC05        ; CIA 1 timer A high byte
	; source: library:/prog8lib/c128/syslib.p8:261   &ubyte  CIA1TBL         = $DC06        ; CIA 1 timer B low byte
	; source: library:/prog8lib/c128/syslib.p8:262   &ubyte  CIA1TBH         = $DC07        ; CIA 1 timer B high byte
	; source: library:/prog8lib/c128/syslib.p8:263   &ubyte  CIA1TOD10       = $DC08        ; time of day, 1/10 sec.
	; source: library:/prog8lib/c128/syslib.p8:264   &ubyte  CIA1TODSEC      = $DC09        ; time of day, seconds
	; source: library:/prog8lib/c128/syslib.p8:265   &ubyte  CIA1TODMMIN     = $DC0A        ; time of day, minutes
	; source: library:/prog8lib/c128/syslib.p8:266   &ubyte  CIA1TODHR       = $DC0B        ; time of day, hours
	; source: library:/prog8lib/c128/syslib.p8:267   &ubyte  CIA1SDR         = $DC0C        ; Serial Data Register
	; source: library:/prog8lib/c128/syslib.p8:268   &ubyte  CIA1ICR         = $DC0D
	; source: library:/prog8lib/c128/syslib.p8:269   &ubyte  CIA1CRA         = $DC0E
	; source: library:/prog8lib/c128/syslib.p8:270   &ubyte  CIA1CRB         = $DC0F
	; source: library:/prog8lib/c128/syslib.p8:272   &ubyte  CIA2PRA         = $DD00        ; CIA 2 DRA, serial port and video address
	; source: library:/prog8lib/c128/syslib.p8:273   &ubyte  CIA2PRB         = $DD01        ; CIA 2 DRB, RS232 port / USERPORT
	; source: library:/prog8lib/c128/syslib.p8:274   &ubyte  CIA2DDRA        = $DD02        ; CIA 2 DDRA, serial port and video address
	; source: library:/prog8lib/c128/syslib.p8:275   &ubyte  CIA2DDRB        = $DD03        ; CIA 2 DDRB, RS232 port / USERPORT
	; source: library:/prog8lib/c128/syslib.p8:276   &ubyte  CIA2TAL         = $DD04        ; CIA 2 timer A low byte
	; source: library:/prog8lib/c128/syslib.p8:277   &ubyte  CIA2TAH         = $DD05        ; CIA 2 timer A high byte
	; source: library:/prog8lib/c128/syslib.p8:278   &ubyte  CIA2TBL         = $DD06        ; CIA 2 timer B low byte
	; source: library:/prog8lib/c128/syslib.p8:279   &ubyte  CIA2TBH         = $DD07        ; CIA 2 timer B high byte
	; source: library:/prog8lib/c128/syslib.p8:280   &ubyte  CIA2TOD10       = $DD08        ; time of day, 1/10 sec.
	; source: library:/prog8lib/c128/syslib.p8:281   &ubyte  CIA2TODSEC      = $DD09        ; time of day, seconds
	; source: library:/prog8lib/c128/syslib.p8:282   &ubyte  CIA2TODMIN      = $DD0A        ; time of day, minutes
	; source: library:/prog8lib/c128/syslib.p8:283   &ubyte  CIA2TODHR       = $DD0B        ; time of day, hours
	; source: library:/prog8lib/c128/syslib.p8:284   &ubyte  CIA2SDR         = $DD0C        ; Serial Data Register
	; source: library:/prog8lib/c128/syslib.p8:285   &ubyte  CIA2ICR         = $DD0D
	; source: library:/prog8lib/c128/syslib.p8:286   &ubyte  CIA2CRA         = $DD0E
	; source: library:/prog8lib/c128/syslib.p8:287   &ubyte  CIA2CRB         = $DD0F
	; source: library:/prog8lib/c128/syslib.p8:293   &ubyte  FREQLO1         = $D400        ; channel 1 freq lo
	; source: library:/prog8lib/c128/syslib.p8:294   &ubyte  FREQHI1         = $D401        ; channel 1 freq hi
	; source: library:/prog8lib/c128/syslib.p8:295   &uword  FREQ1           = $D400        ; channel 1 freq (word)
	; source: library:/prog8lib/c128/syslib.p8:296   &ubyte  PWLO1           = $D402        ; channel 1 pulse width lo (7-0)
	; source: library:/prog8lib/c128/syslib.p8:297   &ubyte  PWHI1           = $D403        ; channel 1 pulse width hi (11-8)
	; source: library:/prog8lib/c128/syslib.p8:298   &uword  PW1             = $D402        ; channel 1 pulse width (word)
	; source: library:/prog8lib/c128/syslib.p8:299   &ubyte  CR1             = $D404        ; channel 1 voice control register
	; source: library:/prog8lib/c128/syslib.p8:300   &ubyte  AD1             = $D405        ; channel 1 attack & decay
	; source: library:/prog8lib/c128/syslib.p8:301   &ubyte  SR1             = $D406        ; channel 1 sustain & release
	; source: library:/prog8lib/c128/syslib.p8:302   &ubyte  FREQLO2         = $D407        ; channel 2 freq lo
	; source: library:/prog8lib/c128/syslib.p8:303   &ubyte  FREQHI2         = $D408        ; channel 2 freq hi
	; source: library:/prog8lib/c128/syslib.p8:304   &uword  FREQ2           = $D407        ; channel 2 freq (word)
	; source: library:/prog8lib/c128/syslib.p8:305   &ubyte  PWLO2           = $D409        ; channel 2 pulse width lo (7-0)
	; source: library:/prog8lib/c128/syslib.p8:306   &ubyte  PWHI2           = $D40A        ; channel 2 pulse width hi (11-8)
	; source: library:/prog8lib/c128/syslib.p8:307   &uword  PW2             = $D409        ; channel 2 pulse width (word)
	; source: library:/prog8lib/c128/syslib.p8:308   &ubyte  CR2             = $D40B        ; channel 2 voice control register
	; source: library:/prog8lib/c128/syslib.p8:309   &ubyte  AD2             = $D40C        ; channel 2 attack & decay
	; source: library:/prog8lib/c128/syslib.p8:310   &ubyte  SR2             = $D40D        ; channel 2 sustain & release
	; source: library:/prog8lib/c128/syslib.p8:311   &ubyte  FREQLO3         = $D40E        ; channel 3 freq lo
	; source: library:/prog8lib/c128/syslib.p8:312   &ubyte  FREQHI3         = $D40F        ; channel 3 freq hi
	; source: library:/prog8lib/c128/syslib.p8:313   &uword  FREQ3           = $D40E        ; channel 3 freq (word)
	; source: library:/prog8lib/c128/syslib.p8:314   &ubyte  PWLO3           = $D410        ; channel 3 pulse width lo (7-0)
	; source: library:/prog8lib/c128/syslib.p8:315   &ubyte  PWHI3           = $D411        ; channel 3 pulse width hi (11-8)
	; source: library:/prog8lib/c128/syslib.p8:316   &uword  PW3             = $D410        ; channel 3 pulse width (word)
	; source: library:/prog8lib/c128/syslib.p8:317   &ubyte  CR3             = $D412        ; channel 3 voice control register
	; source: library:/prog8lib/c128/syslib.p8:318   &ubyte  AD3             = $D413        ; channel 3 attack & decay
	; source: library:/prog8lib/c128/syslib.p8:319   &ubyte  SR3             = $D414        ; channel 3 sustain & release
	; source: library:/prog8lib/c128/syslib.p8:320   &ubyte  FCLO            = $D415        ; filter cutoff lo (2-0)
	; source: library:/prog8lib/c128/syslib.p8:321   &ubyte  FCHI            = $D416        ; filter cutoff hi (10-3)
	; source: library:/prog8lib/c128/syslib.p8:322   &uword  FC              = $D415        ; filter cutoff (word)
	; source: library:/prog8lib/c128/syslib.p8:323   &ubyte  RESFILT         = $D417        ; filter resonance and routing
	; source: library:/prog8lib/c128/syslib.p8:324   &ubyte  MVOL            = $D418        ; filter mode and main volume control
	; source: library:/prog8lib/c128/syslib.p8:325   &ubyte  POTX            = $D419        ; potentiometer X
	; source: library:/prog8lib/c128/syslib.p8:326   &ubyte  POTY            = $D41A        ; potentiometer Y
	; source: library:/prog8lib/c128/syslib.p8:327   &ubyte  OSC3            = $D41B        ; channel 3 oscillator value read
	; source: library:/prog8lib/c128/syslib.p8:328   &ubyte  ENV3            = $D41C        ; channel 3 envelope value read
	; source: library:/prog8lib/c128/syslib.p8:180   c64 {
	.pend

; ---- block: 'c128' ----
c128	.proc
	; source: library:/prog8lib/c128/syslib.p8:334   c128 {
	VM1 = $0a2c
	VM2 = $0a2d
	VM3 = $0a2e
	VM4 = $0a2f

	SPIN_SPOUT = $ff47
	CLOSE_ALL = $ff4a
	C64_MODE = $ff4d
	DMA_CALL = $ff50
	BOOT_CALL = $ff53
	PHOENIX = $ff56
	LKUPLA = $ff59
	LKUPSA = $ff5c
	SWAPPER = $ff5f
	DLCHR = $ff62
	PFKEY = $ff65
	SETBNK = $ff68
	GETCFG = $ff6b
	JSRFAR = $ff6e
	JMPFAR = $ff71
	INDFET = $ff74
	INDSTA = $ff77
	INDCMP = $ff7a
	PRIMM = $ff7d

	; source: library:/prog8lib/c128/syslib.p8:337   &ubyte  VM1     = $0A2C         ; shadow for VUC $d018 in text mode
	; source: library:/prog8lib/c128/syslib.p8:338   &ubyte  VM2     = $0A2D         ; shadow for VIC $d018 in bitmap screen mode
	; source: library:/prog8lib/c128/syslib.p8:339   &ubyte  VM3     = $0A2E         ; starting page for VDC screen mem
	; source: library:/prog8lib/c128/syslib.p8:340   &ubyte  VM4     = $0A2F         ; starting page for VDC attribute mem
	; source: library:/prog8lib/c128/syslib.p8:334   c128 {
	; source: library:/prog8lib/c128/syslib.p8:343   extsub $FF47 = SPIN_SPOUT() clobbers(A)                         ; set up serial bus for fast communications mode

	; source: library:/prog8lib/c128/syslib.p8:344   extsub $FF4A = CLOSE_ALL(ubyte device @X)  clobbers(X)          ; close all channels to specific device

	; source: library:/prog8lib/c128/syslib.p8:345   extsub $FF4D = C64_MODE()                                       ; restart machine in C64 mode (does not return)

	; source: library:/prog8lib/c128/syslib.p8:346   extsub $FF50 = DMA_CALL(ubyte bank @X, ubyte command @Y) clobbers(A,X) ; send a command to a DMA device

	; source: library:/prog8lib/c128/syslib.p8:347   extsub $FF53 = BOOT_CALL(ubyte device @X, ubyte drive @A) clobbers(A,X,Y) ; try to autoboot the given disk

	; source: library:/prog8lib/c128/syslib.p8:348   extsub $FF56 = PHOENIX() clobbers(A,X,Y)                        ; search for and autostart ROMs, cartridges, then default disk

	; source: library:/prog8lib/c128/syslib.p8:349   extsub $FF59 = LKUPLA(ubyte lfn @A) -> bool @Pc, ubyte @X       ; look up logical file number to see if it's open; returns device

	; source: library:/prog8lib/c128/syslib.p8:350   extsub $FF5C = LKUPSA(ubyte sa @Y) -> bool @Pc, ubyte @A, ubyte @X ; look up secondary address to see if it's in use; returns lfn and device

	; source: library:/prog8lib/c128/syslib.p8:351   extsub $FF5F = SWAPPER() clobbers(A,X,Y)                        ; swap active screen (between 40- and 80-column)

	; source: library:/prog8lib/c128/syslib.p8:352   extsub $FF62 = DLCHR() clobbers(A,X,Y)                          ; copy character ROM into VDC video RAM

	; source: library:/prog8lib/c128/syslib.p8:353   extsub $FF65 = PFKEY(ubyte zpaddr @A, ubyte key @X, ubyte length @Y) ; redefine programmable function key (string descriptor in zp, addr in A)

	; source: library:/prog8lib/c128/syslib.p8:354   extsub $FF68 = SETBNK(ubyte data_bank @A, ubyte filename_bank @X) ; set memory bank for load/save

	; source: library:/prog8lib/c128/syslib.p8:355   extsub $FF6B = GETCFG(ubyte bank @X) -> ubyte @A                ; translate bank number to MMU configuration register value

	; source: library:/prog8lib/c128/syslib.p8:356   extsub $FF6E = JSRFAR() clobbers(A,X)                           ; call routine in another bank (parameters set in zero page addresses 2-8)

	; source: library:/prog8lib/c128/syslib.p8:357   extsub $FF71 = JMPFAR() clobbers(A,X)                           ; jump without return to another bank (parameters set as for JSRFAR)

	; source: library:/prog8lib/c128/syslib.p8:358   extsub $FF74 = INDFET(ubyte zpaddr @A, ubyte bank @X, ubyte offset @Y) clobbers(X) -> ubyte @A ; fetch byte from another bank (address in zp, ptr in A)

	; source: library:/prog8lib/c128/syslib.p8:359   extsub $FF77 = INDSTA(ubyte value @A, ubyte bank @X, ubyte offset @Y) clobbers(X) ; store byte to another bank (address in zp, ptr in $02b9)

	; source: library:/prog8lib/c128/syslib.p8:360   extsub $FF7A = INDCMP(ubyte value @A, ubyte bank @X, ubyte offset @Y) clobbers(X) -> bool @Pz, bool @Pc, bool @Pv; compare byte in another bank (address in zp, ptr in $02c8)

	; source: library:/prog8lib/c128/syslib.p8:361   extsub $FF7D = PRIMM()                                          ; print immediate string  (the 0-terminated string immediately following the JSR PRIMM instruction)

	; source: library:/prog8lib/c128/syslib.p8:366   inline asmsub banks(ubyte banks @A) {
	; source: library:/prog8lib/c128/syslib.p8:373   inline asmsub getbanks() -> ubyte @A {
	; source: library:/prog8lib/c128/syslib.p8:380   asmsub  disable_basic() clobbers(A) {

disable_basic	.proc
	; source: library:/prog8lib/c128/syslib.p8:381   %asm {{
        lda $0a04   ; disable BASIC shadow registers
        and #$fe
        sta $0a04

        lda #$01    ; disable BASIC IRQ service routine
        sta $12fd

        lda #$ff    ; disable screen editor IRQ setup
        sta $d8

        lda #$b7    ; skip programmable function key check
        sta $033c

        lda #$0e    ; bank out BASIC ROM
        sta $ff00
        rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:401   asmsub  x16jsrfar() {

x16jsrfar	.proc
	; source: library:/prog8lib/c128/syslib.p8:402   %asm {{
        ; setup a JSRFAR call (using X16 call convention)
        ; see https://cx16.dk/c128-kernal-routines/jsrfar.html
        sty  $08                ; save registers
        stx  $07
        sta  $06
        php                    ; including PSR
        pla
        sta  $05

        pla                    ; get original return address
        sta  $fa                ; and store it in a temp ZP pointer
        pla
        sta  $fb

        ldy  #$01
        lda  ($fa),y            ; grab low byte of target address
        sta  $04
        iny
        lda  ($fa),y            ; now the high byte
        sta  $03
        iny
        lda  ($fa),y            ; then the target bank
        sta  $02

        ; replace the original return address by it + 3 to skip the data bytes
        clc
        lda  $fa
        adc  #3
        sta  $fa
        lda  $fb
        adc  #0
        pha
        lda  $fa
        pha

        jsr c128.JSRFAR        ; call kernal's jsrfar routine

        lda  $05                ; populate registers
        pha
        lda  $06
        ldx  $07
        ldy  $08
        plp

        rts                    ; and return
	.pend
	.pend

; ---- block: 'sys' ----
sys	.proc
	; source: library:/prog8lib/c128/syslib.p8:455   sys {
	MAX_BYTE = $7f
	MAX_UBYTE = $ff
	MAX_UWORD = $ffff
	MAX_WORD = $7fff
	MIN_BYTE = -$80
	MIN_UBYTE = 0
	MIN_UWORD = 0
	MIN_WORD = -$8000
	SIZEOF_BOOL = 1
	SIZEOF_BYTE = 1
	SIZEOF_FLOAT = 5
	SIZEOF_LONG = 4
	SIZEOF_POINTER = 2
	SIZEOF_UBYTE = 1
	SIZEOF_UWORD = 2
	SIZEOF_WORD = 2
	target = $80


	; source: library:/prog8lib/c128/syslib.p8:458   const ubyte target = 128         ;  compilation target specifier.  255=virtual, 128=C128, 64=C64, 32=PET, 16=CommanderX16, 8=atari800XL, 7=Neo6502
	; source: library:/prog8lib/c128/syslib.p8:460   const ubyte SIZEOF_BOOL  = sizeof(bool)
	; source: library:/prog8lib/c128/syslib.p8:461   const ubyte SIZEOF_BYTE  = sizeof(byte)
	; source: library:/prog8lib/c128/syslib.p8:462   const ubyte SIZEOF_UBYTE = sizeof(ubyte)
	; source: library:/prog8lib/c128/syslib.p8:463   const ubyte SIZEOF_WORD  = sizeof(word)
	; source: library:/prog8lib/c128/syslib.p8:464   const ubyte SIZEOF_UWORD = sizeof(uword)
	; source: library:/prog8lib/c128/syslib.p8:465   const ubyte SIZEOF_LONG  = sizeof(long)
	; source: library:/prog8lib/c128/syslib.p8:466   const ubyte SIZEOF_POINTER = sizeof(&sys.wait)
	; source: library:/prog8lib/c128/syslib.p8:467   const ubyte SIZEOF_FLOAT = sizeof(float)
	; source: library:/prog8lib/c128/syslib.p8:468   const byte  MIN_BYTE     = -128
	; source: library:/prog8lib/c128/syslib.p8:469   const byte  MAX_BYTE     = 127
	; source: library:/prog8lib/c128/syslib.p8:470   const ubyte MIN_UBYTE    = 0
	; source: library:/prog8lib/c128/syslib.p8:471   const ubyte MAX_UBYTE    = 255
	; source: library:/prog8lib/c128/syslib.p8:472   const word  MIN_WORD     = -32768
	; source: library:/prog8lib/c128/syslib.p8:473   const word  MAX_WORD     = 32767
	; source: library:/prog8lib/c128/syslib.p8:474   const uword MIN_UWORD    = 0
	; source: library:/prog8lib/c128/syslib.p8:475   const uword MAX_UWORD    = 65535
	; source: library:/prog8lib/c128/syslib.p8:455   sys {
	; source: library:/prog8lib/c128/syslib.p8:487   asmsub save_prog8_internals() {

save_prog8_internals	.proc
	; source: library:/prog8lib/c128/syslib.p8:488   %asm {{
            lda  P8ZP_SCRATCH_B1
            sta  save_SCRATCH_ZPB1
            lda  P8ZP_SCRATCH_REG
            sta  save_SCRATCH_ZPREG
            lda  P8ZP_SCRATCH_W1
            sta  save_SCRATCH_ZPWORD1
            lda  P8ZP_SCRATCH_W1+1
            sta  save_SCRATCH_ZPWORD1+1
            lda  P8ZP_SCRATCH_W2
            sta  save_SCRATCH_ZPWORD2
            lda  P8ZP_SCRATCH_W2+1
            sta  save_SCRATCH_ZPWORD2+1
            rts
            .section BSS
save_SCRATCH_ZPB1	.byte  ?
save_SCRATCH_ZPREG	.byte  ?
save_SCRATCH_ZPWORD1	.word  ?
save_SCRATCH_ZPWORD2	.word  ?
            .send BSS
            ; !notreached!
	.pend
	; source: library:/prog8lib/c128/syslib.p8:512   asmsub restore_prog8_internals() {

restore_prog8_internals	.proc
	; source: library:/prog8lib/c128/syslib.p8:513   %asm {{
            lda  save_prog8_internals.save_SCRATCH_ZPB1
            sta  P8ZP_SCRATCH_B1
            lda  save_prog8_internals.save_SCRATCH_ZPREG
            sta  P8ZP_SCRATCH_REG
            lda  save_prog8_internals.save_SCRATCH_ZPWORD1
            sta  P8ZP_SCRATCH_W1
            lda  save_prog8_internals.save_SCRATCH_ZPWORD1+1
            sta  P8ZP_SCRATCH_W1+1
            lda  save_prog8_internals.save_SCRATCH_ZPWORD2
            sta  P8ZP_SCRATCH_W2
            lda  save_prog8_internals.save_SCRATCH_ZPWORD2+1
            sta  P8ZP_SCRATCH_W2+1
            rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:530   asmsub  set_irq(uword handler @AY) clobbers(A)  {

set_irq	.proc
	; source: library:/prog8lib/c128/syslib.p8:531   %asm {{
	    php
		sei
        sta  _vector
        sty  _vector+1
		lda  #<_irq_handler
		sta  cbm.CINV
		lda  #>_irq_handler
		sta  cbm.CINV+1
		plp
		rts
_irq_handler
        jsr  sys.save_prog8_internals
        cld

        jsr  _run_custom
        pha
        jsr  sys.restore_prog8_internals
        pla
		bne  cbm.IRQDFRT		; continue with normal kernal irq routine
+		lda  #$ff
		sta  c64.VICIRQ			; acknowledge raster irq
		lda  c64.CIA1ICR		; acknowledge CIA1 interrupt
		pla
		tay
		pla
		tax
		pla
		rti
_run_custom
		jmp  (_vector)
		.section BSS
_vector	.word ?
		.send BSS
        ; !notreached!
	.pend
	; source: library:/prog8lib/c128/syslib.p8:570   asmsub  restore_irq() clobbers(A) {

restore_irq	.proc
	; source: library:/prog8lib/c128/syslib.p8:571   %asm {{
	    php
		sei
		lda  #<cbm.IRQDFRT
		sta  cbm.CINV
		lda  #>cbm.IRQDFRT
		sta  cbm.CINV+1
		lda  #1
		sta  c64.IREQMASK	; enable raster irq
		lda  #%10000001
		sta  c64.CIA1ICR	; restore CIA1 irq
		plp
		rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:587   asmsub  set_rasterirq(uword handler @AY, uword rasterpos @R0) clobbers(A) {

set_rasterirq	.proc
	; source: library:/prog8lib/c128/syslib.p8:588   %asm {{
	    php
        sei
        sta  user_vector
        sty  user_vector+1

        lda  #%01111111
        sta  c64.CIA1ICR    ; "switch off" interrupts signals from cia-1
        sta  c64.CIA2ICR    ; "switch off" interrupts signals from cia-2
        lda  c64.CIA1ICR    ; ack previous irq
        lda  c64.CIA2ICR    ; ack previous irq
        lda  cx16.r0
        ldy  cx16.r0+1
        jsr  sys.set_rasterline
        lda  #%00000001
        sta  c64.IREQMASK   ; enable raster interrupt signals from vic

        lda  #<_raster_irq_handler
        sta  cbm.CINV
        lda  #>_raster_irq_handler
        sta  cbm.CINV+1
        plp
        rts

_raster_irq_handler
		jsr  sys.save_prog8_internals
		cld

        jsr  _run_custom
        pha
		jsr  sys.restore_prog8_internals
        lda  #$ff
        sta  c64.VICIRQ			; acknowledge raster irq
		pla
		bne  cbm.IRQDFRT        ; continue with kernal irq routine
+		pla
		tay
		pla
		tax
		pla
		rti
_run_custom
		jmp  (user_vector)
		.section BSS
user_vector	.word ?
		.send BSS

        ; !notreached!
	.pend
	; source: library:/prog8lib/c128/syslib.p8:640   asmsub update_rasterirq(uword handler @AY, uword rasterpos @R0) clobbers(A) {

update_rasterirq	.proc
	; source: library:/prog8lib/c128/syslib.p8:644   %asm {{
            php
            sei
            sta  sys.set_rasterirq.user_vector
            sty  sys.set_rasterirq.user_vector+1
            lda  cx16.r0L
            ldy  cx16.r0H
            jsr  sys.set_rasterline
            plp
            rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:657   asmsub  set_rasterline(uword line @AY) {

set_rasterline	.proc
	; source: library:/prog8lib/c128/syslib.p8:659   %asm {{
            sta  c64.RASTER     ; set the raster line number where interrupt should occur
            lda  c64.SCROLY
            and  #%01111111
            cpy  #0
            beq  +
            ora  #%10000000
    +       sta  c64.SCROLY     ; clear most significant bit of raster position
            rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:671   asmsub  reset_system()  {

reset_system	.proc
	; source: library:/prog8lib/c128/syslib.p8:673   %asm {{
            sei
            lda  #0
            sta  $ff00      ; default bank 15
            jmp  (cbm.RESET_VEC)
	.pend
	; source: library:/prog8lib/c128/syslib.p8:681   asmsub wait(uword jiffies @AY) {

wait	.proc
	; source: library:/prog8lib/c128/syslib.p8:684   %asm {{
            stx  P8ZP_SCRATCH_B1
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1

_loop       lda  P8ZP_SCRATCH_W1
            ora  P8ZP_SCRATCH_W1+1
            bne  +
            ldx  P8ZP_SCRATCH_B1
            rts

+           lda  cbm.TIME_LO
            sta  P8ZP_SCRATCH_B1
-           lda  cbm.TIME_LO
            cmp  P8ZP_SCRATCH_B1
            beq  -

            lda  P8ZP_SCRATCH_W1
            bne  +
            dec  P8ZP_SCRATCH_W1+1
+           dec  P8ZP_SCRATCH_W1
            jmp  _loop
	.pend
	; source: library:/prog8lib/c128/syslib.p8:709   asmsub waitvsync() clobbers(A) {

waitvsync	.proc
	; source: library:/prog8lib/c128/syslib.p8:712   %asm {{
-           bit  c64.SCROLY
            bpl  -
-           bit  c64.SCROLY
            bmi  -
            rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:721   inline asmsub waitrastborder() {
	; source: library:/prog8lib/c128/syslib.p8:730   asmsub waitrasterline(uword line @AY) {

waitrasterline	.proc
	; source: library:/prog8lib/c128/syslib.p8:732   %asm {{
            cpy  #0
            bne  _larger
-           cmp  c64.RASTER
            bne  -
            bit  c64.SCROLY
            bmi  -
            rts
_larger
            cmp  c64.RASTER
            bne  _larger
            bit  c64.SCROLY
            bpl  _larger
            rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:750   asmsub internal_stringcopy(str source @R0, str target @AY) clobbers (A,Y) {

internal_stringcopy	.proc
	; source: library:/prog8lib/c128/syslib.p8:752   %asm {{
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend
	; source: library:/prog8lib/c128/syslib.p8:761   asmsub memcopy(uword source @R0, uword target @R1, uword count @AY) clobbers(A,X,Y) {

memcopy	.proc
	; source: library:/prog8lib/c128/syslib.p8:764   %asm {{
            ldx  cx16.r0
            stx  P8ZP_SCRATCH_W1        ; source in ZP
            ldx  cx16.r0+1
            stx  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            stx  P8ZP_SCRATCH_W2        ; target in ZP
            ldx  cx16.r1+1
            stx  P8ZP_SCRATCH_W2+1
            cpy  #0
            bne  _longcopy

            ; copy <= 255 bytes
            tay
            bne  _copyshort
            rts     ; nothing to copy

_copyshort
            dey
            beq  +
-           lda  (P8ZP_SCRATCH_W1),y
            sta  (P8ZP_SCRATCH_W2),y
            dey
            bne  -
+           lda  (P8ZP_SCRATCH_W1),y
            sta  (P8ZP_SCRATCH_W2),y
            rts

_longcopy
            sta  P8ZP_SCRATCH_B1        ; lsb(count) = remainder in last page
            tya
            tax                         ; x = num pages (1+)
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            sta  (P8ZP_SCRATCH_W2),y
            iny
            bne  -
            inc  P8ZP_SCRATCH_W1+1
            inc  P8ZP_SCRATCH_W2+1
            dex
            bne  -
            ldy  P8ZP_SCRATCH_B1
            bne  _copyshort
            rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:811   asmsub memset(uword mem @R0, uword numbytes @R1, ubyte value @A) clobbers(A,X,Y) {

memset	.proc
	; source: library:/prog8lib/c128/syslib.p8:812   %asm {{
            ldy  cx16.r0
            sty  P8ZP_SCRATCH_W1
            ldy  cx16.r0+1
            sty  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            ldy  cx16.r1+1
            jmp  prog8_lib.memset
	.pend
	; source: library:/prog8lib/c128/syslib.p8:823   asmsub memsetw(uword mem @R0, uword numwords @R1, uword value @AY) clobbers(A,X,Y) {

memsetw	.proc
	; source: library:/prog8lib/c128/syslib.p8:824   %asm {{
            ldx  cx16.r0
            stx  P8ZP_SCRATCH_W1
            ldx  cx16.r0+1
            stx  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            stx  P8ZP_SCRATCH_W2
            ldx  cx16.r1+1
            stx  P8ZP_SCRATCH_W2+1
            jmp  prog8_lib.memsetw
	.pend
	; source: library:/prog8lib/c128/syslib.p8:837   asmsub memcmp(uword address1 @R0, uword address2 @R1, uword size @AY) -> byte @A {

memcmp	.proc
	; source: library:/prog8lib/c128/syslib.p8:840   %asm {{
            sta  P8ZP_SCRATCH_REG   ; lsb(size)
            sty  P8ZP_SCRATCH_B1    ; msb(size)
            lda  cx16.r0
            ldy  cx16.r0+1
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            lda  cx16.r1
            ldy  cx16.r1+1
            sta  P8ZP_SCRATCH_W2
            sty  P8ZP_SCRATCH_W2+1

            ldx  P8ZP_SCRATCH_B1
            beq  _no_msb_size

_loop_msb_size
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            cmp  (P8ZP_SCRATCH_W2),y
            bcs  +
            lda  #-1
            rts
+           beq  +
            lda  #1
            rts
+           iny
            bne  -
            inc  P8ZP_SCRATCH_W1+1
            inc  P8ZP_SCRATCH_W2+1
            dec  P8ZP_SCRATCH_B1        ; msb(size) -= 1
            dex
            bne  _loop_msb_size

_no_msb_size
            lda  P8ZP_SCRATCH_REG       ; lsb(size)
            bne  +
            rts

+           ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            cmp  (P8ZP_SCRATCH_W2),y
            bcs  +
            lda  #-1
            rts
+           beq  +
            lda  #1
            rts
+           iny
            cpy  P8ZP_SCRATCH_REG       ; lsb(size)
            bne  -

            lda #0
            rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:896   inline asmsub read_flags() -> ubyte @A {
	; source: library:/prog8lib/c128/syslib.p8:903   inline asmsub clear_carry() {
	; source: library:/prog8lib/c128/syslib.p8:909   inline asmsub set_carry() {
	; source: library:/prog8lib/c128/syslib.p8:915   inline asmsub clear_irqd() {
	; source: library:/prog8lib/c128/syslib.p8:921   inline asmsub set_irqd() {
	; source: library:/prog8lib/c128/syslib.p8:927   inline asmsub irqsafe_set_irqd() {
	; source: library:/prog8lib/c128/syslib.p8:934   inline asmsub irqsafe_clear_irqd() {
	; source: library:/prog8lib/c128/syslib.p8:940   inline asmsub disable_caseswitch() {
	; source: library:/prog8lib/c128/syslib.p8:947   inline asmsub enable_caseswitch() {
	; source: library:/prog8lib/c128/syslib.p8:954   asmsub exit(ubyte returnvalue @A) {

exit	.proc
	; source: library:/prog8lib/c128/syslib.p8:956   %asm {{
            sta  p8_sys_startup.cleanup_at_exit._exitcode
            ldx  prog8_lib.orig_stackpointer
            txs
            jmp  p8_sys_startup.cleanup_at_exit
	.pend
	; source: library:/prog8lib/c128/syslib.p8:964   asmsub exit2(ubyte resulta @A, ubyte resultx @X, ubyte resulty @Y) {

exit2	.proc
	; source: library:/prog8lib/c128/syslib.p8:966   %asm {{
            sta  p8_sys_startup.cleanup_at_exit._exitcode
            stx  p8_sys_startup.cleanup_at_exit._exitcodeX
            sty  p8_sys_startup.cleanup_at_exit._exitcodeY
            ldx  prog8_lib.orig_stackpointer
            txs
            jmp  p8_sys_startup.cleanup_at_exit
	.pend
	; source: library:/prog8lib/c128/syslib.p8:976   asmsub exit3(ubyte resulta @A, ubyte resultx @X, ubyte resulty @Y, bool carry @Pc) {

exit3	.proc
	; source: library:/prog8lib/c128/syslib.p8:978   %asm {{
            sta  p8_sys_startup.cleanup_at_exit._exitcode
            lda  #0
            rol  a
            sta  p8_sys_startup.cleanup_at_exit._exitcarry
            stx  p8_sys_startup.cleanup_at_exit._exitcodeX
            sty  p8_sys_startup.cleanup_at_exit._exitcodeY
            ldx  prog8_lib.orig_stackpointer
            txs
            jmp  p8_sys_startup.cleanup_at_exit
	.pend
	; source: library:/prog8lib/c128/syslib.p8:991   inline asmsub progend() -> uword @AY {
	; source: library:/prog8lib/c128/syslib.p8:998   inline asmsub progstart() -> uword @AY {
	; source: library:/prog8lib/c128/syslib.p8:1005   inline asmsub push(ubyte value @A) {
	; source: library:/prog8lib/c128/syslib.p8:1011   inline asmsub pushw(uword value @AY) {
	; source: library:/prog8lib/c128/syslib.p8:1019   inline asmsub push_returnaddress(uword address @XY) {
	; source: library:/prog8lib/c128/syslib.p8:1033   asmsub get_as_returnaddress(uword address @XY) -> uword @AX {

get_as_returnaddress	.proc
	; source: library:/prog8lib/c128/syslib.p8:1034   %asm {{
            ; return the address like JSR would push onto the stack:  address-1,  MSB first then LSB
            cpx  #0
            bne  +
            dey
+           dex
            tya
            rts
	.pend
	; source: library:/prog8lib/c128/syslib.p8:1045   inline asmsub pop() -> ubyte @A {
	; source: library:/prog8lib/c128/syslib.p8:1051   inline asmsub popw() -> uword @AY {
	; source: library:/prog8lib/c128/syslib.p8:1059   inline asmsub pushl(long value @R0R1_32) {
	; source: library:/prog8lib/c128/syslib.p8:1072   inline asmsub popl() -> long @R0R1_32 {
	.pend

; ---- block: 'cx16' ----
cx16	.proc
	; source: library:/prog8lib/c128/syslib.p8:1103   cx16 {
	r0 = $1be0
	r0s = $1be0
	r0r1sl = $1be0
	r0L = $1be0
	r0sL = $1be0
	r0bL = $1be0
	r0H = $1be1
	r0sH = $1be1
	r0bH = $1be1
	r1 = $1be2
	r1s = $1be2
	r1L = $1be2
	r1sL = $1be2
	r1bL = $1be2
	r1H = $1be3
	r1sH = $1be3
	r1bH = $1be3
	r2 = $1be4
	r2s = $1be4
	r2r3sl = $1be4
	r2L = $1be4
	r2sL = $1be4
	r2bL = $1be4
	r2H = $1be5
	r2sH = $1be5
	r2bH = $1be5
	r3 = $1be6
	r3s = $1be6
	r3L = $1be6
	r3sL = $1be6
	r3bL = $1be6
	r3H = $1be7
	r3sH = $1be7
	r3bH = $1be7
	r4 = $1be8
	r4s = $1be8
	r4r5sl = $1be8
	r4L = $1be8
	r4sL = $1be8
	r4bL = $1be8
	r4H = $1be9
	r4sH = $1be9
	r4bH = $1be9
	r5 = $1bea
	r5s = $1bea
	r5L = $1bea
	r5sL = $1bea
	r5bL = $1bea
	r5H = $1beb
	r5sH = $1beb
	r5bH = $1beb
	r6 = $1bec
	r6s = $1bec
	r6r7sl = $1bec
	r6L = $1bec
	r6sL = $1bec
	r6bL = $1bec
	r6H = $1bed
	r6sH = $1bed
	r6bH = $1bed
	r7 = $1bee
	r7s = $1bee
	r7L = $1bee
	r7sL = $1bee
	r7bL = $1bee
	r7H = $1bef
	r7sH = $1bef
	r7bH = $1bef
	r8 = $1bf0
	r8s = $1bf0
	r8r9sl = $1bf0
	r8L = $1bf0
	r8sL = $1bf0
	r8bL = $1bf0
	r8H = $1bf1
	r8sH = $1bf1
	r8bH = $1bf1
	r9 = $1bf2
	r9s = $1bf2
	r9L = $1bf2
	r9sL = $1bf2
	r9bL = $1bf2
	r9H = $1bf3
	r9sH = $1bf3
	r9bH = $1bf3
	r10 = $1bf4
	r10s = $1bf4
	r10r11sl = $1bf4
	r10L = $1bf4
	r10sL = $1bf4
	r10bL = $1bf4
	r10H = $1bf5
	r10sH = $1bf5
	r10bH = $1bf5
	r11 = $1bf6
	r11s = $1bf6
	r11L = $1bf6
	r11sL = $1bf6
	r11bL = $1bf6
	r11H = $1bf7
	r11sH = $1bf7
	r11bH = $1bf7
	r12 = $1bf8
	r12s = $1bf8
	r12r13sl = $1bf8
	r12L = $1bf8
	r12sL = $1bf8
	r12bL = $1bf8
	r12H = $1bf9
	r12sH = $1bf9
	r12bH = $1bf9
	r13 = $1bfa
	r13s = $1bfa
	r13L = $1bfa
	r13sL = $1bfa
	r13bL = $1bfa
	r13H = $1bfb
	r13sH = $1bfb
	r13bH = $1bfb
	r14 = $1bfc
	r14s = $1bfc
	r14r15sl = $1bfc
	r14L = $1bfc
	r14sL = $1bfc
	r14bL = $1bfc
	r14H = $1bfd
	r14sH = $1bfd
	r14bH = $1bfd
	r15 = $1bfe
	r15s = $1bfe
	r15L = $1bfe
	r15sL = $1bfe
	r15bL = $1bfe
	r15H = $1bff
	r15sH = $1bff
	r15bH = $1bff


	; source: library:/prog8lib/c128/syslib.p8:1108   &uword r0  = $1be0
	; source: library:/prog8lib/c128/syslib.p8:1109   &uword r1  = $1be2
	; source: library:/prog8lib/c128/syslib.p8:1110   &uword r2  = $1be4
	; source: library:/prog8lib/c128/syslib.p8:1111   &uword r3  = $1be6
	; source: library:/prog8lib/c128/syslib.p8:1112   &uword r4  = $1be8
	; source: library:/prog8lib/c128/syslib.p8:1113   &uword r5  = $1bea
	; source: library:/prog8lib/c128/syslib.p8:1114   &uword r6  = $1bec
	; source: library:/prog8lib/c128/syslib.p8:1115   &uword r7  = $1bee
	; source: library:/prog8lib/c128/syslib.p8:1116   &uword r8  = $1bf0
	; source: library:/prog8lib/c128/syslib.p8:1117   &uword r9  = $1bf2
	; source: library:/prog8lib/c128/syslib.p8:1118   &uword r10 = $1bf4
	; source: library:/prog8lib/c128/syslib.p8:1119   &uword r11 = $1bf6
	; source: library:/prog8lib/c128/syslib.p8:1120   &uword r12 = $1bf8
	; source: library:/prog8lib/c128/syslib.p8:1121   &uword r13 = $1bfa
	; source: library:/prog8lib/c128/syslib.p8:1122   &uword r14 = $1bfc
	; source: library:/prog8lib/c128/syslib.p8:1123   &uword r15 = $1bfe
	; source: library:/prog8lib/c128/syslib.p8:1126   &word r0s  = $1be0
	; source: library:/prog8lib/c128/syslib.p8:1127   &word r1s  = $1be2
	; source: library:/prog8lib/c128/syslib.p8:1128   &word r2s  = $1be4
	; source: library:/prog8lib/c128/syslib.p8:1129   &word r3s  = $1be6
	; source: library:/prog8lib/c128/syslib.p8:1130   &word r4s  = $1be8
	; source: library:/prog8lib/c128/syslib.p8:1131   &word r5s  = $1bea
	; source: library:/prog8lib/c128/syslib.p8:1132   &word r6s  = $1bec
	; source: library:/prog8lib/c128/syslib.p8:1133   &word r7s  = $1bee
	; source: library:/prog8lib/c128/syslib.p8:1134   &word r8s  = $1bf0
	; source: library:/prog8lib/c128/syslib.p8:1135   &word r9s  = $1bf2
	; source: library:/prog8lib/c128/syslib.p8:1136   &word r10s = $1bf4
	; source: library:/prog8lib/c128/syslib.p8:1137   &word r11s = $1bf6
	; source: library:/prog8lib/c128/syslib.p8:1138   &word r12s = $1bf8
	; source: library:/prog8lib/c128/syslib.p8:1139   &word r13s = $1bfa
	; source: library:/prog8lib/c128/syslib.p8:1140   &word r14s = $1bfc
	; source: library:/prog8lib/c128/syslib.p8:1141   &word r15s = $1bfe
	; source: library:/prog8lib/c128/syslib.p8:1144   &long r0r1sl  = $1be0
	; source: library:/prog8lib/c128/syslib.p8:1145   &long r2r3sl  = $1be4
	; source: library:/prog8lib/c128/syslib.p8:1146   &long r4r5sl  = $1be8
	; source: library:/prog8lib/c128/syslib.p8:1147   &long r6r7sl  = $1bec
	; source: library:/prog8lib/c128/syslib.p8:1148   &long r8r9sl  = $1bf0
	; source: library:/prog8lib/c128/syslib.p8:1149   &long r10r11sl = $1bf4
	; source: library:/prog8lib/c128/syslib.p8:1150   &long r12r13sl = $1bf8
	; source: library:/prog8lib/c128/syslib.p8:1151   &long r14r15sl = $1bfc
	; source: library:/prog8lib/c128/syslib.p8:1154   &ubyte r0L  = $1be0
	; source: library:/prog8lib/c128/syslib.p8:1155   &ubyte r1L  = $1be2
	; source: library:/prog8lib/c128/syslib.p8:1156   &ubyte r2L  = $1be4
	; source: library:/prog8lib/c128/syslib.p8:1157   &ubyte r3L  = $1be6
	; source: library:/prog8lib/c128/syslib.p8:1158   &ubyte r4L  = $1be8
	; source: library:/prog8lib/c128/syslib.p8:1159   &ubyte r5L  = $1bea
	; source: library:/prog8lib/c128/syslib.p8:1160   &ubyte r6L  = $1bec
	; source: library:/prog8lib/c128/syslib.p8:1161   &ubyte r7L  = $1bee
	; source: library:/prog8lib/c128/syslib.p8:1162   &ubyte r8L  = $1bf0
	; source: library:/prog8lib/c128/syslib.p8:1163   &ubyte r9L  = $1bf2
	; source: library:/prog8lib/c128/syslib.p8:1164   &ubyte r10L = $1bf4
	; source: library:/prog8lib/c128/syslib.p8:1165   &ubyte r11L = $1bf6
	; source: library:/prog8lib/c128/syslib.p8:1166   &ubyte r12L = $1bf8
	; source: library:/prog8lib/c128/syslib.p8:1167   &ubyte r13L = $1bfa
	; source: library:/prog8lib/c128/syslib.p8:1168   &ubyte r14L = $1bfc
	; source: library:/prog8lib/c128/syslib.p8:1169   &ubyte r15L = $1bfe
	; source: library:/prog8lib/c128/syslib.p8:1171   &ubyte r0H  = $1be1
	; source: library:/prog8lib/c128/syslib.p8:1172   &ubyte r1H  = $1be3
	; source: library:/prog8lib/c128/syslib.p8:1173   &ubyte r2H  = $1be5
	; source: library:/prog8lib/c128/syslib.p8:1174   &ubyte r3H  = $1be7
	; source: library:/prog8lib/c128/syslib.p8:1175   &ubyte r4H  = $1be9
	; source: library:/prog8lib/c128/syslib.p8:1176   &ubyte r5H  = $1beb
	; source: library:/prog8lib/c128/syslib.p8:1177   &ubyte r6H  = $1bed
	; source: library:/prog8lib/c128/syslib.p8:1178   &ubyte r7H  = $1bef
	; source: library:/prog8lib/c128/syslib.p8:1179   &ubyte r8H  = $1bf1
	; source: library:/prog8lib/c128/syslib.p8:1180   &ubyte r9H  = $1bf3
	; source: library:/prog8lib/c128/syslib.p8:1181   &ubyte r10H = $1bf5
	; source: library:/prog8lib/c128/syslib.p8:1182   &ubyte r11H = $1bf7
	; source: library:/prog8lib/c128/syslib.p8:1183   &ubyte r12H = $1bf9
	; source: library:/prog8lib/c128/syslib.p8:1184   &ubyte r13H = $1bfb
	; source: library:/prog8lib/c128/syslib.p8:1185   &ubyte r14H = $1bfd
	; source: library:/prog8lib/c128/syslib.p8:1186   &ubyte r15H = $1bff
	; source: library:/prog8lib/c128/syslib.p8:1189   &byte r0sL  = $1be0
	; source: library:/prog8lib/c128/syslib.p8:1190   &byte r1sL  = $1be2
	; source: library:/prog8lib/c128/syslib.p8:1191   &byte r2sL  = $1be4
	; source: library:/prog8lib/c128/syslib.p8:1192   &byte r3sL  = $1be6
	; source: library:/prog8lib/c128/syslib.p8:1193   &byte r4sL  = $1be8
	; source: library:/prog8lib/c128/syslib.p8:1194   &byte r5sL  = $1bea
	; source: library:/prog8lib/c128/syslib.p8:1195   &byte r6sL  = $1bec
	; source: library:/prog8lib/c128/syslib.p8:1196   &byte r7sL  = $1bee
	; source: library:/prog8lib/c128/syslib.p8:1197   &byte r8sL  = $1bf0
	; source: library:/prog8lib/c128/syslib.p8:1198   &byte r9sL  = $1bf2
	; source: library:/prog8lib/c128/syslib.p8:1199   &byte r10sL = $1bf4
	; source: library:/prog8lib/c128/syslib.p8:1200   &byte r11sL = $1bf6
	; source: library:/prog8lib/c128/syslib.p8:1201   &byte r12sL = $1bf8
	; source: library:/prog8lib/c128/syslib.p8:1202   &byte r13sL = $1bfa
	; source: library:/prog8lib/c128/syslib.p8:1203   &byte r14sL = $1bfc
	; source: library:/prog8lib/c128/syslib.p8:1204   &byte r15sL = $1bfe
	; source: library:/prog8lib/c128/syslib.p8:1206   &byte r0sH  = $1be1
	; source: library:/prog8lib/c128/syslib.p8:1207   &byte r1sH  = $1be3
	; source: library:/prog8lib/c128/syslib.p8:1208   &byte r2sH  = $1be5
	; source: library:/prog8lib/c128/syslib.p8:1209   &byte r3sH  = $1be7
	; source: library:/prog8lib/c128/syslib.p8:1210   &byte r4sH  = $1be9
	; source: library:/prog8lib/c128/syslib.p8:1211   &byte r5sH  = $1beb
	; source: library:/prog8lib/c128/syslib.p8:1212   &byte r6sH  = $1bed
	; source: library:/prog8lib/c128/syslib.p8:1213   &byte r7sH  = $1bef
	; source: library:/prog8lib/c128/syslib.p8:1214   &byte r8sH  = $1bf1
	; source: library:/prog8lib/c128/syslib.p8:1215   &byte r9sH  = $1bf3
	; source: library:/prog8lib/c128/syslib.p8:1216   &byte r10sH = $1bf5
	; source: library:/prog8lib/c128/syslib.p8:1217   &byte r11sH = $1bf7
	; source: library:/prog8lib/c128/syslib.p8:1218   &byte r12sH = $1bf9
	; source: library:/prog8lib/c128/syslib.p8:1219   &byte r13sH = $1bfb
	; source: library:/prog8lib/c128/syslib.p8:1220   &byte r14sH = $1bfd
	; source: library:/prog8lib/c128/syslib.p8:1221   &byte r15sH = $1bff
	; source: library:/prog8lib/c128/syslib.p8:1224   &bool r0bL  = $1be0
	; source: library:/prog8lib/c128/syslib.p8:1225   &bool r1bL  = $1be2
	; source: library:/prog8lib/c128/syslib.p8:1226   &bool r2bL  = $1be4
	; source: library:/prog8lib/c128/syslib.p8:1227   &bool r3bL  = $1be6
	; source: library:/prog8lib/c128/syslib.p8:1228   &bool r4bL  = $1be8
	; source: library:/prog8lib/c128/syslib.p8:1229   &bool r5bL  = $1bea
	; source: library:/prog8lib/c128/syslib.p8:1230   &bool r6bL  = $1bec
	; source: library:/prog8lib/c128/syslib.p8:1231   &bool r7bL  = $1bee
	; source: library:/prog8lib/c128/syslib.p8:1232   &bool r8bL  = $1bf0
	; source: library:/prog8lib/c128/syslib.p8:1233   &bool r9bL  = $1bf2
	; source: library:/prog8lib/c128/syslib.p8:1234   &bool r10bL = $1bf4
	; source: library:/prog8lib/c128/syslib.p8:1235   &bool r11bL = $1bf6
	; source: library:/prog8lib/c128/syslib.p8:1236   &bool r12bL = $1bf8
	; source: library:/prog8lib/c128/syslib.p8:1237   &bool r13bL = $1bfa
	; source: library:/prog8lib/c128/syslib.p8:1238   &bool r14bL = $1bfc
	; source: library:/prog8lib/c128/syslib.p8:1239   &bool r15bL = $1bfe
	; source: library:/prog8lib/c128/syslib.p8:1241   &bool r0bH  = $1be1
	; source: library:/prog8lib/c128/syslib.p8:1242   &bool r1bH  = $1be3
	; source: library:/prog8lib/c128/syslib.p8:1243   &bool r2bH  = $1be5
	; source: library:/prog8lib/c128/syslib.p8:1244   &bool r3bH  = $1be7
	; source: library:/prog8lib/c128/syslib.p8:1245   &bool r4bH  = $1be9
	; source: library:/prog8lib/c128/syslib.p8:1246   &bool r5bH  = $1beb
	; source: library:/prog8lib/c128/syslib.p8:1247   &bool r6bH  = $1bed
	; source: library:/prog8lib/c128/syslib.p8:1248   &bool r7bH  = $1bef
	; source: library:/prog8lib/c128/syslib.p8:1249   &bool r8bH  = $1bf1
	; source: library:/prog8lib/c128/syslib.p8:1250   &bool r9bH  = $1bf3
	; source: library:/prog8lib/c128/syslib.p8:1251   &bool r10bH = $1bf5
	; source: library:/prog8lib/c128/syslib.p8:1252   &bool r11bH = $1bf7
	; source: library:/prog8lib/c128/syslib.p8:1253   &bool r12bH = $1bf9
	; source: library:/prog8lib/c128/syslib.p8:1254   &bool r13bH = $1bfb
	; source: library:/prog8lib/c128/syslib.p8:1255   &bool r14bH = $1bfd
	; source: library:/prog8lib/c128/syslib.p8:1256   &bool r15bH = $1bff
	; source: library:/prog8lib/c128/syslib.p8:1103   cx16 {
	; source: library:/prog8lib/c128/syslib.p8:1259   asmsub save_virtual_registers() clobbers(A,Y) {

save_virtual_registers	.proc
	; source: library:/prog8lib/c128/syslib.p8:1260   %asm {{
            ldy  #31
    -       lda  cx16.r0,y
            sta  _cx16_vreg_storage,y
            dey
            bpl  -
            rts

            .section BSS
    _cx16_vreg_storage
            .word ?,?,?,?,?,?,?,?
            .word ?,?,?,?,?,?,?,?
            .send BSS
            ; !notreached!
	.pend
	; source: library:/prog8lib/c128/syslib.p8:1277   asmsub restore_virtual_registers() clobbers(A,Y) {

restore_virtual_registers	.proc
	; source: library:/prog8lib/c128/syslib.p8:1278   %asm {{
            ldy  #31
    -       lda  save_virtual_registers._cx16_vreg_storage,y
            sta  cx16.r0,y
            dey
            bpl  -
            rts
	.pend
	.pend

; ---- block: 'conv' ----
conv	.proc
	; source: library:/prog8lib/conv.p8:3   conv {

; non-zeropage variables
	.section BSS
string_out	.fill  16
	.send BSS

	; source: library:/prog8lib/conv.p8:941   ubyte[16]  @shared string_out       ; internal result buffer for the string conversion routines (note: uses uninitialized ARRAY instead of STR, to force it to be allocated in BSS area so it's ROM-compatible)
	; source: library:/prog8lib/conv.p8:5   %option no_symbol_prefixing, ignore_unused
	; source: library:/prog8lib/conv.p8:9   asmsub str_ub0(ubyte value @A) clobbers(X) -> str @AY {

str_ub0	.proc
	; source: library:/prog8lib/conv.p8:11   %asm {{
            jsr  internal_ubyte2decimal
            sty  conv.string_out
            stx  conv.string_out+1
            sta  conv.string_out+2
            lda  #0
            sta  conv.string_out+3
            lda  #<conv.string_out
            ldy  #>conv.string_out
            rts
	.pend
	; source: library:/prog8lib/conv.p8:24   asmsub str_ub(ubyte value @A) clobbers(X) -> str @AY {

str_ub	.proc
	; source: library:/prog8lib/conv.p8:26   %asm {{
            jsr  internal_ubyte2decimal
            cpy  #'0'
            beq  +
            sty  conv.string_out
            stx  conv.string_out+1
            sta  conv.string_out+2
            lda  #0
            sta  conv.string_out+3
            jmp  _done
+           cpx  #'0'
            beq  +
            stx  conv.string_out
            sta  conv.string_out+1
            lda  #0
            sta  conv.string_out+2
            jmp  _done
+           sta  conv.string_out
            lda  #0
            sta  conv.string_out+1
_done       lda  #<conv.string_out
            ldy  #>conv.string_out
            rts
	.pend
	; source: library:/prog8lib/conv.p8:52   asmsub str_b(byte value @A) clobbers(X) -> str @AY {

str_b	.proc
	; source: library:/prog8lib/conv.p8:54   %asm {{
            cmp  #0
            bpl  str_ub
            eor  #255
            clc
            adc  #1
            jsr  str_ub
            ; insert a minus sign at the start
            lda  #0
            sta  conv.string_out+4
            lda  conv.string_out+2
            sta  conv.string_out+3
            lda  conv.string_out+1
            sta  conv.string_out+2
            lda  conv.string_out
            sta  conv.string_out+1
            lda  #'-'
            sta  conv.string_out
            lda  #<conv.string_out
            ldy  #>conv.string_out
            rts
	.pend
	; source: library:/prog8lib/conv.p8:78   asmsub  str_ubhex  (ubyte value @ A) clobbers(X) -> str @AY {

str_ubhex	.proc
	; source: library:/prog8lib/conv.p8:80   %asm {{
        jsr  internal_ubyte2hex
        sta  string_out
        sty  string_out+1
        lda  #0
        sta  string_out+2
        lda  #<string_out
        ldy  #>string_out
        rts
	.pend
	; source: library:/prog8lib/conv.p8:92   asmsub  str_ubbin  (ubyte value @ A) clobbers(X) -> str @AY  {

str_ubbin	.proc
	; source: library:/prog8lib/conv.p8:94   %asm {{
	    sta  P8ZP_SCRATCH_B1
	    ldy  #0
	    sty  string_out+8
	    ldy  #7
-	    lsr  P8ZP_SCRATCH_B1
        bcc  +
        lda  #'1'
        bne  _digit
+       lda  #'0'
_digit  sta  string_out,y
        dey
	    bpl  -
        lda  #<string_out
        ldy  #>string_out
	    rts
	.pend
	; source: library:/prog8lib/conv.p8:113   asmsub  str_uwbin  (uword value @ AY) clobbers(X) -> str @AY  {

str_uwbin	.proc
	; source: library:/prog8lib/conv.p8:115   %asm {{
	    sta  P8ZP_SCRATCH_REG
	    tya
	    jsr  str_ubbin
	    ldy  #0
	    sty  string_out+16
	    ldy  #7
-	    lsr  P8ZP_SCRATCH_REG
        bcc  +
        lda  #'1'
        bne  _digit
+       lda  #'0'
_digit  sta  string_out+8,y
        dey
	    bpl  -
        lda  #<string_out
        ldy  #>string_out
	    rts
	.pend
	; source: library:/prog8lib/conv.p8:136   asmsub  str_uwhex  (uword value @ AY) -> str @AY  {

str_uwhex	.proc
	; source: library:/prog8lib/conv.p8:138   %asm {{
        pha
        tya
        jsr  internal_ubyte2hex
        sta  string_out
        sty  string_out+1
        pla
        jsr  internal_ubyte2hex
        sta  string_out+2
        sty  string_out+3
        lda  #0
        sta  string_out+4
        lda  #<string_out
        ldy  #>string_out
        rts
	.pend
	; source: library:/prog8lib/conv.p8:180   asmsub  str_uw0  (uword value @ AY) clobbers(X) -> str @AY  {

str_uw0	.proc
	; source: library:/prog8lib/conv.p8:182   %asm {{
	    jsr  conv.internal_uword2decimal
	    ldy  #0
-       lda  conv.internal_uword2decimal.decTenThousands,y
        sta  string_out,y
        beq  +
        iny
        bne  -
+
        lda  #<string_out
        ldy  #>string_out
        rts
	.pend
	; source: library:/prog8lib/conv.p8:197   asmsub  str_uw  (uword value @ AY) clobbers(X) -> str @AY  {

str_uw	.proc
	; source: library:/prog8lib/conv.p8:199   %asm {{
	    jsr  conv.internal_uword2decimal
	    ldx  #0
_output_digits
	    ldy  #0
-       lda  internal_uword2decimal.decTenThousands,y
        beq  _allzero
        cmp  #'0'
        bne  _gotdigit
        iny
        bne  -
_gotdigit   sta  string_out,x
        inx
        iny
        lda  internal_uword2decimal.decTenThousands,y
        bne  _gotdigit
_end    lda  #0
        sta  string_out,x
        lda  #<string_out
        ldy  #>string_out
        rts

_allzero    lda  #'0'
        sta  string_out,x
        inx
        bne  _end
        ; !notreached!
	.pend
	; source: library:/prog8lib/conv.p8:229   asmsub  str_w  (word value @ AY) clobbers(X) -> str @AY  {

str_w	.proc
	; source: library:/prog8lib/conv.p8:231   %asm {{
	    cpy  #0
	    bpl  str_uw
	    pha
	    lda  #'-'
	    sta  string_out
        tya
        eor  #255
        tay
        pla
        eor  #255
        clc
        adc  #1
        bcc  +
        iny
+	    jsr  conv.internal_uword2decimal
	    ldx  #1
	    bne  str_uw._output_digits
	    rts
	.pend
	; source: library:/prog8lib/conv.p8:332   asmsub  any2uword(str string @AY) -> uword @AY, ubyte @X {

any2uword	.proc
	; source: library:/prog8lib/conv.p8:338   %asm {{
	pha
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	ldy  P8ZP_SCRATCH_W1+1
	cmp  #'$'
	beq  _hex
	cmp  #'%'
	beq  _bin
	pla
	jsr  str2uword
	jmp  _result
_hex	pla
	jsr  hex2uword
	jmp  _result
_bin	pla
	jsr  bin2uword
_result
        ldx  cx16.r15
        rts
	.pend
	; source: library:/prog8lib/conv.p8:363   inline asmsub  str2ubyte(str string @AY) clobbers(Y) -> ubyte @A {
	; source: library:/prog8lib/conv.p8:373   inline asmsub  str2byte(str string @AY) clobbers(Y) -> byte @A {
	; source: library:/prog8lib/conv.p8:383   asmsub  str2uword(str string @AY) -> uword @AY {

str2uword	.proc
	; source: library:/prog8lib/conv.p8:388   %asm {{
_result = P8ZP_SCRATCH_W1
        	sta  P8ZP_SCRATCH_W2
        	sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sty  _result
		sty  _result+1
		sty  cx16.r15+1
_loop
		lda  (P8ZP_SCRATCH_W2),y
		sec
		sbc  #48
		bpl  _digit
_done
		sty  cx16.r15
		lda  _result
		ldy  _result+1
		rts
_digit
		cmp  #10
		bcs  _done
		; add digit to result
		pha
		jsr  _result_times_10
		pla
		clc
		adc  _result
		sta  _result
		bcc  +
		inc  _result+1
+		iny
		bne  _loop
		; never reached

_result_times_10     ; (W*4 + W)*2
		lda  _result+1
		sta  P8ZP_SCRATCH_REG
		lda  _result
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  _result
		sta  _result
		lda  P8ZP_SCRATCH_REG
		adc  _result+1
		asl  _result
		rol  a
		sta  _result+1
		rts
	.pend
	; source: library:/prog8lib/conv.p8:442   asmsub  str2word(str string @AY) -> word @AY {

str2word	.proc
	; source: library:/prog8lib/conv.p8:447   %asm {{
_result = P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sty  _result
		sty  _result+1
		sty  _negative
		sty  cx16.r15+1
		lda  (P8ZP_SCRATCH_W2),y
		cmp  #'+'
		bne  +
		iny
+		cmp  #'-'
		bne  _parse
		inc  _negative
		iny
_parse		lda  (P8ZP_SCRATCH_W2),y
		sec
		sbc  #48
		bpl  _digit
_done
		sty  cx16.r15
		lda  _negative
		beq  +
		sec
		lda  #0
		sbc  _result
		sta  _result
		lda  #0
		sbc  _result+1
		sta  _result+1
+		lda  _result
		ldy  _result+1
		rts
_digit
		cmp  #10
		bcs  _done
		; add digit to result
		pha
		jsr  str2uword._result_times_10
		pla
		clc
		adc  _result
		sta  _result
		bcc  +
		inc  _result+1
+		iny
		bne  _parse
		; never reached
		.section BSS
_negative	.byte  ?
		.send BSS
        ; !notreached!
	.pend
	; source: library:/prog8lib/conv.p8:504   asmsub  hex2uword(str string @AY) -> uword @AY {

hex2uword	.proc
	; source: library:/prog8lib/conv.p8:509   %asm {{
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	sty  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	sty  cx16.r15+1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #'$'
	bne  _loop
	iny
_loop
	lda  #0
	sta  P8ZP_SCRATCH_B1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #7                 ; screencode letters A-F are 1-6
	bcc  _add_letter
	and  #127
	cmp  #97
	bcs  _try_iso            ; maybe letter is iso:'a'-iso:'f' (97-102)
	cmp  #'g'
	bcs  _stop
	cmp  #'a'
	bcs  _add_letter
	cmp  #'0'
	bcc  _stop
	cmp  #'9'+1
	bcs  _stop
_calc
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	and  #$0f
	clc
	adc  P8ZP_SCRATCH_B1
	ora  P8ZP_SCRATCH_W1
	sta  P8ZP_SCRATCH_W1
	iny
	bne  _loop
_stop
	sty  cx16.r15
	lda  P8ZP_SCRATCH_W1
	ldy  P8ZP_SCRATCH_W1+1
	rts
_add_letter
	pha
	lda  #9
	sta  P8ZP_SCRATCH_B1
	pla
	jmp  _calc
_try_iso
        cmp  #103
        bcs  _stop
        and  #63
        bne  _add_letter
		; !notreached!
	.pend
	; source: library:/prog8lib/conv.p8:575   asmsub hex2long(str string @AY) -> long @R0R1_32 {

hex2long	.proc
	; source: library:/prog8lib/conv.p8:580   %asm {{
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	sty  cx16.r0
	sty  cx16.r0+1
	sty  cx16.r0+2
	sty  cx16.r0+3
	sty  cx16.r15H
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #'$'
	bne  _loop
	iny
_loop
	lda  #0
	sta  P8ZP_SCRATCH_B1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #7                 ; screencode letters A-F are 1-6
	bcc  _add_letter
	and  #127
	cmp  #97
	bcs  _try_iso            ; maybe letter is iso:'a'-iso:'f' (97-102)
	cmp  #'g'
	bcs  _stop
	cmp  #'a'
	bcs  _add_letter
	cmp  #'0'
	bcc  _stop
	cmp  #'9'+1
	bcs  _stop
_calc
	asl  cx16.r0
	rol  cx16.r0+1
	rol  cx16.r0+2
	rol  cx16.r0+3
	asl  cx16.r0
	rol  cx16.r0+1
	rol  cx16.r0+2
	rol  cx16.r0+3
	asl  cx16.r0
	rol  cx16.r0+1
	rol  cx16.r0+2
	rol  cx16.r0+3
	asl  cx16.r0
	rol  cx16.r0+1
	rol  cx16.r0+2
	rol  cx16.r0+3
	and  #$0f
	clc
	adc  P8ZP_SCRATCH_B1
	ora  cx16.r0
	sta  cx16.r0
	iny
	bne  _loop
_stop
	sty  cx16.r15L
	rts
_add_letter
	pha
	lda  #9
	sta  P8ZP_SCRATCH_B1
	pla
	jmp  _calc
_try_iso
        cmp  #103
        bcs  _stop
        and  #63
        bne  _add_letter
		; !notreached!
	.pend
	; source: library:/prog8lib/conv.p8:654   asmsub  bin2uword(str string @AY) -> uword @AY {

bin2uword	.proc
	; source: library:/prog8lib/conv.p8:658   %asm {{
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	sty  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	sty  cx16.r15+1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #'%'
	bne  _loop
	iny
_loop
	lda  (P8ZP_SCRATCH_W2),y
	cmp  #'0'
	bcc  _stop
	cmp  #'2'
	bcs  _stop
_first  asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	and  #1
	ora  P8ZP_SCRATCH_W1
	sta  P8ZP_SCRATCH_W1
	iny
	bne  _loop
_stop
	sty  cx16.r15
	lda  P8ZP_SCRATCH_W1
	ldy  P8ZP_SCRATCH_W1+1
	rts
	.pend
	; source: library:/prog8lib/conv.p8:694   asmsub internal_ubyte2decimal(ubyte value @A) -> ubyte @Y, ubyte @X, ubyte @A {

internal_ubyte2decimal	.proc
	; source: library:/prog8lib/conv.p8:695   %asm {{
        ldy  #'0'-1
        ldx  #'9'+1
        sec
-       iny
        sbc  #100
        bcs  -
-       dex
        adc  #10
        bmi  -
        adc  #'0'-1
        rts
	.pend
	; source: library:/prog8lib/conv.p8:710   asmsub  internal_uword2decimal  (uword value @AY) -> ubyte @Y, ubyte @A, ubyte @X  {

internal_uword2decimal	.proc
	; source: library:/prog8lib/conv.p8:716   %asm {{
;Convert 16 bit Hex to Decimal (0-65535) Rev 2
;By Omegamatrix    Further optimizations by tepples
; routine from https://forums.nesdev.org/viewtopic.php?p=130363&sid=1944ba8bac4d6afa9c02e3cc42304e6b#p130363

;HexToDec99
; start in A
; end with A = 10's, decOnes (also in X)

;HexToDec255
; start in A
; end with Y = 100's, A = 10's, decOnes (also in X)

;HexToDec999
; start with A = high byte, Y = low byte
; end with Y = 100's, A = 10's, decOnes (also in X)
; requires 1 extra temp register on top of decOnes, could combine
; these two if HexToDec65535 was eliminated...

;HexToDec65535
; start with A/Y (low/high) as 16 bit value
; end with decTenThousand, decThousand, Y = 100's, A = 10's, decOnes (also in X)
; (irmen: I store Y and A in decHundreds and decTens too, so all of it can be easily printed)


ASCII_0_OFFSET 	= $30
temp       	    = P8ZP_SCRATCH_B1	; byte in zeropage
hexHigh      	= P8ZP_SCRATCH_W1	; byte in zeropage
hexLow       	= P8ZP_SCRATCH_W1+1	; byte in zeropage


HexToDec65535; SUBROUTINE
    sty    hexHigh               ;3  @9
    sta    hexLow                ;3  @12
    tya
    tax                          ;2  @14
    lsr    a                     ;2  @16
    lsr    a                     ;2  @18   integer divide 1024 (result 0-63)

    cpx    #$A7                  ;2  @20   account for overflow of multiplying 24 from 43,000 ($A7F8) onward,
    adc    #1                    ;2  @22   we can just round it to $A700, and the divide by 1024 is fine...

    ;at this point we have a number 1-65 that we have to times by 24,
    ;add to original sum, and Mod 1024 to get a remainder 0-999


    sta    temp                  ;3  @25
    asl    a                     ;2  @27
    adc    temp                  ;3  @30  x3
    tay                          ;2  @32
    lsr    a                     ;2  @34
    lsr    a                     ;2  @36
    lsr    a                     ;2  @38
    lsr    a                     ;2  @40
    lsr    a                     ;2  @42
    tax                          ;2  @44
    tya                          ;2  @46
    asl    a                     ;2  @48
    asl    a                     ;2  @50
    asl    a                     ;2  @52
    clc                          ;2  @54
    adc    hexLow                ;3  @57
    sta    hexLow                ;3  @60
    txa                          ;2  @62
    adc    hexHigh               ;3  @65
    sta    hexHigh               ;3  @68
    ror    a                     ;2  @70
    lsr    a                     ;2  @72
    tay                          ;2  @74    integer divide 1,000 (result 0-65)

    lsr    a                     ;2  @76    split the 1,000 and 10,000 digit
    tax                          ;2  @78
    lda    ShiftedBcdTab,x       ;4  @82
    tax                          ;2  @84
    rol    a                     ;2  @86
    and    #$0F                  ;2  @88
    ora    #ASCII_0_OFFSET
    sta    decThousands          ;3  @91
    txa                          ;2  @93
    lsr    a                     ;2  @95
    lsr    a                     ;2  @97
    lsr    a                     ;2  @99
    ora    #ASCII_0_OFFSET
    sta    decTenThousands       ;3  @102

    lda    hexLow                ;3  @105
    cpy    temp                  ;3  @108
    bmi    _doSubtract           ;2 @110/111
    beq    _useZero               ;2 @112/113
    adc    #23 + 24              ;2  @114
_doSubtract
    sbc    #23                   ;2  @116
    sta    hexLow                ;3  @119
_useZero
    lda    hexHigh               ;3  @122
    sbc    #0                    ;2  @124

Start100s
    and    #$03                  ;2  @126
    tax                          ;2  @128   0,1,2,3
    cmp    #2                    ;2  @130
    rol    a                     ;2  @132   0,2,5,7
    ora    #ASCII_0_OFFSET
    tay                          ;2  @134   Y = Hundreds digit

    lda    hexLow                ;3  @137
    adc    Mod100Tab,x           ;4  @141    adding remainder of 256, 512, and 256+512 (all mod 100)
    bcs    hex_doSub200             ;2 @143/144

hex_try200
    cmp    #200                  ;2  @145
    bcc    hex_try100               ;2 @147/148
hex_doSub200
    iny                          ;2  @149
    iny                          ;2  @151
    sbc    #200                  ;2  @153
hex_try100
    cmp    #100                  ;2  @155
    bcc    HexToDec99            ;2 @157/158
    iny                          ;2  @159
    sbc    #100                  ;2  @161

HexToDec99; SUBROUTINE
    lsr    a                     ;2  @163
    tax                          ;2  @165
    lda    ShiftedBcdTab,x       ;4  @169
    tax                          ;2  @171
    rol    a                     ;2  @173
    and    #$0F                  ;2  @175
    ora    #ASCII_0_OFFSET
    sta    decOnes               ;3  @178
    txa                          ;2  @180
    lsr    a                     ;2  @182
    lsr    a                     ;2  @184
    lsr    a                     ;2  @186
    ora    #ASCII_0_OFFSET

    ; irmen: load X with ones, and store Y and A too, for easy printing afterwards
    sty  decHundreds
    sta  decTens
    ldx  decOnes
    rts                          ;6  @192   Y=hundreds, A = tens digit, X=ones digit


HexToDec999; SUBROUTINE
    sty    hexLow                ;3  @9
    jmp    Start100s             ;3  @12

Mod100Tab
    .byte 0,56,12,56+12

ShiftedBcdTab
    .byte $00,$01,$02,$03,$04,$08,$09,$0A,$0B,$0C
    .byte $10,$11,$12,$13,$14,$18,$19,$1A,$1B,$1C
    .byte $20,$21,$22,$23,$24,$28,$29,$2A,$2B,$2C
    .byte $30,$31,$32,$33,$34,$38,$39,$3A,$3B,$3C
    .byte $40,$41,$42,$43,$44,$48,$49,$4A,$4B,$4C

    .section BSS
decTenThousands   	.byte  ?
decThousands    	.byte  ?
decHundreds		.byte  ?
decTens			.byte  ?
decOnes   		.byte  ?
			.byte  ?		; zero-terminate the decimal output string, set to 0 by bss init mechanisms
    .send BSS
		; !notreached!
	.pend
	; source: library:/prog8lib/conv.p8:887   asmsub  internal_byte2decimal  (byte value @A) -> ubyte @Y, ubyte @A, ubyte @X  {

internal_byte2decimal	.proc
	; source: library:/prog8lib/conv.p8:890   %asm {{
		cmp  #0
		bpl  +
		eor  #255
		clc
		adc  #1
+		jmp  internal_ubyte2decimal
	.pend
	; source: library:/prog8lib/conv.p8:900   asmsub  internal_ubyte2hex  (ubyte value @A) clobbers(X) -> ubyte @A, ubyte @Y  {

internal_ubyte2hex	.proc
	; source: library:/prog8lib/conv.p8:902   %asm {{
		pha
		and  #$0f
		tax
		ldy  _hex_digits,x
		pla
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		tax
		lda  _hex_digits,x
		rts

_hex_digits	.text "0123456789abcdef"	; can probably be reused for other stuff as well
		; !notreached!
	.pend
	; source: library:/prog8lib/conv.p8:921   asmsub  internal_uword2hex  (uword value @AY) clobbers(A,Y)  {

internal_uword2hex	.proc
	; source: library:/prog8lib/conv.p8:923   %asm {{
		sta  P8ZP_SCRATCH_REG
		tya
		jsr  ubyte2hex
		sta  output
		sty  output+1
		lda  P8ZP_SCRATCH_REG
		jsr  ubyte2hex
		sta  output+2
		sty  output+3
		rts
		.section BSS
output		.fill 5      ; 0-terminated output buffer (to make printing easier)
		.send BSS
		; !notreached!
	.pend
	.pend

; ---- block: 'p8b_config' ----
p8b_config	.proc
	; source: config.p8:5   config {
	p8c_config_load_address = $1000

; non-zeropage variables
	.section BSS
p8v_configdirectives_lsb	.fill  64
p8v_configdirectives_msb	.fill  64
p8v_configdrive	.byte  ?
p8v_configfilename	.word  ?
p8v_configpos	.byte  ?
p8v_configvalues_lsb	.fill  64
p8v_configvalues_msb	.fill  64
p8v_configword	.word  ?
p8v_readchar	.byte  ?
	.send BSS

	; source: config.p8:7   ubyte configdrive = 8
	; source: config.p8:8   uword configfilename = "bbsconfig"
	; source: config.p8:10   str[64] configdirectives
	; source: config.p8:11   str[64] configvalues
	; source: config.p8:12   uword configword = ""
	; source: config.p8:13   ubyte configpos = 0
	; source: config.p8:14   ubyte readchar = 0
	; source: config.p8:15   uword config_load_address = $1000  ; Memory address where config file is loaded
	; source: config.p8:17   sub load() -> bool {

p8s_load	.proc
	p8c_parse_start = $1000
; statements
	; source: config.p8:73   ubyte[2] char_buf
	; source: config.p8:34   uword end_address = diskio.load(configfilename, config_load_address)
	; source: config.p8:42   uword file_size = end_address - config_load_address
	; source: config.p8:51   ubyte i = 0
	; source: config.p8:52   uword counter = 0
	; source: config.p8:57   uword parse_start = config_load_address
	; source: config.p8:18   txt.print("Loading config...")
	ldy  #>prog8_interned_strings.string_18
	lda  #<prog8_interned_strings.string_18
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: config.p8:22   diskio.drivenumber = configdrive
	lda  p8b_config.p8v_configdrive
	sta  diskio.drivenumber
	; source: config.p8:25   if not diskio.exists(configfilename) {
	ldy  p8b_config.p8v_configfilename+1
	lda  p8b_config.p8v_configfilename
	jsr  diskio.exists
	cmp  #0
	bne  p8_label_gen_205_afterif
	; source: config.p8:26   txt.print("Config file not found.")
	ldy  #>prog8_interned_strings.string_19
	lda  #<prog8_interned_strings.string_19
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: config.p8:28   return false
	lda  #0
	rts
p8_label_gen_205_afterif
	; source: config.p8:34   uword end_address = diskio.load(configfilename, config_load_address)
	lda  p8b_config.p8v_configfilename
	ldy  p8b_config.p8v_configfilename+1
	sta  diskio.load.filenameptr
	sty  diskio.load.filenameptr+1
	lda  #<$1000
	ldy  #>$1000
	sta  diskio.load.address_override
	sty  diskio.load.address_override+1
	jsr  diskio.load
	sta  p8v_end_address
	sty  p8v_end_address+1
	; source: config.p8:36   if end_address == 0 {
	ora  p8v_end_address+1
	bne  p8_label_gen_206_afterif
	; source: config.p8:37   txt.print("Error: Could not load config file")
	ldy  #>prog8_interned_strings.string_20
	lda  #<prog8_interned_strings.string_20
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: config.p8:39   return false
	lda  #0
	rts
p8_label_gen_206_afterif
	; source: config.p8:42   uword file_size = end_address - config_load_address
	ldy  p8v_end_address+1
	lda  p8v_end_address
	sec
	sbc  #<$1000
	tax
	tya
	sbc  #>$1000
	tay
	txa
	sta  p8v_file_size
	sty  p8v_file_size+1
	; source: config.p8:43   txt.print("Loaded: ")
	ldy  #>prog8_interned_strings.string_21
	lda  #<prog8_interned_strings.string_21
	jsr  txt.print
	; source: config.p8:44   txt.print_uw(file_size)
	ldy  p8v_file_size+1
	lda  p8v_file_size
	jsr  txt.print_uw
	; source: config.p8:45   txt.print(" bytes")
	ldy  #>prog8_interned_strings.string_22
	lda  #<prog8_interned_strings.string_22
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: config.p8:49   configword = ""
	lda  #<prog8_interned_strings.string_23
	ldy  #>prog8_interned_strings.string_23
	sta  p8b_config.p8v_configword
	sty  p8b_config.p8v_configword+1
	; source: config.p8:50   configpos = 0
	lda  #0
	sta  p8b_config.p8v_configpos
	; source: config.p8:51   ubyte i = 0
	sta  p8v_i
	; source: config.p8:52   uword counter = 0
	sta  p8v_counter
	sta  p8v_counter+1
	; source: config.p8:59   while i != $25 {  ; $25 is '%' character
p8_label_gen_4_whileloop
	lda  p8v_i
	cmp  #37
	beq  p8_label_gen_5_afterwhile
	; source: config.p8:60   readchar = @(parse_start + counter)
	lda  p8b_config.p8s_load.p8v_counter
	sta  P8ZP_SCRATCH_W2
	lda  p8b_config.p8s_load.p8v_counter+1
	clc
	adc  #>4096
	sta  P8ZP_SCRATCH_W2+1
	ldy  #<4096
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8b_config.p8v_readchar
	; source: config.p8:62   if readchar == $3d {  ; '=' character
	cmp  #61
	bne  p8_label_gen_208_else
	; source: config.p8:63   configdirectives[configpos] = configword
	ldy  p8b_config.p8v_configpos
	lda  p8b_config.p8v_configword
	sta  p8b_config.p8v_configdirectives_lsb,y
	lda  p8b_config.p8v_configword+1
	sta  p8b_config.p8v_configdirectives_msb,y
	; source: config.p8:64   configword = ""
	lda  #<prog8_interned_strings.string_23
	ldy  #>prog8_interned_strings.string_23
	sta  p8b_config.p8v_configword
	sty  p8b_config.p8v_configword+1
	jmp  p8_label_gen_207_afterif
p8_label_gen_208_else
	; source: config.p8:66   else if readchar == $0d {  ; Carriage return
	lda  p8b_config.p8v_readchar
	cmp  #13
	bne  p8_label_gen_210_else
	; source: config.p8:67   configvalues[configpos] = configword
	ldy  p8b_config.p8v_configpos
	lda  p8b_config.p8v_configword
	sta  p8b_config.p8v_configvalues_lsb,y
	lda  p8b_config.p8v_configword+1
	sta  p8b_config.p8v_configvalues_msb,y
	; source: config.p8:68   configword = ""
	lda  #<prog8_interned_strings.string_23
	ldy  #>prog8_interned_strings.string_23
	sta  p8b_config.p8v_configword
	sty  p8b_config.p8v_configword+1
	; source: config.p8:69   configpos = configpos + 1
	inc  p8b_config.p8v_configpos
	jmp  p8_label_gen_209_afterif
p8_label_gen_210_else
	; source: config.p8:71   else if readchar != $0a {  ; Skip line feed, but process other chars
	lda  p8b_config.p8v_readchar
	cmp  #10
	beq  p8_label_gen_211_afterif
	; source: config.p8:74   char_buf[0] = readchar
	lda  p8b_config.p8v_readchar
	sta  p8v_char_buf+0
	; source: config.p8:75   char_buf[1] = 0
	lda  #0
	sta  p8v_char_buf+1
	; source: config.p8:76   configword = configword + &char_buf
	ldy  #>p8v_char_buf
	lda  #<p8v_char_buf
	clc
	adc  p8b_config.p8v_configword
	sta  p8b_config.p8v_configword
	tya
	adc  p8b_config.p8v_configword+1
	sta  p8b_config.p8v_configword+1
p8_label_gen_211_afterif
p8_label_gen_209_afterif
p8_label_gen_207_afterif
	; source: config.p8:79   i = readchar
	lda  p8b_config.p8v_readchar
	sta  p8v_i
	; source: config.p8:80   counter = counter + 1
	inc  p8v_counter
	bne  +
	inc  p8v_counter+1
+
	; source: config.p8:83   if counter > 16384 {
	ldy  #>$4000
	lda  #<$4000
	cmp  p8v_counter
	tya
	sbc  p8v_counter+1
	bcs  p8_label_gen_212_afterif
	; source: config.p8:84   txt.print("Error: Config file too large or malformed")
	ldy  #>prog8_interned_strings.string_24
	lda  #<prog8_interned_strings.string_24
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: config.p8:86   break
	jmp  p8_label_gen_3_after
p8_label_gen_212_afterif
	; source: config.p8:59   while i != $25 {  ; $25 is '%' character
	jmp  p8_label_gen_4_whileloop
p8_label_gen_5_afterwhile
	; source: config.p8:86   break
p8_label_gen_3_after
	; source: config.p8:90   txt.print("Config loaded: ")
	ldy  #>prog8_interned_strings.string_25
	lda  #<prog8_interned_strings.string_25
	jsr  txt.print
	; source: config.p8:91   txt.print_ub(configpos)
	lda  p8b_config.p8v_configpos
	jsr  txt.print_ub
	; source: config.p8:92   txt.print(" entries")
	ldy  #>prog8_interned_strings.string_26
	lda  #<prog8_interned_strings.string_26
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: config.p8:95   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_char_buf	.fill  2
p8v_counter	.word  ?
p8v_end_address	.word  ?
p8v_file_size	.word  ?
p8v_i	.byte  ?
	.send BSS
	.pend
	; source: config.p8:100   sub save() -> bool {

p8s_save	.proc
; statements
	; source: config.p8:143   ubyte cr = $0d
	; source: config.p8:134   uword val_len = strings.length(configvalues[i])
	; source: config.p8:127   ubyte eq = $3d
	; source: config.p8:118   uword dir_len = strings.length(configdirectives[i])
	; source: config.p8:115   ubyte i = 0
	; source: config.p8:152   ubyte term = $25
	; source: config.p8:101   txt.print("Saving config...")
	ldy  #>prog8_interned_strings.string_27
	lda  #<prog8_interned_strings.string_27
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: config.p8:105   diskio.drivenumber = configdrive
	lda  p8b_config.p8v_configdrive
	sta  diskio.drivenumber
	; source: config.p8:108   if not diskio.f_open_w(configfilename) {
	ldy  p8b_config.p8v_configfilename+1
	lda  p8b_config.p8v_configfilename
	jsr  diskio.f_open_w
	cmp  #0
	bne  p8_label_gen_213_afterif
	; source: config.p8:109   txt.print("Error: Could not open config file for writing")
	ldy  #>prog8_interned_strings.string_28
	lda  #<prog8_interned_strings.string_28
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: config.p8:111   return false
	lda  #0
	rts
p8_label_gen_213_afterif
	; source: config.p8:115   ubyte i = 0
	lda  #0
	sta  p8v_i
	; source: config.p8:116   while i < configpos {
p8_label_gen_6_whileloop
	lda  p8v_i
	cmp  p8b_config.p8v_configpos
	bcs  p8_label_gen_7_afterwhile
	; source: config.p8:118   uword dir_len = strings.length(configdirectives[i])
	ldy  p8v_i
	lda  p8b_config.p8v_configdirectives_lsb,y
	ldx  p8b_config.p8v_configdirectives_msb,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	jsr  strings.length
	tya
	sta  p8v_dir_len
	lda  #0
	sta  p8v_dir_len+1
	; source: config.p8:119   if dir_len > 0 {
	lda  p8v_dir_len
	ora  p8v_dir_len+1
	beq  p8_label_gen_214_afterif
	; source: config.p8:120   if not diskio.f_write(configdirectives[i], dir_len) {
	ldy  p8v_i
	lda  p8b_config.p8v_configdirectives_lsb,y
	ldx  p8b_config.p8v_configdirectives_msb,y
	sta  diskio.f_write.bufferpointer
	stx  diskio.f_write.bufferpointer+1
	lda  p8v_dir_len
	ldy  p8v_dir_len+1
	sta  diskio.f_write.num_bytes
	sty  diskio.f_write.num_bytes+1
	jsr  diskio.f_write
	cmp  #0
	bne  p8_label_gen_215_afterif
	; source: config.p8:121   diskio.f_close_w()
	jsr  diskio.f_close_w
	; source: config.p8:122   return false
	lda  #0
	rts
p8_label_gen_215_afterif
p8_label_gen_214_afterif
	; source: config.p8:127   ubyte eq = $3d
	lda  #$3d
	sta  p8v_eq
	; source: config.p8:128   if not diskio.f_write(&eq, 1) {
	lda  #<p8v_eq
	ldy  #>p8v_eq
	sta  diskio.f_write.bufferpointer
	sty  diskio.f_write.bufferpointer+1
	lda  #<1
	ldy  #>1
	sta  diskio.f_write.num_bytes
	sty  diskio.f_write.num_bytes+1
	jsr  diskio.f_write
	cmp  #0
	bne  p8_label_gen_216_afterif
	; source: config.p8:129   diskio.f_close_w()
	jsr  diskio.f_close_w
	; source: config.p8:130   return false
	lda  #0
	rts
p8_label_gen_216_afterif
	; source: config.p8:134   uword val_len = strings.length(configvalues[i])
	ldy  p8v_i
	lda  p8b_config.p8v_configvalues_lsb,y
	ldx  p8b_config.p8v_configvalues_msb,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	jsr  strings.length
	tya
	sta  p8v_val_len
	lda  #0
	sta  p8v_val_len+1
	; source: config.p8:135   if val_len > 0 {
	lda  p8v_val_len
	ora  p8v_val_len+1
	beq  p8_label_gen_217_afterif
	; source: config.p8:136   if not diskio.f_write(configvalues[i], val_len) {
	ldy  p8v_i
	lda  p8b_config.p8v_configvalues_lsb,y
	ldx  p8b_config.p8v_configvalues_msb,y
	sta  diskio.f_write.bufferpointer
	stx  diskio.f_write.bufferpointer+1
	lda  p8v_val_len
	ldy  p8v_val_len+1
	sta  diskio.f_write.num_bytes
	sty  diskio.f_write.num_bytes+1
	jsr  diskio.f_write
	cmp  #0
	bne  p8_label_gen_218_afterif
	; source: config.p8:137   diskio.f_close_w()
	jsr  diskio.f_close_w
	; source: config.p8:138   return false
	lda  #0
	rts
p8_label_gen_218_afterif
p8_label_gen_217_afterif
	; source: config.p8:143   ubyte cr = $0d
	lda  #13
	sta  p8v_cr
	; source: config.p8:144   if not diskio.f_write(&cr, 1) {
	lda  #<p8v_cr
	ldy  #>p8v_cr
	sta  diskio.f_write.bufferpointer
	sty  diskio.f_write.bufferpointer+1
	lda  #<1
	ldy  #>1
	sta  diskio.f_write.num_bytes
	sty  diskio.f_write.num_bytes+1
	jsr  diskio.f_write
	cmp  #0
	bne  p8_label_gen_219_afterif
	; source: config.p8:145   diskio.f_close_w()
	jsr  diskio.f_close_w
	; source: config.p8:146   return false
	lda  #0
	rts
p8_label_gen_219_afterif
	; source: config.p8:148   i++
	inc  p8v_i
	; source: config.p8:116   while i < configpos {
	jmp  p8_label_gen_6_whileloop
p8_label_gen_7_afterwhile
	; source: config.p8:152   ubyte term = $25
	lda  #$25
	sta  p8v_term
	; source: config.p8:153   if not diskio.f_write(&term, 1) {
	lda  #<p8v_term
	ldy  #>p8v_term
	sta  diskio.f_write.bufferpointer
	sty  diskio.f_write.bufferpointer+1
	lda  #<1
	ldy  #>1
	sta  diskio.f_write.num_bytes
	sty  diskio.f_write.num_bytes+1
	jsr  diskio.f_write
	cmp  #0
	bne  p8_label_gen_220_afterif
	; source: config.p8:154   diskio.f_close_w()
	jsr  diskio.f_close_w
	; source: config.p8:155   return false
	lda  #0
	rts
p8_label_gen_220_afterif
	; source: config.p8:159   diskio.f_close_w()
	jsr  diskio.f_close_w
	; source: config.p8:161   txt.print("Config saved successfully")
	ldy  #>prog8_interned_strings.string_29
	lda  #<prog8_interned_strings.string_29
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: config.p8:163   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_cr	.byte  ?
p8v_dir_len	.word  ?
p8v_eq	.byte  ?
p8v_i	.byte  ?
p8v_term	.byte  ?
p8v_val_len	.word  ?
	.send BSS
	.pend
	; source: config.p8:167   sub setdirective(uword directive, uword value) {

p8s_setdirective	.proc
; statements
	; source: config.p8:169   ubyte i = 0
	lda  #0
	sta  p8v_i
	; source: config.p8:170   while i < 64 {
p8_label_gen_8_whileloop
	lda  p8v_i
	cmp  #64
	bcs  p8_label_gen_9_afterwhile
	; source: config.p8:171   if configdirectives[i] == directive {
	ldy  p8v_i
	lda  p8b_config.p8v_configdirectives_lsb,y
	ldx  p8b_config.p8v_configdirectives_msb,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	cmp  p8b_config.p8s_setdirective.p8v_directive
	bne  p8_label_gen_221_afterif
	cpy  p8b_config.p8s_setdirective.p8v_directive+1
	bne  p8_label_gen_221_afterif
	; source: config.p8:172   configvalues[i] = value
	ldy  p8v_i
	lda  p8v_value
	sta  p8b_config.p8v_configvalues_lsb,y
	lda  p8v_value+1
	sta  p8b_config.p8v_configvalues_msb,y
	; source: config.p8:173   return
	rts
p8_label_gen_221_afterif
	; source: config.p8:175   i++
	inc  p8v_i
	; source: config.p8:170   while i < 64 {
	jmp  p8_label_gen_8_whileloop
p8_label_gen_9_afterwhile
	; source: config.p8:178   configdirectives[configpos] = directive
	ldy  p8b_config.p8v_configpos
	lda  p8v_directive
	sta  p8b_config.p8v_configdirectives_lsb,y
	lda  p8v_directive+1
	sta  p8b_config.p8v_configdirectives_msb,y
	; source: config.p8:179   configvalues[configpos] = value
	ldy  p8b_config.p8v_configpos
	lda  p8v_value
	sta  p8b_config.p8v_configvalues_lsb,y
	lda  p8v_value+1
	sta  p8b_config.p8v_configvalues_msb,y
	; source: config.p8:180   configpos = configpos + 1
	inc  p8b_config.p8v_configpos
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_directive	.word  ?
p8v_i	.byte  ?
p8v_value	.word  ?
	.send BSS
	.pend
	; source: config.p8:183   sub getdirective(uword directive) -> uword {

p8s_getdirective	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_directive
	sty  p8v_directive+1
; statements
	; source: config.p8:184   ubyte i = 0
	lda  #0
	sta  p8v_i
	; source: config.p8:185   while i < 64 {
p8_label_gen_10_whileloop
	lda  p8v_i
	cmp  #64
	bcs  p8_label_gen_11_afterwhile
	; source: config.p8:186   if configdirectives[i] == directive {
	ldy  p8v_i
	lda  p8b_config.p8v_configdirectives_lsb,y
	ldx  p8b_config.p8v_configdirectives_msb,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	cmp  p8b_config.p8s_getdirective.p8v_directive
	bne  p8_label_gen_222_afterif
	cpy  p8b_config.p8s_getdirective.p8v_directive+1
	bne  p8_label_gen_222_afterif
	; source: config.p8:187   return configvalues[i]
	ldy  p8v_i
	lda  p8b_config.p8v_configvalues_lsb,y
	ldx  p8b_config.p8v_configvalues_msb,y
	stx  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_REG
	rts
p8_label_gen_222_afterif
	; source: config.p8:189   i++
	inc  p8v_i
	; source: config.p8:185   while i < 64 {
	jmp  p8_label_gen_10_whileloop
p8_label_gen_11_afterwhile
	; source: config.p8:191   return ""
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_directive	.word  ?
p8v_i	.byte  ?
	.send BSS
	.pend
prog8_init_vars	.block
	; source: config.p8:7   ubyte configdrive = 8
	lda  #8
	sta  p8b_config.p8v_configdrive
	; source: config.p8:8   uword configfilename = "bbsconfig"
	lda  #<prog8_interned_strings.string_194
	ldy  #>prog8_interned_strings.string_194
	sta  p8b_config.p8v_configfilename
	sty  p8b_config.p8v_configfilename+1
	; source: config.p8:12   uword configword = ""
	lda  #<prog8_interned_strings.string_23
	ldy  #>prog8_interned_strings.string_23
	sta  p8b_config.p8v_configword
	sty  p8b_config.p8v_configword+1
	rts
	.bend
	.pend

; ---- block: 'diskio' ----
diskio	.proc
	; source: library:/prog8lib/c128/diskio.p8:3   diskio {
	READ_IO_CHANNEL = 12
	STATUS_EOF = $40
	WRITE_IO_CHANNEL = 13

; non-zeropage variables
	.section BSS
drivenumber	.byte  ?
iteration_in_progress	.byte  ?
list_blocks	.word  ?
list_pattern	.word  ?
list_skip_disk_name	.byte  ?
write_iteration_in_progress	.byte  ?
	.send BSS
; non-zeropage variables with init value
list_filename	; PETSCII:"??????????????????????????????????????????????????"
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $3f, $3f, $00
list_filetype	; PETSCII:"???"
	.byte  $3f, $3f, $3f, $00

	; source: library:/prog8lib/shared_cbm_diskio.p8:16   const ubyte READ_IO_CHANNEL=12
	; source: library:/prog8lib/shared_cbm_diskio.p8:17   const ubyte WRITE_IO_CHANNEL=13
	; source: library:/prog8lib/shared_cbm_diskio.p8:18   const ubyte STATUS_EOF=$40
	; source: library:/prog8lib/shared_cbm_diskio.p8:20   ubyte @shared drivenumber = 8           ; user programs can set this to the drive number they want to load/save to!
	; source: library:/prog8lib/shared_cbm_diskio.p8:147   bool list_skip_disk_name
	; source: library:/prog8lib/shared_cbm_diskio.p8:148   ^^ubyte list_pattern
	; source: library:/prog8lib/shared_cbm_diskio.p8:149   uword list_blocks
	; source: library:/prog8lib/shared_cbm_diskio.p8:150   bool iteration_in_progress = false
	; source: library:/prog8lib/shared_cbm_diskio.p8:151   bool write_iteration_in_progress = false
	; source: library:/prog8lib/shared_cbm_diskio.p8:152   str list_filetype = "???"       ; prg, seq, dir
	; source: library:/prog8lib/shared_cbm_diskio.p8:153   str list_filename = "?" * 50
	; source: library:/prog8lib/c128/diskio.p8:4   %option no_symbol_prefixing, ignore_unused
	; source: library:/prog8lib/shared_cbm_diskio.p8:22   sub reset_read_channel() {

reset_read_channel	.proc
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:23   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/shared_cbm_diskio.p8:24   void cbm.CHKIN(READ_IO_CHANNEL)
	ldx  #12
	jmp  cbm.CHKIN
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:27   sub reset_write_channel() {

reset_write_channel	.proc
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:28   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/shared_cbm_diskio.p8:29   cbm.CHKOUT(WRITE_IO_CHANNEL)
	ldx  #13
	jmp  cbm.CHKOUT
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:190   sub lf_start_list(str pattern_ptr) -> bool {

lf_start_list	.proc
; simple int arg(s) passed via cpu register(s)
	sta  pattern_ptr
	sty  pattern_ptr+1
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:193   cbm.SETNAM(1, "$")
	ldy  #>prog8_interned_strings.string_30
	ldx  #<prog8_interned_strings.string_30
	lda  #1
	jsr  cbm.SETNAM
	; source: library:/prog8lib/shared_cbm_diskio.p8:195   start_list_internal:
start_list_internal
	; source: library:/prog8lib/shared_cbm_diskio.p8:196   lf_end_list()
	jsr  diskio.lf_end_list
	; source: library:/prog8lib/shared_cbm_diskio.p8:197   list_pattern = pattern_ptr
	lda  pattern_ptr
	ldy  pattern_ptr+1
	sta  diskio.list_pattern
	sty  diskio.list_pattern+1
	; source: library:/prog8lib/shared_cbm_diskio.p8:198   list_skip_disk_name = true
	lda  #1
	sta  diskio.list_skip_disk_name
	; source: library:/prog8lib/shared_cbm_diskio.p8:199   iteration_in_progress = true
	sta  diskio.iteration_in_progress
	; source: library:/prog8lib/shared_cbm_diskio.p8:201   cbm.SETLFS(READ_IO_CHANNEL, drivenumber, 0)
	ldy  #0
	ldx  diskio.drivenumber
	lda  #12
	jsr  cbm.SETLFS
	; source: library:/prog8lib/shared_cbm_diskio.p8:202   void cbm.OPEN()          ; open 12,8,0,"$"
	jsr  cbm.OPEN
	; source: library:/prog8lib/shared_cbm_diskio.p8:203   if_cs
	bcs  io_error
	; source: library:/prog8lib/shared_cbm_diskio.p8:205   reset_read_channel()
	jsr  diskio.reset_read_channel
	; source: library:/prog8lib/shared_cbm_diskio.p8:207   repeat 4 {
	lda  #4
	sta  p8_label_gen_225_tempv
p8_label_gen_224_repeat
	; source: library:/prog8lib/shared_cbm_diskio.p8:208   void cbm.CHRIN()     ; skip the 4 prologue bytes
	jsr  cbm.CHRIN
	dec  p8_label_gen_225_tempv
	bne  p8_label_gen_224_repeat
	; source: library:/prog8lib/shared_cbm_diskio.p8:211   if cbm.READST()==0
	jsr  cbm.READST
	cmp  #0
	bne  p8_label_gen_226_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:212   return true
	lda  #1
	rts
p8_label_gen_226_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:214   io_error:
io_error
	; source: library:/prog8lib/shared_cbm_diskio.p8:215   cbm.CLOSE(READ_IO_CHANNEL)
	lda  #12
	jsr  cbm.CLOSE
	; source: library:/prog8lib/shared_cbm_diskio.p8:216   lf_end_list()
	jsr  diskio.lf_end_list
	; source: library:/prog8lib/shared_cbm_diskio.p8:217   return false
	lda  #0
	rts
; variables
	.section BSS_NOCLEAR
p8_label_gen_225_tempv    .byte  ?
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
pattern_ptr	.word  ?
	.send BSS
	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:238   sub lf_next_entry() -> bool {

lf_next_entry	.proc
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:251   ubyte blocks_msb = cbm.CHRIN()
	; source: library:/prog8lib/shared_cbm_diskio.p8:250   ubyte blocks_lsb = cbm.CHRIN()
	; source: library:/prog8lib/shared_cbm_diskio.p8:249   ^^ubyte nameptr = &list_filename
	; source: library:/prog8lib/shared_cbm_diskio.p8:266   ubyte character = cbm.CHRIN()
	; source: library:/prog8lib/shared_cbm_diskio.p8:243   if not iteration_in_progress
	lda  diskio.iteration_in_progress
	bne  p8_label_gen_227_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:244   return false
	lda  #0
	rts
p8_label_gen_227_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:246   repeat {
p8_label_gen_31_repeat
	; source: library:/prog8lib/shared_cbm_diskio.p8:247   reset_read_channel()        ; use the input io channel again
	jsr  diskio.reset_read_channel
	; source: library:/prog8lib/shared_cbm_diskio.p8:249   ^^ubyte nameptr = &list_filename
	lda  #<diskio.list_filename
	ldy  #>diskio.list_filename
	sta  nameptr
	sty  nameptr+1
	; source: library:/prog8lib/shared_cbm_diskio.p8:250   ubyte blocks_lsb = cbm.CHRIN()
	jsr  cbm.CHRIN
	sta  blocks_lsb
	; source: library:/prog8lib/shared_cbm_diskio.p8:251   ubyte blocks_msb = cbm.CHRIN()
	jsr  cbm.CHRIN
	sta  blocks_msb
	; source: library:/prog8lib/shared_cbm_diskio.p8:253   if cbm.READST()!=0
	jsr  cbm.READST
	cmp  #0
	bne  close_end
	; source: library:/prog8lib/shared_cbm_diskio.p8:256   list_blocks = mkword(blocks_msb, blocks_lsb)
	lda  blocks_lsb
	ldy  blocks_msb
	sta  diskio.list_blocks
	sty  diskio.list_blocks+1
	; source: library:/prog8lib/shared_cbm_diskio.p8:259   while cbm.CHRIN()!='\"'  {
p8_label_gen_24_whileloop
	jsr  cbm.CHRIN
	cmp  #34
	beq  p8_label_gen_25_afterwhile
	; source: library:/prog8lib/shared_cbm_diskio.p8:260   if cbm.READST()!=0
	jsr  cbm.READST
	cmp  #0
	bne  close_end
	; source: library:/prog8lib/shared_cbm_diskio.p8:259   while cbm.CHRIN()!='\"'  {
	jmp  p8_label_gen_24_whileloop
p8_label_gen_25_afterwhile
	; source: library:/prog8lib/shared_cbm_diskio.p8:265   repeat {
p8_label_gen_28_repeat
	; source: library:/prog8lib/shared_cbm_diskio.p8:266   ubyte character = cbm.CHRIN()
	jsr  cbm.CHRIN
	sta  character
	; source: library:/prog8lib/shared_cbm_diskio.p8:267   if character==0
	lda  character
	beq  p8_label_gen_26_after
	; source: library:/prog8lib/shared_cbm_diskio.p8:269   if character=='\"'
	lda  character
	cmp  #34
	beq  p8_label_gen_27_after
	; source: library:/prog8lib/shared_cbm_diskio.p8:271   @(nameptr) = character
	lda  character
	ldy  nameptr
	sty  P8ZP_SCRATCH_PTR
	ldy  nameptr+1
	sty  P8ZP_SCRATCH_PTR+1
	ldy  #0
	sta  (P8ZP_SCRATCH_PTR),y
	; source: library:/prog8lib/shared_cbm_diskio.p8:272   nameptr++
	inc  nameptr
	bne  +
	inc  nameptr+1
+
	; source: library:/prog8lib/shared_cbm_diskio.p8:265   repeat {
	jmp  p8_label_gen_28_repeat
	; source: library:/prog8lib/shared_cbm_diskio.p8:270   break
p8_label_gen_27_after
	; source: library:/prog8lib/shared_cbm_diskio.p8:268   break
p8_label_gen_26_after
	; source: library:/prog8lib/shared_cbm_diskio.p8:275   @(nameptr) = 0
	lda  #0
	ldy  nameptr
	sty  P8ZP_SCRATCH_PTR
	ldy  nameptr+1
	sty  P8ZP_SCRATCH_PTR+1
	ldy  #0
	sta  (P8ZP_SCRATCH_PTR),y
	; source: library:/prog8lib/shared_cbm_diskio.p8:277   do {
p8_label_gen_29_untilloop
	; source: library:/prog8lib/shared_cbm_diskio.p8:278   cx16.r15L = cbm.CHRIN()
	jsr  cbm.CHRIN
	sta  cx16.r15L
	; source: library:/prog8lib/shared_cbm_diskio.p8:277   do {
	cmp  #32
	beq  p8_label_gen_29_untilloop
	; source: library:/prog8lib/shared_cbm_diskio.p8:280   list_filetype[0] = cx16.r15L
	lda  cx16.r15L
	sta  diskio.list_filetype+0
	; source: library:/prog8lib/shared_cbm_diskio.p8:281   list_filetype[1] = cbm.CHRIN()
	jsr  cbm.CHRIN
	sta  diskio.list_filetype+1
	; source: library:/prog8lib/shared_cbm_diskio.p8:282   list_filetype[2] = cbm.CHRIN()
	jsr  cbm.CHRIN
	sta  diskio.list_filetype+2
	; source: library:/prog8lib/shared_cbm_diskio.p8:283   while cbm.CHRIN()!=0 {
p8_label_gen_30_untilloop
	jsr  cbm.CHRIN
	cmp  #0
	bne  p8_label_gen_30_untilloop
	; source: library:/prog8lib/shared_cbm_diskio.p8:287   void cbm.CHRIN()     ; skip 2 bytes
	jsr  cbm.CHRIN
	; source: library:/prog8lib/shared_cbm_diskio.p8:288   void cbm.CHRIN()
	jsr  cbm.CHRIN
	; source: library:/prog8lib/shared_cbm_diskio.p8:290   if not list_skip_disk_name {
	lda  diskio.list_skip_disk_name
	bne  p8_label_gen_228_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:291   if list_pattern==0
	lda  diskio.list_pattern
	ora  diskio.list_pattern+1
	bne  p8_label_gen_229_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:292   return true
	lda  #1
	rts
p8_label_gen_229_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:293   if strings.pattern_match(list_filename, list_pattern)
	lda  diskio.list_pattern
	sta  cx16.r0
	lda  diskio.list_pattern+1
	sta  cx16.r0+1
	ldy  #>diskio.list_filename
	lda  #<diskio.list_filename
	jsr  strings.pattern_match
	cmp  #0
	beq  p8_label_gen_230_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:294   return true
	lda  #1
	rts
p8_label_gen_230_afterif
p8_label_gen_228_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:296   list_skip_disk_name = false
	lda  #0
	sta  diskio.list_skip_disk_name
	; source: library:/prog8lib/shared_cbm_diskio.p8:246   repeat {
	jmp  p8_label_gen_31_repeat
	; source: library:/prog8lib/shared_cbm_diskio.p8:299   close_end:
close_end
	; source: library:/prog8lib/shared_cbm_diskio.p8:300   lf_end_list()
	jsr  diskio.lf_end_list
	; source: library:/prog8lib/shared_cbm_diskio.p8:301   return false
	lda  #0
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
blocks_lsb	.byte  ?
blocks_msb	.byte  ?
character	.byte  ?
nameptr	.word  ?
	.send BSS
	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:304   sub lf_end_list() {

lf_end_list	.proc
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:306   if iteration_in_progress {
	lda  diskio.iteration_in_progress
	beq  p8_label_gen_231_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:307   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/shared_cbm_diskio.p8:308   cbm.CLOSE(READ_IO_CHANNEL)
	lda  #12
	jsr  cbm.CLOSE
	; source: library:/prog8lib/shared_cbm_diskio.p8:309   iteration_in_progress = false
	lda  #0
	sta  diskio.iteration_in_progress
p8_label_gen_231_afterif
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:316   sub f_open(str filenameptr) -> bool {

f_open	.proc
; simple int arg(s) passed via cpu register(s)
	sta  filenameptr
	sty  filenameptr+1
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:323   f_close()
	jsr  diskio.f_close
	; source: library:/prog8lib/shared_cbm_diskio.p8:325   cbm.SETNAM(strings.length(filenameptr), filenameptr)
	ldy  filenameptr+1
	ldx  filenameptr
	txa
	pha
	tya
	pha
	ldy  filenameptr+1
	lda  filenameptr
	jsr  strings.length
	tya
	sta  P8ZP_SCRATCH_REG
	pla
	tay
	lda  P8ZP_SCRATCH_REG
	pla
	tax
	lda  P8ZP_SCRATCH_REG
	jsr  cbm.SETNAM
	; source: library:/prog8lib/shared_cbm_diskio.p8:326   cbm.SETLFS(READ_IO_CHANNEL, drivenumber, READ_IO_CHANNEL)     ; note: has to be Channel,x,Channel because otherwise f_seek doesn't work
	ldy  #12
	ldx  diskio.drivenumber
	lda  #12
	jsr  cbm.SETLFS
	; source: library:/prog8lib/shared_cbm_diskio.p8:327   void cbm.OPEN()          ; open 12,8,12,"filename"
	jsr  cbm.OPEN
	; source: library:/prog8lib/shared_cbm_diskio.p8:328   if_cc {
	bcs  p8_label_gen_232_branch_else
	; source: library:/prog8lib/shared_cbm_diskio.p8:329   reset_read_channel()
	jsr  diskio.reset_read_channel
	; source: library:/prog8lib/shared_cbm_diskio.p8:330   if cbm.READST()==0 {
	jsr  cbm.READST
	cmp  #0
	bne  p8_label_gen_233_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:331   iteration_in_progress = true
	lda  #1
	sta  diskio.iteration_in_progress
	; source: library:/prog8lib/shared_cbm_diskio.p8:332   void cbm.CHRIN()        ; read first byte to test for file not found
	jsr  cbm.CHRIN
	; source: library:/prog8lib/shared_cbm_diskio.p8:333   if cbm.READST() & ~STATUS_EOF == 0 {
	jsr  cbm.READST
	and  #$bf
	bne  p8_label_gen_234_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:334   cbm.CLOSE(READ_IO_CHANNEL)           ; close file because we already consumed first byte
	lda  #12
	jsr  cbm.CLOSE
	; source: library:/prog8lib/shared_cbm_diskio.p8:335   void cbm.OPEN()         ; re-open the file
	jsr  cbm.OPEN
	; source: library:/prog8lib/shared_cbm_diskio.p8:336   cbm.CLRCHN()            ; reset default i/o channels
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/shared_cbm_diskio.p8:337   return true
	lda  #1
	rts
p8_label_gen_234_afterif
p8_label_gen_233_afterif
p8_label_gen_232_branch_else
	; source: library:/prog8lib/shared_cbm_diskio.p8:341   f_close()
	jsr  diskio.f_close
	; source: library:/prog8lib/shared_cbm_diskio.p8:342   cbm.CLOSE(READ_IO_CHANNEL)
	lda  #12
	jsr  cbm.CLOSE
	; source: library:/prog8lib/shared_cbm_diskio.p8:343   return false
	lda  #0
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
filenameptr	.word  ?
	.send BSS
	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:346   sub f_read(uword bufferpointer, uword num_bytes) -> uword {

f_read	.proc
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:349   if not iteration_in_progress or num_bytes==0
	lda  diskio.iteration_in_progress
	beq  p8_label_gen_235_shortcut
	lda  num_bytes
	ora  num_bytes+1
p8_label_gen_235_shortcut
	bne  p8_label_gen_236_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:350   return 0
	ldy  #>0
	lda  #<0
	rts
p8_label_gen_236_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:352   reset_read_channel()
	jsr  diskio.reset_read_channel
	; source: library:/prog8lib/shared_cbm_diskio.p8:353   if num_bytes==1 {
	lda  diskio.f_read.num_bytes
	cmp  #<1
	bne  p8_label_gen_237_afterif
	lda  diskio.f_read.num_bytes+1
	cmp  #>1
	bne  p8_label_gen_237_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:355   @(bufferpointer) = cbm.CHRIN()
	jsr  cbm.CHRIN
	ldy  bufferpointer
	sty  P8ZP_SCRATCH_PTR
	ldy  bufferpointer+1
	sty  P8ZP_SCRATCH_PTR+1
	ldy  #0
	sta  (P8ZP_SCRATCH_PTR),y
	; source: library:/prog8lib/shared_cbm_diskio.p8:356   cx16.r0L = cbm.READST()
	jsr  cbm.READST
	sta  cx16.r0L
	; source: library:/prog8lib/shared_cbm_diskio.p8:357   cbm.CLRCHN()            ; reset default i/o channels
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/shared_cbm_diskio.p8:358   if cx16.r0L!=0 {
	lda  cx16.r0L
	beq  p8_label_gen_238_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:359   f_close()
	jsr  diskio.f_close
	; source: library:/prog8lib/shared_cbm_diskio.p8:360   if cx16.r0L & STATUS_EOF == 0
	bit  cx16.r0L
	bvs  p8_label_gen_239_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:361   return 0
	ldy  #>0
	lda  #<0
	rts
p8_label_gen_239_afterif
p8_label_gen_238_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:363   return 1
	ldy  #>1
	lda  #<1
	rts
p8_label_gen_237_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:366   list_blocks = 0     ; we reuse this variable for the total number of bytes read
	lda  #0
	sta  diskio.list_blocks
	sta  diskio.list_blocks+1
	; source: library:/prog8lib/shared_cbm_diskio.p8:367   %asm {{
            lda  bufferpointer
            sta  P8ZP_SCRATCH_W1
            lda  bufferpointer+1
            sta  P8ZP_SCRATCH_W1+1
	; source: library:/prog8lib/shared_cbm_diskio.p8:373   while num_bytes!=0 {
p8_label_gen_32_whileloop
	lda  num_bytes
	ora  num_bytes+1
	beq  p8_label_gen_33_afterwhile
	; source: library:/prog8lib/shared_cbm_diskio.p8:374   %asm {{
                jsr  cbm.CHRIN
                ldy  #0
                sta  (P8ZP_SCRATCH_W1),y
                inc  P8ZP_SCRATCH_W1
                bne  +
                inc  P8ZP_SCRATCH_W1+1
+
	; source: library:/prog8lib/shared_cbm_diskio.p8:383   list_blocks++
	inc  diskio.list_blocks
	bne  +
	inc  diskio.list_blocks+1
+
	; source: library:/prog8lib/shared_cbm_diskio.p8:384   cx16.r0L = cbm.READST()
	jsr  cbm.READST
	sta  cx16.r0L
	; source: library:/prog8lib/shared_cbm_diskio.p8:385   if_nz {
	beq  p8_label_gen_240_branch_else
	; source: library:/prog8lib/shared_cbm_diskio.p8:386   f_close()
	jsr  diskio.f_close
	; source: library:/prog8lib/shared_cbm_diskio.p8:387   cbm.CLRCHN()            ;  reset default i/o channels
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/shared_cbm_diskio.p8:388   if cx16.r0L & STATUS_EOF !=0    ; eof?
	bit  cx16.r0L
	bvc  p8_label_gen_241_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:389   return list_blocks   ; number of bytes read
	ldy  diskio.list_blocks+1
	lda  diskio.list_blocks
	rts
p8_label_gen_241_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:390   return 0  ; error.
	ldy  #>0
	lda  #<0
	rts
p8_label_gen_240_branch_else
	; source: library:/prog8lib/shared_cbm_diskio.p8:392   num_bytes--
	lda  num_bytes
	bne  +
	dec  num_bytes+1
+                           dec  num_bytes
	; source: library:/prog8lib/shared_cbm_diskio.p8:373   while num_bytes!=0 {
	jmp  p8_label_gen_32_whileloop
p8_label_gen_33_afterwhile
	; source: library:/prog8lib/shared_cbm_diskio.p8:394   cbm.CLRCHN()            ; reset default i/o channels
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/shared_cbm_diskio.p8:395   return list_blocks  ; number of bytes read
	ldy  diskio.list_blocks+1
	lda  diskio.list_blocks
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
bufferpointer	.word  ?
num_bytes	.word  ?
	.send BSS
	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:418   asmsub f_readline(^^ubyte bufptr @AY) clobbers(X) -> ubyte @Y, ubyte @A {

f_readline	.proc
	; source: library:/prog8lib/shared_cbm_diskio.p8:425   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            jsr  reset_read_channel
            ldy  #0
_loop       jsr  cbm.CHRIN
            sta  (P8ZP_SCRATCH_W1),y
            beq  _end
            iny
            cmp  #$0a
            beq  _line_end
            cmp  #$0d
            bne  _loop
_line_end   dey     ; get rid of the trailing end-of-line char
            lda  #0
            sta  (P8ZP_SCRATCH_W1),y
_end        jsr  cbm.READST
            pha
            tya
            pha
            jsr  cbm.CLRCHN
            pla
            tay
            pla
            rts
	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:453   sub f_close() {

f_close	.proc
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:456   if iteration_in_progress {
	lda  diskio.iteration_in_progress
	beq  p8_label_gen_242_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:457   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/shared_cbm_diskio.p8:458   cbm.CLOSE(READ_IO_CHANNEL)
	lda  #12
	jsr  cbm.CLOSE
	; source: library:/prog8lib/shared_cbm_diskio.p8:459   iteration_in_progress = false
	lda  #0
	sta  diskio.iteration_in_progress
p8_label_gen_242_afterif
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:466   sub f_open_w(str filenameptr) -> bool {

f_open_w	.proc
; simple int arg(s) passed via cpu register(s)
	sta  filenameptr
	sty  filenameptr+1
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:475   f_close_w()
	jsr  diskio.f_close_w
	; source: library:/prog8lib/shared_cbm_diskio.p8:477   cbm.SETNAM(strings.length(filenameptr), filenameptr)
	ldy  filenameptr+1
	ldx  filenameptr
	txa
	pha
	tya
	pha
	ldy  filenameptr+1
	lda  filenameptr
	jsr  strings.length
	tya
	sta  P8ZP_SCRATCH_REG
	pla
	tay
	lda  P8ZP_SCRATCH_REG
	pla
	tax
	lda  P8ZP_SCRATCH_REG
	jsr  cbm.SETNAM
	; source: library:/prog8lib/shared_cbm_diskio.p8:478   cbm.SETLFS(WRITE_IO_CHANNEL, drivenumber, 1)
	ldy  #1
	ldx  diskio.drivenumber
	lda  #13
	jsr  cbm.SETLFS
	; source: library:/prog8lib/shared_cbm_diskio.p8:479   void cbm.OPEN()             ; open 13,8,1,"filename"
	jsr  cbm.OPEN
	; source: library:/prog8lib/shared_cbm_diskio.p8:480   if_cc {
	bcs  p8_label_gen_243_branch_else
	; source: library:/prog8lib/shared_cbm_diskio.p8:481   if cbm.READST()==0 {
	jsr  cbm.READST
	cmp  #0
	bne  p8_label_gen_244_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:482   write_iteration_in_progress = true
	lda  #1
	sta  diskio.write_iteration_in_progress
	; source: library:/prog8lib/shared_cbm_diskio.p8:483   cbm.CLRCHN()            ; reset default i/o channels
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/shared_cbm_diskio.p8:484   return true
	lda  #1
	rts
p8_label_gen_244_afterif
p8_label_gen_243_branch_else
	; source: library:/prog8lib/shared_cbm_diskio.p8:487   cbm.CLOSE(WRITE_IO_CHANNEL)
	lda  #13
	jsr  cbm.CLOSE
	; source: library:/prog8lib/shared_cbm_diskio.p8:488   f_close_w()
	jsr  diskio.f_close_w
	; source: library:/prog8lib/shared_cbm_diskio.p8:489   return false
	lda  #0
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
filenameptr	.word  ?
	.send BSS
	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:492   sub f_write(uword bufferpointer, uword num_bytes) -> bool {

f_write	.proc
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:495   if num_bytes!=0 {
	lda  num_bytes
	ora  num_bytes+1
	beq  p8_label_gen_245_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:496   reset_write_channel()
	jsr  diskio.reset_write_channel
	; source: library:/prog8lib/shared_cbm_diskio.p8:497   repeat num_bytes {
	ldy  num_bytes+1
	lda  num_bytes
	beq  +
	iny
+           sta  p8_label_gen_248_tempv
	sty  p8_label_gen_248_tempv+1
	ora  p8_label_gen_248_tempv+1
	beq  p8_label_gen_246_repeatend
p8_label_gen_247_repeat
	; source: library:/prog8lib/shared_cbm_diskio.p8:498   cbm.CHROUT(@(bufferpointer))
	lda  bufferpointer
	ldy  bufferpointer+1
	sta  P8ZP_SCRATCH_PTR
	sty  P8ZP_SCRATCH_PTR+1
	ldy  #0
	lda  (P8ZP_SCRATCH_PTR),y
	jsr  cbm.CHROUT
	; source: library:/prog8lib/shared_cbm_diskio.p8:499   bufferpointer++
	inc  bufferpointer
	bne  +
	inc  bufferpointer+1
+
	dec  p8_label_gen_248_tempv
	bne  p8_label_gen_247_repeat
	dec  p8_label_gen_248_tempv+1
	bne  p8_label_gen_247_repeat
p8_label_gen_246_repeatend
	; source: library:/prog8lib/shared_cbm_diskio.p8:501   cx16.r0L = cbm.READST()
	jsr  cbm.READST
	sta  cx16.r0L
	; source: library:/prog8lib/shared_cbm_diskio.p8:502   cbm.CLRCHN()            ; reset default i/o channels
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/shared_cbm_diskio.p8:503   return cx16.r0L==0
	lda  cx16.r0L
	beq  +
	lda  #1
+                           eor  #1
	rts
p8_label_gen_245_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:505   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
p8_label_gen_248_tempv    .word  ?
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
bufferpointer	.word  ?
num_bytes	.word  ?
	.send BSS
	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:508   sub f_close_w() {

f_close_w	.proc
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:511   if write_iteration_in_progress {
	lda  diskio.write_iteration_in_progress
	beq  p8_label_gen_249_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:512   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: library:/prog8lib/shared_cbm_diskio.p8:513   cbm.CLOSE(WRITE_IO_CHANNEL)
	lda  #13
	jsr  cbm.CLOSE
	; source: library:/prog8lib/shared_cbm_diskio.p8:514   write_iteration_in_progress = false
	lda  #0
	sta  diskio.write_iteration_in_progress
p8_label_gen_249_afterif
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:622   sub load(str filenameptr, uword address_override) -> uword {

load	.proc
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:624   ubyte secondary = 1
	; source: library:/prog8lib/shared_cbm_diskio.p8:623   cbm.SETNAM(strings.length(filenameptr), filenameptr)
	ldy  filenameptr+1
	ldx  filenameptr
	txa
	pha
	tya
	pha
	ldy  filenameptr+1
	lda  filenameptr
	jsr  strings.length
	tya
	sta  P8ZP_SCRATCH_REG
	pla
	tay
	lda  P8ZP_SCRATCH_REG
	pla
	tax
	lda  P8ZP_SCRATCH_REG
	jsr  cbm.SETNAM
	; source: library:/prog8lib/shared_cbm_diskio.p8:624   ubyte secondary = 1
	lda  #1
	sta  secondary
	; source: library:/prog8lib/shared_cbm_diskio.p8:625   cx16.r1 = 0
	lda  #0
	sta  cx16.r1
	sta  cx16.r1+1
	; source: library:/prog8lib/shared_cbm_diskio.p8:626   if address_override!=0
	lda  address_override
	ora  address_override+1
	beq  p8_label_gen_250_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:627   secondary = 0
	lda  #0
	sta  secondary
p8_label_gen_250_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:628   cbm.SETLFS(1, drivenumber, secondary)
	ldy  secondary
	ldx  diskio.drivenumber
	lda  #1
	jsr  cbm.SETLFS
	; source: library:/prog8lib/shared_cbm_diskio.p8:629   %asm {{
            lda  #0
            ldx  address_override
            ldy  address_override+1
            jsr  cbm.LOAD
            bcs  +
            stx  cx16.r1
            sty  cx16.r1+1
+
	; source: library:/prog8lib/shared_cbm_diskio.p8:640   return cx16.r1
	lda  cx16.r1
	ldy  cx16.r1+1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
address_override	.word  ?
filenameptr	.word  ?
secondary	.byte  ?
	.send BSS
	.pend
	; source: library:/prog8lib/shared_cbm_diskio.p8:690   sub exists(str filename) -> bool {

exists	.proc
; simple int arg(s) passed via cpu register(s)
	sta  filename
	sty  filename+1
; statements
	; source: library:/prog8lib/shared_cbm_diskio.p8:694   if f_open(filename) {
	jsr  diskio.f_open
	cmp  #0
	beq  p8_label_gen_251_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:695   f_close()
	jsr  diskio.f_close
	; source: library:/prog8lib/shared_cbm_diskio.p8:696   return true
	lda  #1
	rts
p8_label_gen_251_afterif
	; source: library:/prog8lib/shared_cbm_diskio.p8:698   return false
	lda  #0
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
filename	.word  ?
	.send BSS
	.pend
prog8_init_vars	.block
	; source: library:/prog8lib/shared_cbm_diskio.p8:20   ubyte @shared drivenumber = 8           ; user programs can set this to the drive number they want to load/save to!
	lda  #8
	sta  diskio.drivenumber
	; source: library:/prog8lib/shared_cbm_diskio.p8:147   bool list_skip_disk_name
	lda  #0
	sta  diskio.list_skip_disk_name
	; source: library:/prog8lib/shared_cbm_diskio.p8:150   bool iteration_in_progress = false
	sta  diskio.iteration_in_progress
	; source: library:/prog8lib/shared_cbm_diskio.p8:151   bool write_iteration_in_progress = false
	sta  diskio.write_iteration_in_progress
	rts
	.bend
	.pend

; ---- block: 'strings' ----
strings	.proc
	; source: library:/prog8lib/strings.p8:5   strings {


	; source: library:/prog8lib/strings.p8:6   %option no_symbol_prefixing, ignore_unused
	; source: library:/prog8lib/strings.p8:8   asmsub length(str string @AY) clobbers(A) -> ubyte @Y {

length	.proc
	; source: library:/prog8lib/strings.p8:14   %asm {{
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  +
		iny
		bne  -
+		rts
	.pend
	; source: library:/prog8lib/strings.p8:26   asmsub left(str source @AX, ubyte length @Y, str target @R1) clobbers(A, Y) {

left	.proc
	; source: library:/prog8lib/strings.p8:31   %asm {{
		; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		sta  P8ZP_SCRATCH_W1
		stx  P8ZP_SCRATCH_W1+1
		lda  cx16.r1
		sta  P8ZP_SCRATCH_W2
		lda  cx16.r1+1
		sta  P8ZP_SCRATCH_W2+1
		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
		rts
_loop		dey
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
+		rts
	.pend
	; source: library:/prog8lib/strings.p8:53   asmsub right(str source @AY, ubyte length @X, str target @R1) clobbers(A,Y) {

right	.proc
	; source: library:/prog8lib/strings.p8:58   %asm {{
		; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		stx  P8ZP_SCRATCH_B1
		sta  cx16.r0
		sty  cx16.r0+1
		jsr  length
		tya
		sec
		sbc  P8ZP_SCRATCH_B1
		clc
		adc  cx16.r0
		sta  P8ZP_SCRATCH_W1
		lda  cx16.r0+1
		adc  #0
		sta  P8ZP_SCRATCH_W1+1
		ldy  cx16.r1
		sty  P8ZP_SCRATCH_W2
		ldy  cx16.r1+1
		sty  P8ZP_SCRATCH_W2+1
		ldy  P8ZP_SCRATCH_B1
		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
		rts
_loop		dey
		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		cpy  #0
		bne  _loop
+		rts
	.pend
	; source: library:/prog8lib/strings.p8:92   asmsub slice(str source @R0, ubyte start @A, ubyte length @Y, str target @R1) clobbers(A, Y) {

slice	.proc
	; source: library:/prog8lib/strings.p8:98   %asm {{
		; need to copy the the cx16 virtual registers to zeropage to be compatible with C64...
		; substr(source, target, start, length)
		sta  P8ZP_SCRATCH_B1
		lda  cx16.r0
		sta  P8ZP_SCRATCH_W1
		lda  cx16.r0+1
		sta  P8ZP_SCRATCH_W1+1
		lda  cx16.r1
		sta  P8ZP_SCRATCH_W2
		lda  cx16.r1+1
		sta  P8ZP_SCRATCH_W2+1

		; adjust src location
		clc
		lda  P8ZP_SCRATCH_W1
		adc  P8ZP_SCRATCH_B1
		sta  P8ZP_SCRATCH_W1
		bcc  +
		inc  P8ZP_SCRATCH_W1+1
+		lda  #0
		sta  (P8ZP_SCRATCH_W2),y
		beq  _startloop
-		lda  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
_startloop	dey
		cpy  #$ff
		bne  -
		rts
	.pend
	; source: library:/prog8lib/strings.p8:130   asmsub find(str string @AY, ubyte character @X) -> ubyte @A, bool @Pc {

find	.proc
	; source: library:/prog8lib/strings.p8:133   %asm {{
		; need to copy the the cx16 virtual registers to zeropage to make this run on C64...
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		stx  P8ZP_SCRATCH_B1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  _notfound
		cmp  P8ZP_SCRATCH_B1
		beq  _found
		iny
		bne  -
_notfound	lda  #255
        clc
		rts
_found	tya
        sec
        rts
	.pend
	; source: library:/prog8lib/strings.p8:155   asmsub find_eol(str string @AY) -> ubyte @A, bool @Pc {

find_eol	.proc
	; source: library:/prog8lib/strings.p8:159   %asm {{
		; need to copy the the cx16 virtual registers to zeropage to make this run on C64...
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  _notfound
		cmp  #13
		beq  _found
		cmp  #10
		beq  _found
		iny
		bne  -
_notfound	lda  #255
        clc
		rts
_found	tya
        sec
        rts
	.pend
	; source: library:/prog8lib/strings.p8:181   asmsub rfind(str string @AY, ubyte character @X) -> ubyte @A, bool @Pc {

rfind	.proc
	; source: library:/prog8lib/strings.p8:184   %asm {{
            stx  P8ZP_SCRATCH_B1
            ; note: we make use of the fact that length() stores the string address AY in P8ZP_SCRATCH_W1 for us! we need that later
            jsr  length
            cpy  #0
            beq  _notfound
            dey
-           lda  (P8ZP_SCRATCH_W1),y
            cmp  P8ZP_SCRATCH_B1
            beq  _found
            dey
            cpy  #255
            bne  -
_notfound   lda  #255
            clc
            rts
_found      tya
            sec
            rts
	.pend
	; source: library:/prog8lib/strings.p8:206   asmsub contains(str string @AY, ubyte character @X) -> bool @Pc {

contains	.proc
	; source: library:/prog8lib/strings.p8:208   %asm {{
            jmp  find
	.pend
	; source: library:/prog8lib/strings.p8:213   asmsub copy(str source @R0, str target @AY) clobbers(A) -> ubyte @Y {

copy	.proc
	; source: library:/prog8lib/strings.p8:216   %asm {{
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend
	; source: library:/prog8lib/strings.p8:225   asmsub ncopy(str source @R0, str target @AY, ubyte maxlength @X) clobbers(A, X) -> ubyte @Y {

ncopy	.proc
	; source: library:/prog8lib/strings.p8:228   %asm {{
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strncpy
	.pend
	; source: library:/prog8lib/strings.p8:237   asmsub append(str target @R0, str suffix @R1) clobbers(Y) -> ubyte @A {

append	.proc
	; source: library:/prog8lib/strings.p8:240   %asm {{
            lda  cx16.r0
            ldy  cx16.r0+1
            jsr  length
            sty  P8ZP_SCRATCH_B1
            tya
            clc
            adc  cx16.r0
            sta  P8ZP_SCRATCH_W1
            lda  cx16.r0+1
            adc  #0
            sta  P8ZP_SCRATCH_W1+1
            lda  cx16.r1
            ldy  cx16.r1+1
            jsr  prog8_lib.strcpy
            tya
            clc
            adc  P8ZP_SCRATCH_B1
            rts
	.pend
	; source: library:/prog8lib/strings.p8:262   asmsub nappend(str target @R0, str suffix @R1, ubyte maxlength @X) clobbers(Y) -> ubyte @A {

nappend	.proc
	; source: library:/prog8lib/strings.p8:265   %asm {{
            lda  cx16.r0
            ldy  cx16.r0+1
            jsr  length
            sty  P8ZP_SCRATCH_B1
            cpx  P8ZP_SCRATCH_B1
            beq  _max_too_small
            bmi  _max_too_small
            txa
            sec
            sbc  P8ZP_SCRATCH_B1
            sta  P8ZP_SCRATCH_B1
            tya
            clc
            adc  cx16.r0
            sta  P8ZP_SCRATCH_W1
            lda  cx16.r0+1
            adc  #0
            sta  P8ZP_SCRATCH_W1+1
            lda  cx16.r1
            ldy  cx16.r1+1
            ldx  P8ZP_SCRATCH_B1
            jsr  prog8_lib.strncpy
            tya
            clc
            adc  P8ZP_SCRATCH_B1
            rts
_max_too_small
            rts
	.pend
	; source: library:/prog8lib/strings.p8:297   asmsub compare(str string1 @R0, str string2 @AY) clobbers(Y) -> byte @A {

compare	.proc
	; source: library:/prog8lib/strings.p8:302   %asm {{
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcmp_mem
	.pend
	; source: library:/prog8lib/strings.p8:311   asmsub ncompare(str string1 @R0, str string2 @AY, ubyte length @X) clobbers(X, Y) -> byte @A {

ncompare	.proc
	; source: library:/prog8lib/strings.p8:315   %asm {{
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strncmp_mem
	.pend
	; source: library:/prog8lib/strings.p8:324   asmsub lower(str st @AY) -> ubyte @Y {

lower	.proc
	; source: library:/prog8lib/strings.p8:328   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  _done
            and  #$7f
            cmp  #97
            bcc  +
            cmp  #123
            bcs  +
            and  #%11011111
+           sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
_done       rts
	.pend
	; source: library:/prog8lib/strings.p8:347   asmsub upper(str st @AY) -> ubyte @Y {

upper	.proc
	; source: library:/prog8lib/strings.p8:349   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            ldy  #0
-           lda  (P8ZP_SCRATCH_W1),y
            beq  _done
            cmp  #65
            bcc  +
            cmp  #91
            bcs  +
            ora  #%00100000
+           sta  (P8ZP_SCRATCH_W1),y
            iny
            bne  -
_done       rts
	.pend
	; source: library:/prog8lib/strings.p8:367   asmsub lowerchar(ubyte character @A) -> ubyte @A {

lowerchar	.proc
	; source: library:/prog8lib/strings.p8:368   %asm {{
            and  #$7f
            cmp  #97
            bcc  +
            cmp  #123
            bcs  +
            and  #%11011111
+           rts
	.pend
	; source: library:/prog8lib/strings.p8:379   asmsub upperchar(ubyte character @A) -> ubyte @A {

upperchar	.proc
	; source: library:/prog8lib/strings.p8:380   %asm {{
            cmp  #65
            bcc  +
            cmp  #91
            bcs  +
            ora  #%00100000
+           rts
	.pend
	; source: library:/prog8lib/strings.p8:390   asmsub pattern_match(str string @AY, str pattern @R0) clobbers(Y) -> bool @A {

pattern_match	.proc
	; source: library:/prog8lib/strings.p8:407   %asm {{
strptr = P8ZP_SCRATCH_W1

	sta  strptr
	sty  strptr+1
	lda  cx16.r0
	sta  modify_pattern1+1
	sta  modify_pattern2+1
	lda  cx16.r0+1
	sta  modify_pattern1+2
	sta  modify_pattern2+2
	jsr  _match
	lda  #0
	rol  a
	rts


_match
	ldx #$00        ; x is an index in the pattern
	ldy #$ff        ; y is an index in the string
modify_pattern1
next    lda $ffff,x   ; look at next pattern character    MODIFIED
	cmp #'*'     ; is it a star?
	beq star        ; yes, do the complicated stuff
	iny             ; no, let's look at the string
	cmp #'?'     ; is the pattern caracter a ques?
	bne reg         ; no, it's a regular character
	lda (strptr),y     ; yes, so it will match anything
	beq fail        ;  except the end of string
reg     cmp (strptr),y     ; are both characters the same?
	bne fail        ; no, so no match
	inx             ; yes, keep checking
	cmp #0          ; are we at end of string?
	bne next        ; not yet, loop
found   rts             ; success, return with c=1

star    inx             ; skip star in pattern
modify_pattern2
	cmp $ffff,x   	; string of stars equals one star	MODIFIED
	beq star        ;  so skip them also
stloop  txa             ; we first try to match with * = ""
	pha             ;  and grow it by 1 character every
	tya             ;  time we loop
	pha             ; save x and y on stack
	jsr next        ; recursive call
	pla             ; restore x and y
	tay
	pla
	tax
	bcs found       ; we found a match, return with c=1
	iny             ; no match yet, try to grow * string
	lda (strptr),y     ; are we at the end of string?
	bne stloop      ; not yet, add a character
fail    clc             ; yes, no match found, return with c=0
	rts
	.pend
	; source: library:/prog8lib/strings.p8:466   asmsub hash(str string @AY) -> ubyte @A {

hash	.proc
	; source: library:/prog8lib/strings.p8:470   %asm {{
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1
            lda  #179
            sta  P8ZP_SCRATCH_REG
            ldy  #0
            clc
-           lda  (P8ZP_SCRATCH_W1),y
            beq  +
            rol  P8ZP_SCRATCH_REG
            eor  P8ZP_SCRATCH_REG
            sta  P8ZP_SCRATCH_REG
            iny
            bne  -
+           lda  P8ZP_SCRATCH_REG
            rts
	.pend
	; source: library:/prog8lib/strings.p8:489   asmsub isdigit(ubyte petsciichar @A) -> bool @Pc {

isdigit	.proc
	; source: library:/prog8lib/strings.p8:490   %asm {{
            cmp  #'0'
            bcs  +
            rts
+           cmp  #'9'+1
            bcc  +
            clc
            rts
+           sec
            rts
	.pend
	; source: library:/prog8lib/strings.p8:503   asmsub isupper(ubyte petsciichar @A) -> bool @Pc {

isupper	.proc
	; source: library:/prog8lib/strings.p8:505   %asm {{
            cmp  #97
            bcs  +
            rts
+           cmp  #122+1
            bcc  _yes
            cmp  #193
            bcs  +
            rts
+           cmp  #218+1
            bcc  _yes
            clc
            rts
_yes        sec
            rts
	.pend
	; source: library:/prog8lib/strings.p8:523   asmsub islower(ubyte petsciichar @A) -> bool @Pc {

islower	.proc
	; source: library:/prog8lib/strings.p8:524   %asm {{
            cmp  #'a'
            bcs  +
            rts
+           cmp  #'z'+1
            bcc  +
            clc
            rts
+           sec
            rts
	.pend
	; source: library:/prog8lib/strings.p8:537   asmsub isletter(ubyte petsciichar @A) -> bool @Pc {

isletter	.proc
	; source: library:/prog8lib/strings.p8:538   %asm {{
            jsr  islower
            bcc  isupper
+           rts
	.pend
	; source: library:/prog8lib/strings.p8:546   asmsub isspace(ubyte petsciichar @A) -> bool @Pc {

isspace	.proc
	; source: library:/prog8lib/strings.p8:547   %asm {{
            cmp  #32
            beq  +
            cmp  #13
            beq  +
            cmp  #9
            beq  +
            cmp  #10
            beq  +
            cmp  #141
            beq  +
            cmp  #160
            beq  +
            clc
            rts
+           sec
            rts
	.pend
	; source: library:/prog8lib/strings.p8:567   asmsub isprint(ubyte petsciichar @A) -> bool @Pc {

isprint	.proc
	; source: library:/prog8lib/strings.p8:568   %asm {{
            cmp  #160
            bcc  +
            rts
+           cmp  #32
            bcs  +
            rts
+           cmp  #128
            bcc  +
            clc
            rts
+           sec
            rts
	.pend
	.pend

; ---- block: 'p8b_setup' ----
p8b_setup	.proc
	; source: setup.p8:8   setup {


	; source: setup.p8:10   sub run() {

p8s_run	.proc
p8v_user_level_input 	= 64 	; zp uword
p8v_time_limit_input 	= 66 	; zp uword
p8v_sysop_name 	= 68 	; zp uword
p8v_parsed 	= 70 	; zp ubyte
p8v_max_users_input 	= 71 	; zp uword
p8v_drive_num 	= 73 	; zp ubyte
p8v_drive_input 	= 74 	; zp uword
p8v_bbs_name 	= 76 	; zp uword
; statements
	; source: setup.p8:50   ubyte parsed = conv.str2ubyte(drive_input)
	; source: setup.p8:26   uword bbs_name = txt.input_chars(40)
	; source: setup.p8:36   uword sysop_name = txt.input_chars(40)
	; source: setup.p8:46   uword drive_input = txt.input_chars(2)
	; source: setup.p8:47   ubyte drive_num = 8
	; source: setup.p8:61   uword max_users_input = txt.input_chars(5)
	; source: setup.p8:71   uword time_limit_input = txt.input_chars(5)
	; source: setup.p8:81   uword user_level_input = txt.input_chars(2)
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:11   chrout(147)
	lda  #$93
	jsr  txt.chrout
	; source: setup.p8:12   txt.print("=== ColorX128 BBS Setup ===")
	ldy  #>prog8_interned_strings.string_36
	lda  #<prog8_interned_strings.string_36
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:15   txt.print("Welcome to the BBS setup wizard.")
	ldy  #>prog8_interned_strings.string_37
	lda  #<prog8_interned_strings.string_37
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:17   txt.print("This will help you configure your BBS.")
	ldy  #>prog8_interned_strings.string_38
	lda  #<prog8_interned_strings.string_38
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:22   config.configpos = 0
	lda  #0
	sta  p8b_config.p8v_configpos
	; source: setup.p8:25   txt.print("BBS Name: ")
	ldy  #>prog8_interned_strings.string_39
	lda  #<prog8_interned_strings.string_39
	jsr  txt.print
	; source: setup.p8:26   uword bbs_name = txt.input_chars(40)
	ldy  #>$28
	lda  #<$28
	jsr  txt.input_chars
	tya
	sta  p8v_bbs_name
	lda  #0
	sta  p8v_bbs_name+1
	; source: setup.p8:27   if strings.length(bbs_name) > 0 {
	ldy  p8v_bbs_name+1
	lda  p8v_bbs_name
	jsr  strings.length
	tya
	beq  p8_label_gen_253_else
	; source: setup.p8:28   config.setdirective("bbsname", bbs_name)
	lda  #<prog8_interned_strings.string_40
	ldy  #>prog8_interned_strings.string_40
	sta  p8b_config.p8s_setdirective.p8v_directive
	sty  p8b_config.p8s_setdirective.p8v_directive+1
	lda  p8v_bbs_name
	ldy  p8v_bbs_name+1
	sta  p8b_config.p8s_setdirective.p8v_value
	sty  p8b_config.p8s_setdirective.p8v_value+1
	jsr  p8b_config.p8s_setdirective
	jmp  p8_label_gen_252_afterif
p8_label_gen_253_else
	; source: setup.p8:30   config.setdirective("bbsname", "ColorX128 BBS")
	lda  #<prog8_interned_strings.string_40
	ldy  #>prog8_interned_strings.string_40
	sta  p8b_config.p8s_setdirective.p8v_directive
	sty  p8b_config.p8s_setdirective.p8v_directive+1
	lda  #<prog8_interned_strings.string_41
	ldy  #>prog8_interned_strings.string_41
	sta  p8b_config.p8s_setdirective.p8v_value
	sty  p8b_config.p8s_setdirective.p8v_value+1
	jsr  p8b_config.p8s_setdirective
p8_label_gen_252_afterif
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:35   txt.print("SysOp Name: ")
	ldy  #>prog8_interned_strings.string_42
	lda  #<prog8_interned_strings.string_42
	jsr  txt.print
	; source: setup.p8:36   uword sysop_name = txt.input_chars(40)
	ldy  #>$28
	lda  #<$28
	jsr  txt.input_chars
	tya
	sta  p8v_sysop_name
	lda  #0
	sta  p8v_sysop_name+1
	; source: setup.p8:37   if strings.length(sysop_name) > 0 {
	ldy  p8v_sysop_name+1
	lda  p8v_sysop_name
	jsr  strings.length
	tya
	beq  p8_label_gen_255_else
	; source: setup.p8:38   config.setdirective("sysopname", sysop_name)
	lda  #<prog8_interned_strings.string_43
	ldy  #>prog8_interned_strings.string_43
	sta  p8b_config.p8s_setdirective.p8v_directive
	sty  p8b_config.p8s_setdirective.p8v_directive+1
	lda  p8v_sysop_name
	ldy  p8v_sysop_name+1
	sta  p8b_config.p8s_setdirective.p8v_value
	sty  p8b_config.p8s_setdirective.p8v_value+1
	jsr  p8b_config.p8s_setdirective
	jmp  p8_label_gen_254_afterif
p8_label_gen_255_else
	; source: setup.p8:40   config.setdirective("sysopname", "SysOp")
	lda  #<prog8_interned_strings.string_43
	ldy  #>prog8_interned_strings.string_43
	sta  p8b_config.p8s_setdirective.p8v_directive
	sty  p8b_config.p8s_setdirective.p8v_directive+1
	lda  #<prog8_interned_strings.string_44
	ldy  #>prog8_interned_strings.string_44
	sta  p8b_config.p8s_setdirective.p8v_value
	sty  p8b_config.p8s_setdirective.p8v_value+1
	jsr  p8b_config.p8s_setdirective
p8_label_gen_254_afterif
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:45   txt.print("Disk Drive Number (8-11): ")
	ldy  #>prog8_interned_strings.string_45
	lda  #<prog8_interned_strings.string_45
	jsr  txt.print
	; source: setup.p8:46   uword drive_input = txt.input_chars(2)
	ldy  #>2
	lda  #<2
	jsr  txt.input_chars
	tya
	sta  p8v_drive_input
	lda  #0
	sta  p8v_drive_input+1
	; source: setup.p8:47   ubyte drive_num = 8
	lda  #8
	sta  p8v_drive_num
	; source: setup.p8:48   if strings.length(drive_input) > 0 {
	ldy  p8v_drive_input+1
	lda  p8v_drive_input
	jsr  strings.length
	tya
	beq  p8_label_gen_256_afterif
	; source: setup.p8:50   ubyte parsed = conv.str2ubyte(drive_input)
	ldy  p8v_drive_input+1
	lda  p8v_drive_input
	; inlined routine follows: str2ubyte
	; source: library:/prog8lib/conv.p8:368   %asm {{
		jsr  conv.str2uword
	; inlined routine end: str2ubyte
	sta  p8v_parsed
	; source: setup.p8:51   if parsed >= 8 and parsed <= 11 {
	cmp  #8
	rol  a
	and  #1
	beq  p8_label_gen_257_shortcut
	lda  p8v_parsed
	cmp  #12
	rol  a
	and  #1
	eor  #1
p8_label_gen_257_shortcut
	beq  p8_label_gen_258_afterif
	; source: setup.p8:52   drive_num = parsed
	lda  p8v_parsed
	sta  p8v_drive_num
p8_label_gen_258_afterif
p8_label_gen_256_afterif
	; source: setup.p8:55   config.setdirective("drive", conv.str_ub(drive_num))
	lda  #<prog8_interned_strings.string_46
	ldy  #>prog8_interned_strings.string_46
	sta  p8b_config.p8s_setdirective.p8v_directive
	sty  p8b_config.p8s_setdirective.p8v_directive+1
	lda  p8v_drive_num
	jsr  conv.str_ub
	sta  p8b_config.p8s_setdirective.p8v_value
	sty  p8b_config.p8s_setdirective.p8v_value+1
	jsr  p8b_config.p8s_setdirective
	; source: setup.p8:56   config.configdrive = drive_num
	lda  p8v_drive_num
	sta  p8b_config.p8v_configdrive
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:60   txt.print("Maximum Users: ")
	ldy  #>prog8_interned_strings.string_47
	lda  #<prog8_interned_strings.string_47
	jsr  txt.print
	; source: setup.p8:61   uword max_users_input = txt.input_chars(5)
	ldy  #>5
	lda  #<5
	jsr  txt.input_chars
	tya
	sta  p8v_max_users_input
	lda  #0
	sta  p8v_max_users_input+1
	; source: setup.p8:62   if strings.length(max_users_input) > 0 {
	ldy  p8v_max_users_input+1
	lda  p8v_max_users_input
	jsr  strings.length
	tya
	beq  p8_label_gen_260_else
	; source: setup.p8:63   config.setdirective("maxusers", max_users_input)
	lda  #<prog8_interned_strings.string_48
	ldy  #>prog8_interned_strings.string_48
	sta  p8b_config.p8s_setdirective.p8v_directive
	sty  p8b_config.p8s_setdirective.p8v_directive+1
	lda  p8v_max_users_input
	ldy  p8v_max_users_input+1
	sta  p8b_config.p8s_setdirective.p8v_value
	sty  p8b_config.p8s_setdirective.p8v_value+1
	jsr  p8b_config.p8s_setdirective
	jmp  p8_label_gen_259_afterif
p8_label_gen_260_else
	; source: setup.p8:65   config.setdirective("maxusers", "100")
	lda  #<prog8_interned_strings.string_48
	ldy  #>prog8_interned_strings.string_48
	sta  p8b_config.p8s_setdirective.p8v_directive
	sty  p8b_config.p8s_setdirective.p8v_directive+1
	lda  #<prog8_interned_strings.string_49
	ldy  #>prog8_interned_strings.string_49
	sta  p8b_config.p8s_setdirective.p8v_value
	sty  p8b_config.p8s_setdirective.p8v_value+1
	jsr  p8b_config.p8s_setdirective
p8_label_gen_259_afterif
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:70   txt.print("Time Limit (minutes, 0=unlimited): ")
	ldy  #>prog8_interned_strings.string_50
	lda  #<prog8_interned_strings.string_50
	jsr  txt.print
	; source: setup.p8:71   uword time_limit_input = txt.input_chars(5)
	ldy  #>5
	lda  #<5
	jsr  txt.input_chars
	tya
	sta  p8v_time_limit_input
	lda  #0
	sta  p8v_time_limit_input+1
	; source: setup.p8:72   if strings.length(time_limit_input) > 0 {
	ldy  p8v_time_limit_input+1
	lda  p8v_time_limit_input
	jsr  strings.length
	tya
	beq  p8_label_gen_262_else
	; source: setup.p8:73   config.setdirective("timelimit", time_limit_input)
	lda  #<prog8_interned_strings.string_51
	ldy  #>prog8_interned_strings.string_51
	sta  p8b_config.p8s_setdirective.p8v_directive
	sty  p8b_config.p8s_setdirective.p8v_directive+1
	lda  p8v_time_limit_input
	ldy  p8v_time_limit_input+1
	sta  p8b_config.p8s_setdirective.p8v_value
	sty  p8b_config.p8s_setdirective.p8v_value+1
	jsr  p8b_config.p8s_setdirective
	jmp  p8_label_gen_261_afterif
p8_label_gen_262_else
	; source: setup.p8:75   config.setdirective("timelimit", "60")
	lda  #<prog8_interned_strings.string_51
	ldy  #>prog8_interned_strings.string_51
	sta  p8b_config.p8s_setdirective.p8v_directive
	sty  p8b_config.p8s_setdirective.p8v_directive+1
	lda  #<prog8_interned_strings.string_52
	ldy  #>prog8_interned_strings.string_52
	sta  p8b_config.p8s_setdirective.p8v_value
	sty  p8b_config.p8s_setdirective.p8v_value+1
	jsr  p8b_config.p8s_setdirective
p8_label_gen_261_afterif
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:80   txt.print("Default User Level (0-9): ")
	ldy  #>prog8_interned_strings.string_53
	lda  #<prog8_interned_strings.string_53
	jsr  txt.print
	; source: setup.p8:81   uword user_level_input = txt.input_chars(2)
	ldy  #>2
	lda  #<2
	jsr  txt.input_chars
	tya
	sta  p8v_user_level_input
	lda  #0
	sta  p8v_user_level_input+1
	; source: setup.p8:82   if strings.length(user_level_input) > 0 {
	ldy  p8v_user_level_input+1
	lda  p8v_user_level_input
	jsr  strings.length
	tya
	beq  p8_label_gen_264_else
	; source: setup.p8:83   config.setdirective("defaultlevel", user_level_input)
	lda  #<prog8_interned_strings.string_54
	ldy  #>prog8_interned_strings.string_54
	sta  p8b_config.p8s_setdirective.p8v_directive
	sty  p8b_config.p8s_setdirective.p8v_directive+1
	lda  p8v_user_level_input
	ldy  p8v_user_level_input+1
	sta  p8b_config.p8s_setdirective.p8v_value
	sty  p8b_config.p8s_setdirective.p8v_value+1
	jsr  p8b_config.p8s_setdirective
	jmp  p8_label_gen_263_afterif
p8_label_gen_264_else
	; source: setup.p8:85   config.setdirective("defaultlevel", "0")
	lda  #<prog8_interned_strings.string_54
	ldy  #>prog8_interned_strings.string_54
	sta  p8b_config.p8s_setdirective.p8v_directive
	sty  p8b_config.p8s_setdirective.p8v_directive+1
	lda  #<prog8_interned_strings.string_55
	ldy  #>prog8_interned_strings.string_55
	sta  p8b_config.p8s_setdirective.p8v_value
	sty  p8b_config.p8s_setdirective.p8v_value+1
	jsr  p8b_config.p8s_setdirective
p8_label_gen_263_afterif
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:90   txt.print("Setup complete!")
	ldy  #>prog8_interned_strings.string_56
	lda  #<prog8_interned_strings.string_56
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:92   txt.print("Saving configuration...")
	ldy  #>prog8_interned_strings.string_57
	lda  #<prog8_interned_strings.string_57
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:96   if config.save() {
	jsr  p8b_config.p8s_save
	cmp  #0
	beq  p8_label_gen_266_else
	; source: setup.p8:97   txt.print("Configuration saved successfully.")
	ldy  #>prog8_interned_strings.string_58
	lda  #<prog8_interned_strings.string_58
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:100   txt.print("Press any key to continue...")
	ldy  #>prog8_interned_strings.string_59
	lda  #<prog8_interned_strings.string_59
	jsr  txt.print
	; source: setup.p8:101   void txt.input_chars(1)
	ldy  #>1
	lda  #<1
	jmp  txt.input_chars
	; source: setup.p8:102   return
p8_label_gen_266_else
	; source: setup.p8:104   txt.print("ERROR: Failed to save configuration!")
	ldy  #>prog8_interned_strings.string_60
	lda  #<prog8_interned_strings.string_60
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: setup.p8:106   txt.print("Press any key to exit...")
	ldy  #>prog8_interned_strings.string_61
	lda  #<prog8_interned_strings.string_61
	jsr  txt.print
	; source: setup.p8:107   void txt.input_chars(1)
	ldy  #>1
	lda  #<1
	jmp  txt.input_chars
	; source: setup.p8:108   return
p8_label_gen_265_afterif
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	.pend

; ---- block: 'p8b_com' ----
p8b_com	.proc
	; source: com.p8:8   com {
	p8c_SERIAL_CHANNEL = 1
	p8c_SERIAL_DEVICE = 2
	p8c_SERIAL_SECONDARY = 0

; non-zeropage variables
	.section BSS
p8v_current_channel	.byte  ?
p8v_device_initialized	.byte  ?
	.send BSS

	; source: com.p8:10   const ubyte SERIAL_DEVICE = 2
	; source: com.p8:11   const ubyte SERIAL_CHANNEL = 1
	; source: com.p8:12   const ubyte SERIAL_SECONDARY = 0  ; Secondary address for serial device
	; source: com.p8:14   ubyte @shared device_initialized = false
	; source: com.p8:15   ubyte @shared current_channel = 0
	; source: com.p8:19   sub init() -> bool {

p8s_init	.proc
; statements
	; source: com.p8:35   ubyte status = cbm.READST()
	; source: com.p8:20   if device_initialized != 0 {
	lda  p8b_com.p8v_device_initialized
	beq  p8_label_gen_267_afterif
	; source: com.p8:21   return true  ; Already initialized
	lda  #1
	rts
p8_label_gen_267_afterif
	; source: com.p8:26   cbm.SETLFS(SERIAL_CHANNEL, SERIAL_DEVICE, SERIAL_SECONDARY)
	ldy  #0
	ldx  #2
	lda  #1
	jsr  cbm.SETLFS
	; source: com.p8:29   cbm.SETNAM(0, "")
	ldy  #>prog8_interned_strings.string_23
	ldx  #<prog8_interned_strings.string_23
	lda  #0
	jsr  cbm.SETNAM
	; source: com.p8:32   cbm.OPEN()
	jsr  cbm.OPEN
	; source: com.p8:35   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: com.p8:36   if status != 0 {
	lda  p8v_status
	beq  p8_label_gen_268_afterif
	; source: com.p8:37   txt.print("Error initializing serial device: ")
	ldy  #>prog8_interned_strings.string_62
	lda  #<prog8_interned_strings.string_62
	jsr  txt.print
	; source: com.p8:38   txt.print_ub(status)
	lda  p8v_status
	jsr  txt.print_ub
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: com.p8:40   return false
	lda  #0
	rts
p8_label_gen_268_afterif
	; source: com.p8:44   cbm.CHKIN(SERIAL_CHANNEL)
	ldx  #1
	jsr  cbm.CHKIN
	; source: com.p8:46   device_initialized = 1
	lda  #1
	sta  p8b_com.p8v_device_initialized
	; source: com.p8:47   current_channel = SERIAL_CHANNEL
	sta  p8b_com.p8v_current_channel
	; source: com.p8:49   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_status	.byte  ?
	.send BSS
	.pend
	; source: com.p8:53   sub close() {

p8s_close	.proc
; statements
	; source: com.p8:54   if device_initialized != 0 {
	lda  p8b_com.p8v_device_initialized
	beq  p8_label_gen_269_afterif
	; source: com.p8:55   cbm.CLRCHN()  ; Clear channels
	jsr  cbm.CLRCHN
	; source: com.p8:56   cbm.CLOSE(SERIAL_CHANNEL)  ; Close logical file
	lda  #1
	jsr  cbm.CLOSE
	; source: com.p8:57   device_initialized = 0
	lda  #0
	sta  p8b_com.p8v_device_initialized
	; source: com.p8:58   current_channel = 0
	sta  p8b_com.p8v_current_channel
p8_label_gen_269_afterif
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: com.p8:64   sub read_char() -> ubyte {

p8s_read_char	.proc
; statements
	; source: com.p8:70   ubyte status = cbm.READST()
	; source: com.p8:80   ubyte ch = cbm.CHRIN()
	; source: com.p8:65   if device_initialized == 0 {
	lda  p8b_com.p8v_device_initialized
	bne  p8_label_gen_270_afterif
	; source: com.p8:66   return 0
	lda  #0
	rts
p8_label_gen_270_afterif
	; source: com.p8:70   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: com.p8:71   if status != 0 {
	lda  p8v_status
	beq  p8_label_gen_271_afterif
	; source: com.p8:73   if (status & $40) == 0 {
	bit  p8b_com.p8s_read_char.p8v_status
	bvs  p8_label_gen_272_afterif
	; source: com.p8:75   return 0
	lda  #0
	rts
p8_label_gen_272_afterif
p8_label_gen_271_afterif
	; source: com.p8:80   ubyte ch = cbm.CHRIN()
	jsr  cbm.CHRIN
	sta  p8v_ch
	; source: com.p8:83   status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: com.p8:84   if status != 0 and (status & $40) == 0 {
	lda  p8v_status
	beq  p8_label_gen_273_shortcut
	lda  p8v_status
	and  #$40
	beq  +
	lda  #1
+                           eor  #1
p8_label_gen_273_shortcut
	beq  p8_label_gen_274_afterif
	; source: com.p8:86   return 0
	lda  #0
	rts
p8_label_gen_274_afterif
	; source: com.p8:89   return ch
	lda  p8v_ch
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_ch	.byte  ?
p8v_status	.byte  ?
	.send BSS
	.pend
	; source: com.p8:93   sub write_char(ubyte ch) -> bool {

p8s_write_char	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_ch
; statements
	; source: com.p8:108   ubyte status = cbm.READST()
	; source: com.p8:94   if device_initialized == 0 {
	lda  p8b_com.p8v_device_initialized
	bne  p8_label_gen_275_afterif
	; source: com.p8:95   return false
	lda  #0
	rts
p8_label_gen_275_afterif
	; source: com.p8:99   if current_channel != SERIAL_CHANNEL {
	lda  p8b_com.p8v_current_channel
	cmp  #1
	beq  p8_label_gen_276_afterif
	; source: com.p8:100   cbm.CHKOUT(SERIAL_CHANNEL)
	ldx  #1
	jsr  cbm.CHKOUT
	; source: com.p8:101   current_channel = SERIAL_CHANNEL
	lda  #1
	sta  p8b_com.p8v_current_channel
p8_label_gen_276_afterif
	; source: com.p8:105   cbm.CHROUT(ch)
	lda  p8v_ch
	jsr  cbm.CHROUT
	; source: com.p8:108   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: com.p8:109   if status != 0 {
	lda  p8v_status
	beq  p8_label_gen_277_afterif
	; source: com.p8:110   return false
	lda  #0
	rts
p8_label_gen_277_afterif
	; source: com.p8:113   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_ch	.byte  ?
p8v_status	.byte  ?
	.send BSS
	.pend
	; source: com.p8:117   sub write_str(uword str_ptr) -> bool {

p8s_write_str	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_str_ptr
	sty  p8v_str_ptr+1
; statements
	; source: com.p8:139   ubyte status = cbm.READST()
	; source: com.p8:131   ubyte ch = @(str_ptr + i)
	; source: com.p8:129   uword i = 0
	; source: com.p8:118   if device_initialized == 0 {
	lda  p8b_com.p8v_device_initialized
	bne  p8_label_gen_278_afterif
	; source: com.p8:119   return false
	lda  #0
	rts
p8_label_gen_278_afterif
	; source: com.p8:123   if current_channel != SERIAL_CHANNEL {
	lda  p8b_com.p8v_current_channel
	cmp  #1
	beq  p8_label_gen_279_afterif
	; source: com.p8:124   cbm.CHKOUT(SERIAL_CHANNEL)
	ldx  #1
	jsr  cbm.CHKOUT
	; source: com.p8:125   current_channel = SERIAL_CHANNEL
	lda  #1
	sta  p8b_com.p8v_current_channel
p8_label_gen_279_afterif
	; source: com.p8:129   uword i = 0
	lda  #0
	sta  p8v_i
	sta  p8v_i+1
	; source: com.p8:130   while i < 255 {  ; Safety limit
p8_label_gen_47_whileloop
	ldy  p8v_i+1
	lda  p8v_i
	cmp  #<$ff
	tya
	sbc  #>$ff
	bcs  p8_label_gen_48_afterwhile
	; source: com.p8:131   ubyte ch = @(str_ptr + i)
	lda  p8b_com.p8s_write_str.p8v_str_ptr
	sta  P8ZP_SCRATCH_W2
	lda  p8b_com.p8s_write_str.p8v_str_ptr+1
	clc
	adc  p8b_com.p8s_write_str.p8v_i+1
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8b_com.p8s_write_str.p8v_i
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8v_ch
	; source: com.p8:132   if ch == 0 {
	beq  p8_label_gen_46_after
	; source: com.p8:136   cbm.CHROUT(ch)
	lda  p8v_ch
	jsr  cbm.CHROUT
	; source: com.p8:139   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: com.p8:140   if status != 0 {
	lda  p8v_status
	beq  p8_label_gen_280_afterif
	; source: com.p8:141   return false
	lda  #0
	rts
p8_label_gen_280_afterif
	; source: com.p8:144   i++
	inc  p8v_i
	bne  +
	inc  p8v_i+1
+
	; source: com.p8:130   while i < 255 {  ; Safety limit
	jmp  p8_label_gen_47_whileloop
p8_label_gen_48_afterwhile
	; source: com.p8:133   break  ; End of string
p8_label_gen_46_after
	; source: com.p8:147   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_ch	.byte  ?
p8v_i	.word  ?
p8v_status	.byte  ?
p8v_str_ptr	.word  ?
	.send BSS
	.pend
	; source: com.p8:152   sub data_available() -> bool {

p8s_data_available	.proc
; statements
	; source: com.p8:158   ubyte status = cbm.READST()
	; source: com.p8:153   if device_initialized == 0 {
	lda  p8b_com.p8v_device_initialized
	bne  p8_label_gen_281_afterif
	; source: com.p8:154   return false
	lda  #0
	rts
p8_label_gen_281_afterif
	; source: com.p8:158   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: com.p8:162   if status == 0 {
	lda  p8v_status
	bne  p8_label_gen_282_afterif
	; source: com.p8:163   return true  ; No error, data might be available
	lda  #1
	rts
p8_label_gen_282_afterif
	; source: com.p8:166   if (status & $40) != 0 {
	bit  p8b_com.p8s_data_available.p8v_status
	bvc  p8_label_gen_283_afterif
	; source: com.p8:167   return false  ; EOF reached
	lda  #0
	rts
p8_label_gen_283_afterif
	; source: com.p8:171   return false
	lda  #0
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_status	.byte  ?
	.send BSS
	.pend
	; source: com.p8:176   sub get_status() -> ubyte {

p8s_get_status	.proc
; statements
	; source: com.p8:177   if device_initialized == 0 {
	lda  p8b_com.p8v_device_initialized
	bne  p8_label_gen_284_afterif
	; source: com.p8:178   return 255  ; Error code for not initialized
	lda  #$ff
	rts
p8_label_gen_284_afterif
	; source: com.p8:181   return cbm.READST()
	jmp  cbm.READST
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_session' ----
p8b_session	.proc
	; source: session.p8:12   session {
p8v_session_start_time 	= 78 	; zp uword
p8v_session_active 	= 80 	; zp ubyte
p8v_input_pos 	= 81 	; zp ubyte
p8v_current_state 	= 82 	; zp ubyte
p8v_bytes_sent 	= 83 	; zp uword
p8v_bytes_received 	= 85 	; zp uword
	p8c_STATE_CONNECTED = 1
	p8c_STATE_DISCONNECTED = 4
	p8c_STATE_LOGIN = 2
	p8c_STATE_MENU = 3
	p8c_STATE_WAITING = 0

; non-zeropage variables
	.section BSS
p8v_input_buffer	.fill  256
	.send BSS

	; source: session.p8:14   ubyte @shared session_active = false
	; source: session.p8:15   uword @shared session_start_time = 0
	; source: session.p8:16   uword @shared bytes_received = 0
	; source: session.p8:17   uword @shared bytes_sent = 0
	; source: session.p8:20   const ubyte STATE_WAITING = 0
	; source: session.p8:21   const ubyte STATE_CONNECTED = 1
	; source: session.p8:22   const ubyte STATE_LOGIN = 2
	; source: session.p8:23   const ubyte STATE_MENU = 3
	; source: session.p8:24   const ubyte STATE_DISCONNECTED = 4
	; source: session.p8:26   ubyte @shared current_state = STATE_WAITING
	; source: session.p8:29   ubyte[256] input_buffer
	; source: session.p8:30   ubyte input_pos = 0
	; source: session.p8:33   sub init() {

p8s_init	.proc
; statements
	; source: session.p8:34   session_active = 0
	lda  #0
	sta  p8b_session.p8v_session_active
	; source: session.p8:35   current_state = STATE_WAITING
	sta  p8b_session.p8v_current_state
	; source: session.p8:36   input_pos = 0
	sta  p8b_session.p8v_input_pos
	; source: session.p8:37   bytes_received = 0
	sta  p8b_session.p8v_bytes_received
	sta  p8b_session.p8v_bytes_received+1
	; source: session.p8:38   bytes_sent = 0
	lda  #0
	sta  p8b_session.p8v_bytes_sent
	sta  p8b_session.p8v_bytes_sent+1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: session.p8:43   sub wait_for_connection() -> bool {

p8s_wait_for_connection	.proc
p8v_timeout 	= 87 	; zp uword
; statements
	; source: session.p8:48   uword timeout = 0
	; source: session.p8:44   txt.print("Waiting for connection...")
	ldy  #>prog8_interned_strings.string_63
	lda  #<prog8_interned_strings.string_63
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: session.p8:48   uword timeout = 0
	lda  #0
	sta  p8v_timeout
	sta  p8v_timeout+1
	; source: session.p8:49   while timeout < 18000 {  ; 5 minutes (60 jiffies per second * 60 * 5)
p8_label_gen_51_whileloop
	ldy  p8v_timeout+1
	lda  p8v_timeout
	cmp  #<$4650
	tya
	sbc  #>$4650
	bcs  p8_label_gen_52_afterwhile
	; source: session.p8:50   if com.data_available() {
	jsr  p8b_com.p8s_data_available
	cmp  #0
	beq  p8_label_gen_285_afterif
	; source: session.p8:52   session_active = 1
	lda  #1
	sta  p8b_session.p8v_session_active
	; source: session.p8:53   current_state = STATE_CONNECTED
	sta  p8b_session.p8v_current_state
	; source: session.p8:54   session_start_time = 0  ; TODO: Use actual system time when available
	lda  #0
	sta  p8b_session.p8v_session_start_time
	sta  p8b_session.p8v_session_start_time+1
	; source: session.p8:55   txt.print("Connection detected!")
	ldy  #>prog8_interned_strings.string_64
	lda  #<prog8_interned_strings.string_64
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: session.p8:57   return true
	lda  #1
	rts
p8_label_gen_285_afterif
	; source: session.p8:61   sys.wait(6)  ; 0.1 second
	ldy  #>6
	lda  #<6
	jsr  sys.wait
	; source: session.p8:62   timeout = timeout + 6
	lda  p8v_timeout
	clc
	adc  #6
	sta  p8v_timeout
	bcc  +
	inc  p8v_timeout+1
+
	; source: session.p8:49   while timeout < 18000 {  ; 5 minutes (60 jiffies per second * 60 * 5)
	jmp  p8_label_gen_51_whileloop
p8_label_gen_52_afterwhile
	; source: session.p8:66   txt.print("Connection timeout")
	ldy  #>prog8_interned_strings.string_65
	lda  #<prog8_interned_strings.string_65
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: session.p8:68   return false
	lda  #0
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: session.p8:72   sub send_greeting() {

p8s_send_greeting	.proc
p8v_bbs_name 	= 93 	; zp uword
; statements
	; source: session.p8:73   uword bbs_name = config.getdirective("bbsname")
	ldy  #>prog8_interned_strings.string_40
	lda  #<prog8_interned_strings.string_40
	jsr  p8b_config.p8s_getdirective
	sta  p8v_bbs_name
	sty  p8v_bbs_name+1
	; source: session.p8:74   if strings.length(bbs_name) == 0 {
	jsr  strings.length
	tya
	bne  p8_label_gen_286_afterif
	; source: session.p8:75   bbs_name = "ColorX128 BBS"
	lda  #<prog8_interned_strings.string_41
	ldy  #>prog8_interned_strings.string_41
	sta  p8v_bbs_name
	sty  p8v_bbs_name+1
p8_label_gen_286_afterif
	; source: session.p8:79   com.write_char($0d)  ; Carriage return
	lda  #13
	jsr  p8b_com.p8s_write_char
	; source: session.p8:80   com.write_char($0a)  ; Line feed
	lda  #10
	jsr  p8b_com.p8s_write_char
	; source: session.p8:81   com.write_str("Welcome to ")
	ldy  #>prog8_interned_strings.string_66
	lda  #<prog8_interned_strings.string_66
	jsr  p8b_com.p8s_write_str
	; source: session.p8:82   com.write_str(bbs_name)
	ldy  p8v_bbs_name+1
	lda  p8v_bbs_name
	jsr  p8b_com.p8s_write_str
	; source: session.p8:83   com.write_str("!")
	ldy  #>prog8_interned_strings.string_67
	lda  #<prog8_interned_strings.string_67
	jsr  p8b_com.p8s_write_str
	; source: session.p8:84   com.write_char($0d)
	lda  #13
	jsr  p8b_com.p8s_write_char
	; source: session.p8:85   com.write_char($0a)
	lda  #10
	jsr  p8b_com.p8s_write_char
	; source: session.p8:86   com.write_char($0d)
	lda  #13
	jsr  p8b_com.p8s_write_char
	; source: session.p8:87   com.write_char($0a)
	lda  #10
	jmp  p8b_com.p8s_write_char
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: session.p8:93   sub read_line() -> bool {

p8s_read_line	.proc
p8v_ch 	= 95 	; zp ubyte
; statements
	; source: session.p8:104   ubyte ch = com.read_char()
	; source: session.p8:94   input_pos = 0
	lda  #0
	sta  p8b_session.p8v_input_pos
	; source: session.p8:95   input_buffer[0] = 0
	sta  p8b_session.p8v_input_buffer+0
	; source: session.p8:101   continue
p8_label_gen_53_cont
	; source: session.p8:109   continue
p8_label_gen_54_cont
	; source: session.p8:124   continue
p8_label_gen_55_cont
	; source: session.p8:97   while input_pos < 255 {
p8_label_gen_56_whileloop
	lda  p8b_session.p8v_input_pos
	cmp  #255
	bcs  p8_label_gen_57_afterwhile
	; source: session.p8:98   if not com.data_available() {
	jsr  p8b_com.p8s_data_available
	cmp  #0
	bne  p8_label_gen_287_afterif
	; source: session.p8:100   sys.wait(1)
	ldy  #>1
	lda  #<1
	jsr  sys.wait
	; source: session.p8:101   continue
	jmp  p8_label_gen_53_cont
p8_label_gen_287_afterif
	; source: session.p8:104   ubyte ch = com.read_char()
	jsr  p8b_com.p8s_read_char
	sta  p8v_ch
	; source: session.p8:106   if ch == 0 {
	lda  p8v_ch
	bne  p8_label_gen_288_afterif
	; source: session.p8:108   sys.wait(1)
	ldy  #>1
	lda  #<1
	jsr  sys.wait
	; source: session.p8:109   continue
	jmp  p8_label_gen_54_cont
p8_label_gen_288_afterif
	; source: session.p8:112   bytes_received++
	inc  p8b_session.p8v_bytes_received
	bne  +
	inc  p8b_session.p8v_bytes_received+1
+
	; source: session.p8:115   if ch == $08 or ch == $7f {  ; Backspace or DEL
	lda  p8v_ch
	cmp  #8
	beq  +
	cmp  #127
	beq  +
	lda  #0
	beq  ++
+                       lda  #1
+
	cmp  #0
	beq  p8_label_gen_289_afterif
	; source: session.p8:116   if input_pos > 0 {
	lda  p8b_session.p8v_input_pos
	beq  p8_label_gen_290_afterif
	; source: session.p8:117   input_pos--
	dec  p8b_session.p8v_input_pos
	; source: session.p8:118   input_buffer[input_pos] = 0
	ldy  p8b_session.p8v_input_pos
	lda  #0
	sta  p8b_session.p8v_input_buffer,y
	; source: session.p8:120   com.write_char($08)  ; Backspace
	lda  #8
	jsr  p8b_com.p8s_write_char
	; source: session.p8:121   com.write_char($20)  ; Space
	lda  #$20
	jsr  p8b_com.p8s_write_char
	; source: session.p8:122   com.write_char($08)  ; Backspace again
	lda  #8
	jsr  p8b_com.p8s_write_char
p8_label_gen_290_afterif
	; source: session.p8:124   continue
	jmp  p8_label_gen_55_cont
p8_label_gen_289_afterif
	; source: session.p8:127   if ch == $0d or ch == $0a {  ; Carriage return or line feed
	lda  p8v_ch
	cmp  #10
	beq  +
	cmp  #13
	beq  +
	lda  #0
	beq  ++
+                       lda  #1
+
	cmp  #0
	beq  p8_label_gen_291_afterif
	; source: session.p8:129   input_buffer[input_pos] = 0
	ldy  p8b_session.p8v_input_pos
	lda  #0
	sta  p8b_session.p8v_input_buffer,y
	; source: session.p8:130   com.write_char($0d)
	lda  #13
	jsr  p8b_com.p8s_write_char
	; source: session.p8:131   com.write_char($0a)
	lda  #10
	jsr  p8b_com.p8s_write_char
	; source: session.p8:132   return true
	lda  #1
	rts
p8_label_gen_291_afterif
	; source: session.p8:136   if ch >= $20 and ch <= $7e {  ; Printable ASCII
	lda  p8v_ch
	cmp  #32
	rol  a
	and  #1
	beq  p8_label_gen_292_shortcut
	lda  p8v_ch
	cmp  #127
	rol  a
	and  #1
	eor  #1
p8_label_gen_292_shortcut
	beq  p8_label_gen_293_afterif
	; source: session.p8:137   input_buffer[input_pos] = ch
	ldy  p8b_session.p8v_input_pos
	lda  p8v_ch
	sta  p8b_session.p8v_input_buffer,y
	; source: session.p8:138   input_pos++
	inc  p8b_session.p8v_input_pos
	; source: session.p8:139   input_buffer[input_pos] = 0
	ldy  p8b_session.p8v_input_pos
	lda  #0
	sta  p8b_session.p8v_input_buffer,y
	; source: session.p8:142   com.write_char(ch)
	lda  p8v_ch
	jsr  p8b_com.p8s_write_char
p8_label_gen_293_afterif
	; source: session.p8:97   while input_pos < 255 {
	jmp  p8_label_gen_56_whileloop
p8_label_gen_57_afterwhile
	; source: session.p8:147   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: session.p8:151   sub get_input_line() -> uword {

p8s_get_input_line	.proc
; statements
	; source: session.p8:152   return &input_buffer
	ldy  #>p8b_session.p8v_input_buffer
	lda  #<p8b_session.p8v_input_buffer
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: session.p8:156   sub send_line(uword line) {

p8s_send_line	.proc
p8v_line 	= 91 	; zp uword
; simple int arg(s) passed via cpu register(s)
	sta  p8v_line
	sty  p8v_line+1
; statements
	; source: session.p8:157   com.write_str(line)
	jsr  p8b_com.p8s_write_str
	; source: session.p8:158   com.write_char($0d)
	lda  #13
	jsr  p8b_com.p8s_write_char
	; source: session.p8:159   com.write_char($0a)
	lda  #10
	jsr  p8b_com.p8s_write_char
	; source: session.p8:160   bytes_sent = bytes_sent + strings.length(line) + 2
	ldy  p8v_line+1
	lda  p8v_line
	jsr  strings.length
	tya
	ldy  #0
	clc
	adc  p8b_session.p8v_bytes_sent
	tax
	tya
	adc  p8b_session.p8v_bytes_sent+1
	tay
	txa
	clc
	adc  #2
	bcc  +
	iny
+
	sta  p8b_session.p8v_bytes_sent
	sty  p8b_session.p8v_bytes_sent+1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: session.p8:164   sub send_string(uword str_ptr) {

p8s_send_string	.proc
p8v_str_ptr 	= 89 	; zp uword
; simple int arg(s) passed via cpu register(s)
	sta  p8v_str_ptr
	sty  p8v_str_ptr+1
; statements
	; source: session.p8:165   com.write_str(str_ptr)
	jsr  p8b_com.p8s_write_str
	; source: session.p8:166   bytes_sent = bytes_sent + strings.length(str_ptr)
	ldy  p8v_str_ptr+1
	lda  p8v_str_ptr
	jsr  strings.length
	tya
	clc
	adc  p8b_session.p8v_bytes_sent
	sta  p8b_session.p8v_bytes_sent
	bcc  +
	inc  p8b_session.p8v_bytes_sent+1
+
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: session.p8:170   sub is_active() -> bool {

p8s_is_active	.proc
p8v_status 	= 96 	; zp ubyte
; statements
	; source: session.p8:176   ubyte status = com.get_status()
	; source: session.p8:171   if session_active == 0 {
	lda  p8b_session.p8v_session_active
	bne  p8_label_gen_294_afterif
	; source: session.p8:172   return false
	lda  #0
	rts
p8_label_gen_294_afterif
	; source: session.p8:176   ubyte status = com.get_status()
	jsr  p8b_com.p8s_get_status
	sta  p8v_status
	; source: session.p8:177   if status != 0 and (status & $40) == 0 {
	lda  p8v_status
	beq  p8_label_gen_295_shortcut
	lda  p8v_status
	and  #$40
	beq  +
	lda  #1
+                           eor  #1
p8_label_gen_295_shortcut
	beq  p8_label_gen_296_afterif
	; source: session.p8:179   return false
	lda  #0
	rts
p8_label_gen_296_afterif
	; source: session.p8:182   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: session.p8:187   sub handle_session() {

p8s_handle_session	.proc
p8v_username 	= 97 	; zp uword
; statements
	; source: session.p8:206   uword username = login.get_username()
	; source: session.p8:188   current_state = STATE_CONNECTED
	lda  #1
	sta  p8b_session.p8v_current_state
	; source: session.p8:191   send_greeting()
	jsr  p8b_session.p8s_send_greeting
	; source: session.p8:194   current_state = STATE_LOGIN
	lda  #2
	sta  p8b_session.p8v_current_state
	; source: session.p8:195   if not login.prompt_login() {
	jsr  p8b_login.p8s_prompt_login
	cmp  #0
	bne  p8_label_gen_297_afterif
	; source: session.p8:197   send_line("Login failed. Disconnecting...")
	ldy  #>prog8_interned_strings.string_68
	lda  #<prog8_interned_strings.string_68
	jsr  p8b_session.p8s_send_line
	; source: session.p8:198   session_active = 0
	lda  #0
	sta  p8b_session.p8v_session_active
	; source: session.p8:199   current_state = STATE_DISCONNECTED
	lda  #4
	sta  p8b_session.p8v_current_state
	; source: session.p8:200   return
	rts
p8_label_gen_297_afterif
	; source: session.p8:204   current_state = STATE_MENU
	lda  #3
	sta  p8b_session.p8v_current_state
	; source: session.p8:205   send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: session.p8:206   uword username = login.get_username()
	lda  p8b_login.p8v_current_username
	ldy  p8b_login.p8v_current_username+1
	sta  p8v_username
	sty  p8v_username+1
	; source: session.p8:207   send_string("Welcome, ")
	ldy  #>prog8_interned_strings.string_69
	lda  #<prog8_interned_strings.string_69
	jsr  p8b_session.p8s_send_string
	; source: session.p8:208   send_string(username)
	ldy  p8v_username+1
	lda  p8v_username
	jsr  p8b_session.p8s_send_string
	; source: session.p8:209   send_line("!")
	ldy  #>prog8_interned_strings.string_67
	lda  #<prog8_interned_strings.string_67
	jsr  p8b_session.p8s_send_line
	; source: session.p8:210   send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: session.p8:213   menu.show_info()
	jsr  p8b_menu.p8s_show_info
	; source: session.p8:216   menu.run()
	jsr  p8b_menu.p8s_run
	; source: session.p8:219   send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: session.p8:220   send_line("Connection closed.")
	ldy  #>prog8_interned_strings.string_70
	lda  #<prog8_interned_strings.string_70
	jsr  p8b_session.p8s_send_line
	; source: session.p8:221   session_active = 0
	lda  #0
	sta  p8b_session.p8v_session_active
	; source: session.p8:222   current_state = STATE_DISCONNECTED
	lda  #4
	sta  p8b_session.p8v_current_state
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
prog8_init_vars	.block
	; source: session.p8:14   ubyte @shared session_active = false
	lda  #0
	sta  p8b_session.p8v_session_active
	; source: session.p8:15   uword @shared session_start_time = 0
	sta  p8b_session.p8v_session_start_time
	sta  p8b_session.p8v_session_start_time+1
	; source: session.p8:16   uword @shared bytes_received = 0
	lda  #0
	sta  p8b_session.p8v_bytes_received
	sta  p8b_session.p8v_bytes_received+1
	; source: session.p8:17   uword @shared bytes_sent = 0
	lda  #0
	sta  p8b_session.p8v_bytes_sent
	sta  p8b_session.p8v_bytes_sent+1
	; source: session.p8:26   ubyte @shared current_state = STATE_WAITING
	lda  #0
	sta  p8b_session.p8v_current_state
	; source: session.p8:30   ubyte input_pos = 0
	sta  p8b_session.p8v_input_pos
	rts
	.bend
	.pend

; ---- block: 'p8b_login' ----
p8b_login	.proc
	; source: login.p8:10   login {
	p8c_MAX_LOGIN_ATTEMPTS = 3

; non-zeropage variables
	.section BSS
p8v_current_user_level	.byte  ?
p8v_current_username	.word  ?
p8v_logged_in	.byte  ?
p8v_login_attempts	.byte  ?
	.send BSS

	; source: login.p8:12   ubyte @shared current_user_level = 0
	; source: login.p8:13   uword @shared current_username = ""
	; source: login.p8:14   bool @shared logged_in = false
	; source: login.p8:15   ubyte @shared login_attempts = 0
	; source: login.p8:16   const ubyte MAX_LOGIN_ATTEMPTS = 3
	; source: login.p8:19   sub init() {

p8s_init	.proc
; statements
	; source: login.p8:20   current_user_level = 0
	lda  #0
	sta  p8b_login.p8v_current_user_level
	; source: login.p8:21   current_username = ""
	lda  #<prog8_interned_strings.string_23
	ldy  #>prog8_interned_strings.string_23
	sta  p8b_login.p8v_current_username
	sty  p8b_login.p8v_current_username+1
	; source: login.p8:22   logged_in = false
	lda  #0
	sta  p8b_login.p8v_logged_in
	; source: login.p8:23   login_attempts = 0
	sta  p8b_login.p8v_login_attempts
	; source: login.p8:26   if not userdb.init() {
	jsr  p8b_userdb.p8s_init
	cmp  #0
	bne  p8_label_gen_298_afterif
	; source: login.p8:27   txt.print("WARNING: Could not initialize user database!")
	ldy  #>prog8_interned_strings.string_71
	lda  #<prog8_interned_strings.string_71
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
p8_label_gen_298_afterif
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: login.p8:34   sub prompt_login() -> bool {

p8s_prompt_login	.proc
; statements
	; source: login.p8:67   uword password = session.get_input_line()
	; source: login.p8:51   uword username = session.get_input_line()
	; source: login.p8:85   ubyte remaining = MAX_LOGIN_ATTEMPTS - login_attempts
	; source: login.p8:90   uword rem_str = conv.str_ub(remaining)
	; source: login.p8:35   logged_in = false
	lda  #0
	sta  p8b_login.p8v_logged_in
	; source: login.p8:36   login_attempts = 0
	sta  p8b_login.p8v_login_attempts
	; source: login.p8:39   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: login.p8:40   session.send_line("=== Login Required ===")
	ldy  #>prog8_interned_strings.string_72
	lda  #<prog8_interned_strings.string_72
	jsr  p8b_session.p8s_send_line
	; source: login.p8:41   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: login.p8:55   continue
p8_label_gen_58_cont
	; source: login.p8:43   while login_attempts < MAX_LOGIN_ATTEMPTS {
p8_label_gen_59_whileloop
	lda  p8b_login.p8v_login_attempts
	cmp  #3
	bcs  p8_label_gen_60_afterwhile
	; source: login.p8:45   session.send_string("Username: ")
	ldy  #>prog8_interned_strings.string_73
	lda  #<prog8_interned_strings.string_73
	jsr  p8b_session.p8s_send_string
	; source: login.p8:47   if not session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	bne  p8_label_gen_299_afterif
	; source: login.p8:48   return false  ; Disconnect
	lda  #0
	rts
p8_label_gen_299_afterif
	; source: login.p8:51   uword username = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_username
	sty  p8v_username+1
	; source: login.p8:53   if strings.length(username) == 0 {
	jsr  strings.length
	tya
	bne  p8_label_gen_300_afterif
	; source: login.p8:54   session.send_line("Username cannot be empty.")
	ldy  #>prog8_interned_strings.string_74
	lda  #<prog8_interned_strings.string_74
	jsr  p8b_session.p8s_send_line
	; source: login.p8:55   continue
	jmp  p8_label_gen_58_cont
p8_label_gen_300_afterif
	; source: login.p8:59   session.send_string("Password: ")
	ldy  #>prog8_interned_strings.string_75
	lda  #<prog8_interned_strings.string_75
	jsr  p8b_session.p8s_send_string
	; source: login.p8:63   if not session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	bne  p8_label_gen_301_afterif
	; source: login.p8:64   return false  ; Disconnect
	lda  #0
	rts
p8_label_gen_301_afterif
	; source: login.p8:67   uword password = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_password
	sty  p8v_password+1
	; source: login.p8:70   if userdb.verify_password(username, password) {
	lda  p8v_username
	ldy  p8v_username+1
	sta  p8b_userdb.p8s_verify_password.p8v_username
	sty  p8b_userdb.p8s_verify_password.p8v_username+1
	lda  p8v_password
	ldy  p8v_password+1
	sta  p8b_userdb.p8s_verify_password.p8v_password
	sty  p8b_userdb.p8s_verify_password.p8v_password+1
	jsr  p8b_userdb.p8s_verify_password
	cmp  #0
	beq  p8_label_gen_303_else
	; source: login.p8:72   current_username = username
	lda  p8v_username
	ldy  p8v_username+1
	sta  p8b_login.p8v_current_username
	sty  p8b_login.p8v_current_username+1
	; source: login.p8:73   current_user_level = userdb.get_user_level(username)
	ldy  p8v_username+1
	lda  p8v_username
	jsr  p8b_userdb.p8s_get_user_level
	sta  p8b_login.p8v_current_user_level
	; source: login.p8:74   logged_in = true
	lda  #1
	sta  p8b_login.p8v_logged_in
	; source: login.p8:75   login_attempts = 0
	lda  #0
	sta  p8b_login.p8v_login_attempts
	; source: login.p8:77   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: login.p8:78   session.send_line("Login successful!")
	ldy  #>prog8_interned_strings.string_76
	lda  #<prog8_interned_strings.string_76
	jsr  p8b_session.p8s_send_line
	; source: login.p8:79   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: login.p8:81   return true
	lda  #1
	rts
p8_label_gen_303_else
	; source: login.p8:84   login_attempts++
	inc  p8b_login.p8v_login_attempts
	; source: login.p8:85   ubyte remaining = MAX_LOGIN_ATTEMPTS - login_attempts
	lda  #3
	sec
	sbc  p8b_login.p8v_login_attempts
	sta  p8v_remaining
	; source: login.p8:87   session.send_line("Invalid username or password.")
	ldy  #>prog8_interned_strings.string_77
	lda  #<prog8_interned_strings.string_77
	jsr  p8b_session.p8s_send_line
	; source: login.p8:88   if remaining > 0 {
	lda  p8v_remaining
	beq  p8_label_gen_305_else
	; source: login.p8:89   session.send_string("Attempts remaining: ")
	ldy  #>prog8_interned_strings.string_78
	lda  #<prog8_interned_strings.string_78
	jsr  p8b_session.p8s_send_string
	; source: login.p8:90   uword rem_str = conv.str_ub(remaining)
	lda  p8v_remaining
	jsr  conv.str_ub
	sta  p8v_rem_str
	sty  p8v_rem_str+1
	; source: login.p8:91   session.send_string(rem_str)
	jsr  p8b_session.p8s_send_string
	; source: login.p8:92   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	jmp  p8_label_gen_304_afterif
p8_label_gen_305_else
	; source: login.p8:94   session.send_line("Maximum login attempts exceeded.")
	ldy  #>prog8_interned_strings.string_79
	lda  #<prog8_interned_strings.string_79
	jsr  p8b_session.p8s_send_line
	; source: login.p8:95   session.send_line("Connection terminated.")
	ldy  #>prog8_interned_strings.string_80
	lda  #<prog8_interned_strings.string_80
	jsr  p8b_session.p8s_send_line
	; source: login.p8:96   return false
	lda  #0
	rts
p8_label_gen_304_afterif
p8_label_gen_302_afterif
	; source: login.p8:43   while login_attempts < MAX_LOGIN_ATTEMPTS {
	jmp  p8_label_gen_59_whileloop
p8_label_gen_60_afterwhile
	; source: login.p8:101   return false
	lda  #0
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_password	.word  ?
p8v_rem_str	.word  ?
p8v_remaining	.byte  ?
p8v_username	.word  ?
	.send BSS
	.pend
	; source: login.p8:120   sub logout() {

p8s_logout	.proc
; statements
	; source: login.p8:121   logged_in = false
	lda  #0
	sta  p8b_login.p8v_logged_in
	; source: login.p8:122   current_username = ""
	lda  #<prog8_interned_strings.string_23
	ldy  #>prog8_interned_strings.string_23
	sta  p8b_login.p8v_current_username
	sty  p8b_login.p8v_current_username+1
	; source: login.p8:123   current_user_level = 0
	lda  #0
	sta  p8b_login.p8v_current_user_level
	; source: login.p8:124   login_attempts = 0
	sta  p8b_login.p8v_login_attempts
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
prog8_init_vars	.block
	; source: login.p8:13   uword @shared current_username = ""
	lda  #<prog8_interned_strings.string_23
	ldy  #>prog8_interned_strings.string_23
	sta  p8b_login.p8v_current_username
	sty  p8b_login.p8v_current_username+1
	; source: login.p8:14   bool @shared logged_in = false
	lda  #0
	sta  p8b_login.p8v_logged_in
	rts
	.bend
	.pend

; ---- block: 'p8b_userdb' ----
p8b_userdb	.proc
	; source: userdb.p8:10   userdb {
p8v_db_initialized 	= 10 	; zp ubyte
p8v_max_records 	= 13 	; zp uword
p8v_REL_FILENAME 	= 15 	; zp uword
	p8c_PASSWORD_HASH_SIZE = $10
	p8c_RECORD_SIZE = $40
	p8c_REL_CHANNEL = 2
	p8c_REL_DEVICE = 8
	p8c_REL_SECONDARY = 0
	p8c_SALT_SIZE = 8
	p8c_USERNAME_MAX = $14


	; source: userdb.p8:12   const ubyte REL_CHANNEL = 2
	; source: userdb.p8:13   const ubyte REL_DEVICE = 8
	; source: userdb.p8:14   const ubyte REL_SECONDARY = 0
	; source: userdb.p8:15   uword REL_FILENAME = "bbsusers"
	; source: userdb.p8:18   const ubyte RECORD_SIZE = 64  ; Fixed record size for REL file
	; source: userdb.p8:19   const ubyte USERNAME_MAX = 20
	; source: userdb.p8:20   const ubyte PASSWORD_HASH_SIZE = 16
	; source: userdb.p8:21   const ubyte SALT_SIZE = 8
	; source: userdb.p8:31   ubyte @shared db_initialized = false
	; source: userdb.p8:32   uword @shared max_records = 100  ; Maximum number of user records
	; source: userdb.p8:36   sub init() -> bool {

p8s_init	.proc
p8v_status 	= 33 	; zp ubyte
p8v_rel_filename_len 	= 34 	; zp ubyte
p8v_rel_filename 	= 35 	; zp uword
p8v_rec_size_str 	= 37 	; zp uword
p8v_max_rec_str 	= 39 	; zp uword
; statements
	; source: userdb.p8:69   ubyte status = cbm.READST()
	; source: userdb.p8:63   ubyte rel_filename_len = strings.length(rel_filename)
	; source: userdb.p8:62   uword rel_filename = "bbsusers,L,64,R,100"
	; source: userdb.p8:49   uword max_rec_str = conv.str_uw(max_records)
	; source: userdb.p8:48   uword rec_size_str = conv.str_ub(RECORD_SIZE)
	; source: userdb.p8:37   diskio.drivenumber = REL_DEVICE
	lda  #8
	sta  diskio.drivenumber
	; source: userdb.p8:40   if not diskio.exists(REL_FILENAME) {
	ldy  p8b_userdb.p8v_REL_FILENAME+1
	lda  p8b_userdb.p8v_REL_FILENAME
	jsr  diskio.exists
	cmp  #0
	bne  p8_label_gen_306_afterif
	; source: userdb.p8:42   txt.print("Creating user database...")
	ldy  #>prog8_interned_strings.string_81
	lda  #<prog8_interned_strings.string_81
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: userdb.p8:48   uword rec_size_str = conv.str_ub(RECORD_SIZE)
	lda  #$40
	jsr  conv.str_ub
	sta  p8v_rec_size_str
	sty  p8v_rec_size_str+1
	; source: userdb.p8:49   uword max_rec_str = conv.str_uw(max_records)
	ldy  p8b_userdb.p8v_max_records+1
	lda  p8b_userdb.p8v_max_records
	jsr  conv.str_uw
	sta  p8v_max_rec_str
	sty  p8v_max_rec_str+1
	; source: userdb.p8:57   cbm.SETLFS(REL_CHANNEL, REL_DEVICE, REL_SECONDARY)
	ldy  #0
	ldx  #8
	lda  #2
	jsr  cbm.SETLFS
	; source: userdb.p8:62   uword rel_filename = "bbsusers,L,64,R,100"
	lda  #<prog8_interned_strings.string_83
	ldy  #>prog8_interned_strings.string_83
	sta  p8v_rel_filename
	sty  p8v_rel_filename+1
	; source: userdb.p8:63   ubyte rel_filename_len = strings.length(rel_filename)
	jsr  strings.length
	sty  p8v_rel_filename_len
	; source: userdb.p8:64   cbm.SETNAM(rel_filename_len, rel_filename)
	ldy  p8v_rel_filename+1
	ldx  p8v_rel_filename
	lda  p8v_rel_filename_len
	jsr  cbm.SETNAM
	; source: userdb.p8:67   cbm.OPEN()
	jsr  cbm.OPEN
	; source: userdb.p8:69   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: userdb.p8:70   if status != 0 {
	lda  p8v_status
	beq  p8_label_gen_307_afterif
	; source: userdb.p8:71   txt.print("Error creating REL file: ")
	ldy  #>prog8_interned_strings.string_84
	lda  #<prog8_interned_strings.string_84
	jsr  txt.print
	; source: userdb.p8:72   txt.print_ub(status)
	lda  p8v_status
	jsr  txt.print_ub
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: userdb.p8:74   return false
	lda  #0
	rts
p8_label_gen_307_afterif
	; source: userdb.p8:78   cbm.CLOSE(REL_CHANNEL)
	lda  #2
	jsr  cbm.CLOSE
	; source: userdb.p8:79   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: userdb.p8:81   txt.print("User database created successfully")
	ldy  #>prog8_interned_strings.string_85
	lda  #<prog8_interned_strings.string_85
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
p8_label_gen_306_afterif
	; source: userdb.p8:85   db_initialized = 1
	lda  #1
	sta  p8b_userdb.p8v_db_initialized
	; source: userdb.p8:86   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: userdb.p8:90   sub open_rel() -> bool {

p8s_open_rel	.proc
p8v_status 	= 32 	; zp ubyte
; statements
	; source: userdb.p8:96   ubyte status = cbm.READST()
	; source: userdb.p8:92   cbm.SETLFS(REL_CHANNEL, REL_DEVICE, REL_SECONDARY)
	ldy  #0
	ldx  #8
	lda  #2
	jsr  cbm.SETLFS
	; source: userdb.p8:93   cbm.SETNAM(strings.length(REL_FILENAME), REL_FILENAME)
	ldy  p8b_userdb.p8v_REL_FILENAME+1
	ldx  p8b_userdb.p8v_REL_FILENAME
	txa
	pha
	tya
	pha
	ldy  p8b_userdb.p8v_REL_FILENAME+1
	lda  p8b_userdb.p8v_REL_FILENAME
	jsr  strings.length
	tya
	sta  P8ZP_SCRATCH_REG
	pla
	tay
	lda  P8ZP_SCRATCH_REG
	pla
	tax
	lda  P8ZP_SCRATCH_REG
	jsr  cbm.SETNAM
	; source: userdb.p8:94   cbm.OPEN()
	jsr  cbm.OPEN
	; source: userdb.p8:96   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: userdb.p8:97   if status != 0 {
	lda  p8v_status
	beq  p8_label_gen_308_afterif
	; source: userdb.p8:98   return false
	lda  #0
	rts
p8_label_gen_308_afterif
	; source: userdb.p8:101   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: userdb.p8:105   sub close_rel() {

p8s_close_rel	.proc
; statements
	; source: userdb.p8:106   cbm.CLOSE(REL_CHANNEL)
	lda  #2
	jsr  cbm.CLOSE
	; source: userdb.p8:107   cbm.CLRCHN()
	jmp  cbm.CLRCHN
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: userdb.p8:112   sub seek_record(ubyte record_num) -> bool {

p8s_seek_record	.proc
p8v_record_num 	= 21 	; zp ubyte
p8v_rec_str 	= 22 	; zp uword
p8v_i 	= 24 	; zp uword
p8v_status 	= 164 	; zp ubyte
; simple int arg(s) passed via cpu register(s)
	sta  p8v_record_num
; statements
	; source: userdb.p8:124   uword rec_str = conv.str_ub(record_num)
	; source: userdb.p8:125   uword i = 0
	; source: userdb.p8:134   ubyte status = cbm.READST()
	; source: userdb.p8:114   cbm.CHKOUT(REL_CHANNEL)
	ldx  #2
	jsr  cbm.CHKOUT
	; source: userdb.p8:118   cbm.CHROUT($52)  ; 'R'
	lda  #$52
	jsr  cbm.CHROUT
	; source: userdb.p8:119   cbm.CHROUT($23)  ; '#'
	lda  #$23
	jsr  cbm.CHROUT
	; source: userdb.p8:120   cbm.CHROUT(REL_CHANNEL + $30)  ; Channel number as ASCII
	lda  #$32
	jsr  cbm.CHROUT
	; source: userdb.p8:121   cbm.CHROUT($2c)  ; ','
	lda  #$2c
	jsr  cbm.CHROUT
	; source: userdb.p8:124   uword rec_str = conv.str_ub(record_num)
	lda  p8v_record_num
	jsr  conv.str_ub
	sta  p8v_rec_str
	sty  p8v_rec_str+1
	; source: userdb.p8:125   uword i = 0
	lda  #0
	sta  p8v_i
	sta  p8v_i+1
	; source: userdb.p8:126   while i < strings.length(rec_str) {
p8_label_gen_61_whileloop
	ldy  p8v_rec_str+1
	lda  p8v_rec_str
	jsr  strings.length
	tya
	sta  P8ZP_SCRATCH_W2
	lda  #0
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8v_i+1
	lda  p8v_i
	cmp  P8ZP_SCRATCH_W2
	tya
	sbc  P8ZP_SCRATCH_W2+1
	bcs  p8_label_gen_62_afterwhile
	; source: userdb.p8:127   cbm.CHROUT(@(rec_str + i))
	lda  p8b_userdb.p8s_seek_record.p8v_rec_str
	sta  P8ZP_SCRATCH_W2
	lda  p8b_userdb.p8s_seek_record.p8v_rec_str+1
	clc
	adc  p8b_userdb.p8s_seek_record.p8v_i+1
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8b_userdb.p8s_seek_record.p8v_i
	lda  (P8ZP_SCRATCH_W2),y
	jsr  cbm.CHROUT
	; source: userdb.p8:128   i++
	inc  p8v_i
	bne  +
	inc  p8v_i+1
+
	; source: userdb.p8:126   while i < strings.length(rec_str) {
	jmp  p8_label_gen_61_whileloop
p8_label_gen_62_afterwhile
	; source: userdb.p8:131   cbm.CHROUT($0d)  ; Carriage return
	lda  #13
	jsr  cbm.CHROUT
	; source: userdb.p8:134   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: userdb.p8:135   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: userdb.p8:137   return status == 0
	lda  p8v_status
	beq  +
	lda  #1
+                           eor  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: userdb.p8:141   sub read_record(ubyte record_num, uword buffer) -> bool {

p8s_read_record	.proc
p8v_record_num 	= 26 	; zp ubyte
p8v_i 	= 27 	; zp uword
p8v_ch 	= 29 	; zp ubyte
p8v_buffer 	= 30 	; zp uword
; statements
	; source: userdb.p8:158   ubyte ch = cbm.CHRIN()
	; source: userdb.p8:156   uword i = 0
	; source: userdb.p8:142   if not open_rel() {
	jsr  p8b_userdb.p8s_open_rel
	cmp  #0
	bne  p8_label_gen_309_afterif
	; source: userdb.p8:143   return false
	lda  #0
	rts
p8_label_gen_309_afterif
	; source: userdb.p8:147   if not seek_record(record_num) {
	lda  p8v_record_num
	jsr  p8b_userdb.p8s_seek_record
	cmp  #0
	bne  p8_label_gen_310_afterif
	; source: userdb.p8:148   close_rel()
	jsr  p8b_userdb.p8s_close_rel
	; source: userdb.p8:149   return false
	lda  #0
	rts
p8_label_gen_310_afterif
	; source: userdb.p8:153   cbm.CHKIN(REL_CHANNEL)
	ldx  #2
	jsr  cbm.CHKIN
	; source: userdb.p8:156   uword i = 0
	lda  #0
	sta  p8v_i
	sta  p8v_i+1
	; source: userdb.p8:157   while i < RECORD_SIZE {
p8_label_gen_63_whileloop
	ldy  p8v_i+1
	lda  p8v_i
	cmp  #<$40
	tya
	sbc  #>$40
	bcs  p8_label_gen_64_afterwhile
	; source: userdb.p8:158   ubyte ch = cbm.CHRIN()
	jsr  cbm.CHRIN
	sta  p8v_ch
	; source: userdb.p8:159   @(buffer + i) = ch
	tax
	lda  p8b_userdb.p8s_read_record.p8v_buffer
	sta  P8ZP_SCRATCH_W2
	lda  p8b_userdb.p8s_read_record.p8v_buffer+1
	clc
	adc  p8b_userdb.p8s_read_record.p8v_i+1
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8b_userdb.p8s_read_record.p8v_i
	txa
	sta  (P8ZP_SCRATCH_W2),y
	; source: userdb.p8:160   i++
	inc  p8v_i
	bne  +
	inc  p8v_i+1
+
	; source: userdb.p8:157   while i < RECORD_SIZE {
	jmp  p8_label_gen_63_whileloop
p8_label_gen_64_afterwhile
	; source: userdb.p8:163   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: userdb.p8:164   close_rel()
	jsr  p8b_userdb.p8s_close_rel
	; source: userdb.p8:166   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: userdb.p8:199   sub hash_password(uword password, uword salt, uword hash_buffer) {

p8s_hash_password	.proc
p8v_salt_byte 	= 41 	; zp ubyte
p8v_salt 	= 42 	; zp uword
p8v_pwd_len 	= 44 	; zp ubyte
p8v_pwd_byte 	= 45 	; zp ubyte
p8v_password 	= 46 	; zp uword
p8v_j 	= 48 	; zp uword
p8v_i 	= 50 	; zp uword
p8v_hash_buffer 	= 52 	; zp uword
; statements
	; source: userdb.p8:223   ubyte salt_byte = @(salt + (i % SALT_SIZE))
	; source: userdb.p8:214   ubyte pwd_byte = 0
	; source: userdb.p8:201   ubyte pwd_len = strings.length(password)
	; source: userdb.p8:202   uword i = 0
	; source: userdb.p8:203   uword j = 0
	; source: userdb.p8:201   ubyte pwd_len = strings.length(password)
	ldy  p8v_password+1
	lda  p8v_password
	jsr  strings.length
	sty  p8v_pwd_len
	; source: userdb.p8:202   uword i = 0
	lda  #0
	sta  p8v_i
	sta  p8v_i+1
	; source: userdb.p8:203   uword j = 0
	lda  #0
	sta  p8v_j
	sta  p8v_j+1
	; source: userdb.p8:206   while i < PASSWORD_HASH_SIZE {
p8_label_gen_67_whileloop
	ldy  p8v_i+1
	lda  p8v_i
	cmp  #<$10
	tya
	sbc  #>$10
	bcs  p8_label_gen_68_afterwhile
	; source: userdb.p8:207   @(hash_buffer + i) = 0
	lda  #0
	tax
	lda  p8b_userdb.p8s_hash_password.p8v_hash_buffer
	sta  P8ZP_SCRATCH_W2
	lda  p8b_userdb.p8s_hash_password.p8v_hash_buffer+1
	clc
	adc  p8b_userdb.p8s_hash_password.p8v_i+1
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8b_userdb.p8s_hash_password.p8v_i
	txa
	sta  (P8ZP_SCRATCH_W2),y
	; source: userdb.p8:208   i++
	inc  p8v_i
	bne  +
	inc  p8v_i+1
+
	; source: userdb.p8:206   while i < PASSWORD_HASH_SIZE {
	jmp  p8_label_gen_67_whileloop
p8_label_gen_68_afterwhile
	; source: userdb.p8:212   i = 0
	lda  #0
	sta  p8v_i
	sta  p8v_i+1
	; source: userdb.p8:213   while i < PASSWORD_HASH_SIZE {
p8_label_gen_69_whileloop
	ldy  p8v_i+1
	lda  p8v_i
	cmp  #<$10
	tya
	sbc  #>$10
	bcs  p8_label_gen_70_afterwhile
	; source: userdb.p8:214   ubyte pwd_byte = 0
	lda  #0
	sta  p8v_pwd_byte
	; source: userdb.p8:215   if j < pwd_len {
	lda  p8v_pwd_len
	sta  P8ZP_SCRATCH_W2
	lda  #0
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8v_j+1
	lda  p8v_j
	cmp  P8ZP_SCRATCH_W2
	tya
	sbc  P8ZP_SCRATCH_W2+1
	bcs  p8_label_gen_311_afterif
	; source: userdb.p8:216   pwd_byte = @(password + j)
	lda  p8b_userdb.p8s_hash_password.p8v_password
	sta  P8ZP_SCRATCH_W2
	lda  p8b_userdb.p8s_hash_password.p8v_password+1
	clc
	adc  p8b_userdb.p8s_hash_password.p8v_j+1
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8b_userdb.p8s_hash_password.p8v_j
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8v_pwd_byte
	; source: userdb.p8:217   j++
	inc  p8v_j
	bne  +
	inc  p8v_j+1
+
	; source: userdb.p8:218   if j >= pwd_len {
	lda  p8v_pwd_len
	sta  P8ZP_SCRATCH_W2
	lda  #0
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8v_j+1
	lda  p8v_j
	cmp  P8ZP_SCRATCH_W2
	tya
	sbc  P8ZP_SCRATCH_W2+1
	bcc  p8_label_gen_312_afterif
	; source: userdb.p8:219   j = 0  ; Cycle through password
	lda  #0
	sta  p8v_j
	sta  p8v_j+1
p8_label_gen_312_afterif
p8_label_gen_311_afterif
	; source: userdb.p8:223   ubyte salt_byte = @(salt + (i % SALT_SIZE))
	ldy  p8v_i+1
	lda  p8v_i
	and  #<7
	ldy  #0
	clc
	adc  p8v_salt
	tax
	tya
	adc  p8v_salt+1
	tay
	txa
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8v_salt_byte
	; source: userdb.p8:224   @(hash_buffer + i) = pwd_byte ^ salt_byte ^ (i as ubyte)
	lda  p8v_pwd_byte
	eor  p8v_salt_byte
	pha
	lda  p8v_i
	sta  P8ZP_SCRATCH_B1
	pla
	eor  P8ZP_SCRATCH_B1
	tax
	lda  p8b_userdb.p8s_hash_password.p8v_hash_buffer
	sta  P8ZP_SCRATCH_W2
	lda  p8b_userdb.p8s_hash_password.p8v_hash_buffer+1
	clc
	adc  p8b_userdb.p8s_hash_password.p8v_i+1
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8b_userdb.p8s_hash_password.p8v_i
	txa
	sta  (P8ZP_SCRATCH_W2),y
	; source: userdb.p8:225   i++
	inc  p8v_i
	bne  +
	inc  p8v_i+1
+
	; source: userdb.p8:213   while i < PASSWORD_HASH_SIZE {
	jmp  p8_label_gen_69_whileloop
p8_label_gen_70_afterwhile
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: userdb.p8:231   sub find_user(uword username) -> ubyte {

p8s_find_user	.proc
p8v_usr_char 	= 57 	; zp ubyte
p8v_username 	= 58 	; zp uword
p8v_rec_char 	= 60 	; zp ubyte
p8v_match 	= 61 	; zp bool
p8v_j 	= 62 	; zp ubyte
p8v_i 	= 63 	; zp ubyte
; simple int arg(s) passed via cpu register(s)
	sta  p8v_username
	sty  p8v_username+1
; statements
	; source: userdb.p8:241   ubyte j = 0
	; source: userdb.p8:240   bool match = true
	; source: userdb.p8:244   ubyte usr_char = @(username + j)
	; source: userdb.p8:243   ubyte rec_char = record_buffer[j]
	; source: userdb.p8:232   ubyte[RECORD_SIZE] record_buffer
	; source: userdb.p8:233   ubyte i = 0
	lda  #0
	sta  p8v_i
	; source: userdb.p8:235   while i < max_records {
p8_label_gen_75_whileloop
	ldy  #0
	lda  p8v_i
	cmp  p8b_userdb.p8v_max_records
	tya
	sbc  p8b_userdb.p8v_max_records+1
	bcs  p8_label_gen_76_afterwhile
	; source: userdb.p8:236   if read_record(i, &record_buffer) {
	lda  p8v_i
	sta  p8b_userdb.p8s_read_record.p8v_record_num
	lda  #<p8v_record_buffer
	ldy  #>p8v_record_buffer
	sta  p8b_userdb.p8s_read_record.p8v_buffer
	sty  p8b_userdb.p8s_read_record.p8v_buffer+1
	jsr  p8b_userdb.p8s_read_record
	cmp  #0
	beq  p8_label_gen_313_afterif
	; source: userdb.p8:238   if record_buffer[0] != 0 {
	lda  p8v_record_buffer+0
	beq  p8_label_gen_314_afterif
	; source: userdb.p8:240   bool match = true
	lda  #1
	sta  p8v_match
	; source: userdb.p8:241   ubyte j = 0
	lda  #0
	sta  p8v_j
	; source: userdb.p8:242   while j < USERNAME_MAX {
p8_label_gen_73_whileloop
	lda  p8v_j
	cmp  #20
	bcs  p8_label_gen_74_afterwhile
	; source: userdb.p8:243   ubyte rec_char = record_buffer[j]
	ldy  p8v_j
	lda  p8v_record_buffer,y
	sta  p8v_rec_char
	; source: userdb.p8:244   ubyte usr_char = @(username + j)
	ldy  p8v_j
	lda  (p8v_username),y
	sta  p8v_usr_char
	; source: userdb.p8:246   if rec_char == 0 and usr_char == 0 {
	lda  p8v_rec_char
	ora  p8v_usr_char
	beq  p8_label_gen_71_after
	; source: userdb.p8:249   if rec_char != usr_char {
	lda  p8v_rec_char
	cmp  p8v_usr_char
	beq  p8_label_gen_315_afterif
	; source: userdb.p8:250   match = false
	lda  #0
	sta  p8v_match
	; source: userdb.p8:251   break
	jmp  p8_label_gen_72_after
p8_label_gen_315_afterif
	; source: userdb.p8:253   j++
	inc  p8v_j
	; source: userdb.p8:242   while j < USERNAME_MAX {
	jmp  p8_label_gen_73_whileloop
p8_label_gen_74_afterwhile
	; source: userdb.p8:251   break
p8_label_gen_72_after
	; source: userdb.p8:247   break  ; Both ended, match
p8_label_gen_71_after
	; source: userdb.p8:256   if match {
	lda  p8v_match
	beq  p8_label_gen_316_afterif
	; source: userdb.p8:257   return i
	lda  p8v_i
	rts
p8_label_gen_316_afterif
p8_label_gen_314_afterif
p8_label_gen_313_afterif
	; source: userdb.p8:261   i++
	inc  p8v_i
	; source: userdb.p8:235   while i < max_records {
	jmp  p8_label_gen_75_whileloop
p8_label_gen_76_afterwhile
	; source: userdb.p8:264   return 255  ; Not found
	lda  #$ff
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_record_buffer	.fill  64
	.send BSS
	.pend
	; source: userdb.p8:340   sub verify_password(uword username, uword password) -> bool {

p8s_verify_password	.proc
p8v_username 	= 17 	; zp uword
p8v_password 	= 19 	; zp uword
p8v_record_num 	= 146 	; zp ubyte
p8v_i3 	= 150 	; zp ubyte
; statements
	; source: userdb.p8:341   ubyte record_num = find_user(username)
	; source: userdb.p8:347   ubyte[RECORD_SIZE] record_buffer
	; source: userdb.p8:358   ubyte[PASSWORD_HASH_SIZE] computed_hash
	; source: userdb.p8:362   ubyte i3 = 0
	; source: userdb.p8:341   ubyte record_num = find_user(username)
	ldy  p8v_username+1
	lda  p8v_username
	jsr  p8b_userdb.p8s_find_user
	sta  p8v_record_num
	; source: userdb.p8:342   if record_num == 255 {
	cmp  #255
	bne  p8_label_gen_317_afterif
	; source: userdb.p8:343   return false  ; User not found
	lda  #0
	rts
p8_label_gen_317_afterif
	; source: userdb.p8:348   if not read_record(record_num, &record_buffer) {
	lda  p8v_record_num
	sta  p8b_userdb.p8s_read_record.p8v_record_num
	lda  #<p8v_record_buffer
	ldy  #>p8v_record_buffer
	sta  p8b_userdb.p8s_read_record.p8v_buffer
	sty  p8b_userdb.p8s_read_record.p8v_buffer+1
	jsr  p8b_userdb.p8s_read_record
	cmp  #0
	bne  p8_label_gen_318_afterif
	; source: userdb.p8:349   return false
	lda  #0
	rts
p8_label_gen_318_afterif
	; source: userdb.p8:353   if (record_buffer[USERNAME_MAX + SALT_SIZE + PASSWORD_HASH_SIZE + 1] & $01) == 0 {
	lda  p8v_record_buffer+45
	and  #1
	bne  p8_label_gen_319_afterif
	; source: userdb.p8:354   return false  ; User not active
	lda  #0
	rts
p8_label_gen_319_afterif
	; source: userdb.p8:359   hash_password(password, &record_buffer[USERNAME_MAX], &computed_hash)
	lda  p8v_password
	ldy  p8v_password+1
	sta  p8b_userdb.p8s_hash_password.p8v_password
	sty  p8b_userdb.p8s_hash_password.p8v_password+1
	lda  #<(p8v_record_buffer + 20)
	ldy  #>(p8v_record_buffer + 20)
	sta  p8b_userdb.p8s_hash_password.p8v_salt
	sty  p8b_userdb.p8s_hash_password.p8v_salt+1
	lda  #<p8v_computed_hash
	ldy  #>p8v_computed_hash
	sta  p8b_userdb.p8s_hash_password.p8v_hash_buffer
	sty  p8b_userdb.p8s_hash_password.p8v_hash_buffer+1
	jsr  p8b_userdb.p8s_hash_password
	; source: userdb.p8:362   ubyte i3 = 0
	lda  #0
	sta  p8v_i3
	; source: userdb.p8:363   while i3 < PASSWORD_HASH_SIZE {
p8_label_gen_85_whileloop
	lda  p8v_i3
	cmp  #16
	bcs  p8_label_gen_86_afterwhile
	; source: userdb.p8:364   if computed_hash[i3] != record_buffer[USERNAME_MAX + SALT_SIZE + i3] {
	ldy  p8v_i3
	lda  p8v_computed_hash,y
	pha
	lda  p8v_i3
	clc
	adc  #$1c
	tay
	lda  p8v_record_buffer,y
	sta  P8ZP_SCRATCH_REG
	pla
	cmp  P8ZP_SCRATCH_REG
	beq  p8_label_gen_320_afterif
	; source: userdb.p8:365   return false
	lda  #0
	rts
p8_label_gen_320_afterif
	; source: userdb.p8:367   i3++
	inc  p8v_i3
	; source: userdb.p8:363   while i3 < PASSWORD_HASH_SIZE {
	jmp  p8_label_gen_85_whileloop
p8_label_gen_86_afterwhile
	; source: userdb.p8:370   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_computed_hash	.fill  16
p8v_record_buffer	.fill  64
	.send BSS
	.pend
	; source: userdb.p8:374   sub get_user_level(uword username) -> ubyte {

p8s_get_user_level	.proc
p8v_username 	= 54 	; zp uword
p8v_record_num 	= 56 	; zp ubyte
; simple int arg(s) passed via cpu register(s)
	sta  p8v_username
	sty  p8v_username+1
; statements
	; source: userdb.p8:375   ubyte record_num = find_user(username)
	; source: userdb.p8:380   ubyte[RECORD_SIZE] record_buffer
	; source: userdb.p8:375   ubyte record_num = find_user(username)
	jsr  p8b_userdb.p8s_find_user
	sta  p8v_record_num
	; source: userdb.p8:376   if record_num == 255 {
	cmp  #255
	bne  p8_label_gen_321_afterif
	; source: userdb.p8:377   return 0  ; Default level
	lda  #0
	rts
p8_label_gen_321_afterif
	; source: userdb.p8:381   if not read_record(record_num, &record_buffer) {
	lda  p8v_record_num
	sta  p8b_userdb.p8s_read_record.p8v_record_num
	lda  #<p8v_record_buffer
	ldy  #>p8v_record_buffer
	sta  p8b_userdb.p8s_read_record.p8v_buffer
	sty  p8b_userdb.p8s_read_record.p8v_buffer+1
	jsr  p8b_userdb.p8s_read_record
	cmp  #0
	bne  p8_label_gen_322_afterif
	; source: userdb.p8:382   return 0
	lda  #0
	rts
p8_label_gen_322_afterif
	; source: userdb.p8:385   return record_buffer[USERNAME_MAX + SALT_SIZE + PASSWORD_HASH_SIZE]
	lda  p8v_record_buffer+44
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_record_buffer	.fill  64
	.send BSS
	.pend
prog8_init_vars	.block
	; source: userdb.p8:15   uword REL_FILENAME = "bbsusers"
	lda  #<prog8_interned_strings.string_195
	ldy  #>prog8_interned_strings.string_195
	sta  p8b_userdb.p8v_REL_FILENAME
	sty  p8b_userdb.p8v_REL_FILENAME+1
	; source: userdb.p8:31   ubyte @shared db_initialized = false
	lda  #0
	sta  p8b_userdb.p8v_db_initialized
	; source: userdb.p8:32   uword @shared max_records = 100  ; Maximum number of user records
	lda  #<$64
	ldy  #>$64
	sta  p8b_userdb.p8v_max_records
	sty  p8b_userdb.p8v_max_records+1
	rts
	.bend
	.pend

; ---- block: 'p8b_menu' ----
p8b_menu	.proc
	; source: menu.p8:14   menu {
	p8c_MENU_BOARDS = 1
	p8c_MENU_FILES = 3
	p8c_MENU_GAMES = 4
	p8c_MENU_MAIN = 0
	p8c_MENU_MESSAGING = 2
	p8c_MENU_SYSOP = 5

; non-zeropage variables
	.section BSS
p8v_current_menu	.byte  ?
	.send BSS

	; source: menu.p8:17   const ubyte MENU_MAIN = 0
	; source: menu.p8:18   const ubyte MENU_BOARDS = 1
	; source: menu.p8:19   const ubyte MENU_MESSAGING = 2
	; source: menu.p8:20   const ubyte MENU_FILES = 3
	; source: menu.p8:21   const ubyte MENU_GAMES = 4
	; source: menu.p8:22   const ubyte MENU_SYSOP = 5
	; source: menu.p8:24   ubyte @shared current_menu = MENU_MAIN
	; source: menu.p8:27   sub show_main_menu() {

p8s_show_main_menu	.proc
; statements
	; source: menu.p8:37   ubyte user_level = login.get_user_level()
	; source: menu.p8:28   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:29   session.send_line("=== Main Menu ===")
	ldy  #>prog8_interned_strings.string_86
	lda  #<prog8_interned_strings.string_86
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:30   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:31   session.send_line("1. Message Boards")
	ldy  #>prog8_interned_strings.string_87
	lda  #<prog8_interned_strings.string_87
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:32   session.send_line("2. Private Messages")
	ldy  #>prog8_interned_strings.string_88
	lda  #<prog8_interned_strings.string_88
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:33   session.send_line("3. File Areas")
	ldy  #>prog8_interned_strings.string_89
	lda  #<prog8_interned_strings.string_89
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:34   session.send_line("4. Games")
	ldy  #>prog8_interned_strings.string_90
	lda  #<prog8_interned_strings.string_90
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:37   ubyte user_level = login.get_user_level()
	lda  p8b_login.p8v_current_user_level
	sta  p8v_user_level
	; source: menu.p8:38   if user_level >= 7 {  ; Administrator or SysOp
	cmp  #7
	bcc  p8_label_gen_323_afterif
	; source: menu.p8:39   session.send_line("5. SysOp Functions")
	ldy  #>prog8_interned_strings.string_91
	lda  #<prog8_interned_strings.string_91
	jsr  p8b_session.p8s_send_line
p8_label_gen_323_afterif
	; source: menu.p8:42   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:43   session.send_line("0. Logout")
	ldy  #>prog8_interned_strings.string_92
	lda  #<prog8_interned_strings.string_92
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:44   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:45   session.send_string("Enter choice: ")
	ldy  #>prog8_interned_strings.string_93
	lda  #<prog8_interned_strings.string_93
	jmp  p8b_session.p8s_send_string
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_user_level	.byte  ?
	.send BSS
	.pend
	; source: menu.p8:50   sub process_selection(uword input) -> bool {

p8s_process_selection	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_input
	sty  p8v_input+1
; statements
	; source: menu.p8:56   ubyte choice = @(input)
	; source: menu.p8:64   ubyte user_level = login.get_user_level()
	; source: menu.p8:51   if strings.length(input) == 0 {
	jsr  strings.length
	tya
	bne  p8_label_gen_324_afterif
	; source: menu.p8:52   return true
	lda  #1
	rts
p8_label_gen_324_afterif
	; source: menu.p8:56   ubyte choice = @(input)
	lda  p8v_input
	ldy  p8v_input+1
	sta  P8ZP_SCRATCH_PTR
	sty  P8ZP_SCRATCH_PTR+1
	ldy  #0
	lda  (P8ZP_SCRATCH_PTR),y
	sta  p8v_choice
	; source: menu.p8:57   if choice >= $30 and choice <= $39 {  ; ASCII '0'-'9'
	cmp  #48
	rol  a
	and  #1
	beq  p8_label_gen_325_shortcut
	lda  p8v_choice
	cmp  #58
	rol  a
	and  #1
	eor  #1
p8_label_gen_325_shortcut
	beq  p8_label_gen_327_else
	; source: menu.p8:58   choice = choice - $30  ; Convert to number
	lda  p8v_choice
	sec
	sbc  #48
	sta  p8v_choice
	jmp  p8_label_gen_326_afterif
p8_label_gen_327_else
	; source: menu.p8:60   session.send_line("Invalid choice. Please enter a number.")
	ldy  #>prog8_interned_strings.string_94
	lda  #<prog8_interned_strings.string_94
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:61   return true
	lda  #1
	rts
p8_label_gen_326_afterif
	; source: menu.p8:64   ubyte user_level = login.get_user_level()
	lda  p8b_login.p8v_current_user_level
	sta  p8v_user_level
	; source: menu.p8:67   if choice == 0 {
	lda  p8v_choice
	bne  p8_label_gen_329_else
	; source: menu.p8:69   session.send_line("Logging out...")
	ldy  #>prog8_interned_strings.string_95
	lda  #<prog8_interned_strings.string_95
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:70   login.logout()
	jsr  p8b_login.p8s_logout
	; source: menu.p8:71   return false
	lda  #0
	rts
p8_label_gen_329_else
	; source: menu.p8:73   else if choice == 1 {
	lda  p8v_choice
	cmp  #1
	bne  p8_label_gen_331_else
	; source: menu.p8:102   boards.show_menu()
	jsr  p8b_boards.p8s_show_menu
	jmp  p8_label_gen_330_afterif
p8_label_gen_331_else
	; source: menu.p8:77   else if choice == 2 {
	lda  p8v_choice
	cmp  #2
	bne  p8_label_gen_333_else
	; source: menu.p8:107   messaging.show_menu()
	jsr  p8b_messaging.p8s_show_menu
	jmp  p8_label_gen_332_afterif
p8_label_gen_333_else
	; source: menu.p8:81   else if choice == 3 {
	lda  p8v_choice
	cmp  #3
	bne  p8_label_gen_335_else
	; source: menu.p8:112   files.show_menu()
	jsr  p8b_files.p8s_show_menu
	jmp  p8_label_gen_334_afterif
p8_label_gen_335_else
	; source: menu.p8:85   else if choice == 4 {
	lda  p8v_choice
	cmp  #4
	bne  p8_label_gen_337_else
	; source: menu.p8:87   show_games_menu()
	jsr  p8b_menu.p8s_show_games_menu
	jmp  p8_label_gen_336_afterif
p8_label_gen_337_else
	; source: menu.p8:89   else if choice == 5 and user_level >= 7 {
	lda  p8v_choice
	cmp  #5
	bne  p8_label_gen_340_else
	lda  #1
	jmp  p8_label_gen_339_afterif
p8_label_gen_340_else
	lda  #0
p8_label_gen_339_afterif
	beq  p8_label_gen_338_shortcut
	lda  p8v_user_level
	cmp  #7
	rol  a
	and  #1
p8_label_gen_338_shortcut
	beq  p8_label_gen_342_else
	; source: menu.p8:91   show_sysop_menu()
	jsr  p8b_menu.p8s_show_sysop_menu
	jmp  p8_label_gen_341_afterif
p8_label_gen_342_else
	; source: menu.p8:94   session.send_line("Invalid choice.")
	ldy  #>prog8_interned_strings.string_96
	lda  #<prog8_interned_strings.string_96
	jsr  p8b_session.p8s_send_line
p8_label_gen_341_afterif
p8_label_gen_336_afterif
p8_label_gen_334_afterif
p8_label_gen_332_afterif
p8_label_gen_330_afterif
p8_label_gen_328_afterif
	; source: menu.p8:97   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_choice	.byte  ?
p8v_input	.word  ?
p8v_user_level	.byte  ?
	.send BSS
	.pend
	; source: menu.p8:116   sub show_games_menu() {

p8s_show_games_menu	.proc
; statements
	; source: menu.p8:117   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:118   session.send_line("=== Games ===")
	ldy  #>prog8_interned_strings.string_97
	lda  #<prog8_interned_strings.string_97
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:119   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:120   session.send_line("Games are not yet implemented.")
	ldy  #>prog8_interned_strings.string_98
	lda  #<prog8_interned_strings.string_98
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:121   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:122   session.send_string("Press Enter to continue...")
	ldy  #>prog8_interned_strings.string_99
	lda  #<prog8_interned_strings.string_99
	jsr  p8b_session.p8s_send_string
	; source: menu.p8:123   session.read_line()
	jmp  p8b_session.p8s_read_line
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: menu.p8:127   sub show_sysop_menu() {

p8s_show_sysop_menu	.proc
; statements
	; source: menu.p8:128   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:129   session.send_line("=== SysOp Functions ===")
	ldy  #>prog8_interned_strings.string_100
	lda  #<prog8_interned_strings.string_100
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:130   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:131   session.send_line("SysOp functions are not yet implemented.")
	ldy  #>prog8_interned_strings.string_101
	lda  #<prog8_interned_strings.string_101
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:132   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:133   session.send_string("Press Enter to continue...")
	ldy  #>prog8_interned_strings.string_99
	lda  #<prog8_interned_strings.string_99
	jsr  p8b_session.p8s_send_string
	; source: menu.p8:134   session.read_line()
	jmp  p8b_session.p8s_read_line
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: menu.p8:139   sub run() {

p8s_run	.proc
; statements
	; source: menu.p8:148   uword input = session.get_input_line()
	; source: menu.p8:140   bool running = true
	lda  #1
	sta  p8v_running
	; source: menu.p8:142   while running and session.is_active() {
p8_label_gen_89_whileloop
	lda  p8v_running
	beq  p8_label_gen_343_shortcut
	jsr  p8b_session.p8s_is_active
p8_label_gen_343_shortcut
	beq  p8_label_gen_90_afterwhile
	; source: menu.p8:144   show_main_menu()
	jsr  p8b_menu.p8s_show_main_menu
	; source: menu.p8:147   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_345_else
	; source: menu.p8:148   uword input = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_input
	sty  p8v_input+1
	; source: menu.p8:151   if not process_selection(input) {
	jsr  p8b_menu.p8s_process_selection
	cmp  #0
	bne  p8_label_gen_346_afterif
	; source: menu.p8:153   running = false
	lda  #0
	sta  p8v_running
	; source: menu.p8:154   break
	jmp  p8_label_gen_87_after
p8_label_gen_346_afterif
	jmp  p8_label_gen_344_afterif
p8_label_gen_345_else
	; source: menu.p8:158   running = false
	lda  #0
	sta  p8v_running
	; source: menu.p8:159   break
	jmp  p8_label_gen_88_after
p8_label_gen_344_afterif
	; source: menu.p8:142   while running and session.is_active() {
	jmp  p8_label_gen_89_whileloop
p8_label_gen_90_afterwhile
	; source: menu.p8:159   break
p8_label_gen_88_after
	; source: menu.p8:154   break
p8_label_gen_87_after
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_input	.word  ?
p8v_running	.byte  ?
	.send BSS
	.pend
	; source: menu.p8:165   sub show_info() {

p8s_show_info	.proc
; statements
	; source: menu.p8:170   uword bbs_name = config.getdirective("bbsname")
	; source: menu.p8:178   uword sysop_name = config.getdirective("sysopname")
	; source: menu.p8:189   uword username = login.get_username()
	; source: menu.p8:190   ubyte level = login.get_user_level()
	; source: menu.p8:195   uword level_str = conv.str_ub(level)
	; source: menu.p8:166   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:167   session.send_line("=== BBS Information ===")
	ldy  #>prog8_interned_strings.string_102
	lda  #<prog8_interned_strings.string_102
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:168   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:170   uword bbs_name = config.getdirective("bbsname")
	ldy  #>prog8_interned_strings.string_40
	lda  #<prog8_interned_strings.string_40
	jsr  p8b_config.p8s_getdirective
	sta  p8v_bbs_name
	sty  p8v_bbs_name+1
	; source: menu.p8:171   if strings.length(bbs_name) == 0 {
	jsr  strings.length
	tya
	bne  p8_label_gen_347_afterif
	; source: menu.p8:172   bbs_name = "ColorX128 BBS"
	lda  #<prog8_interned_strings.string_41
	ldy  #>prog8_interned_strings.string_41
	sta  p8v_bbs_name
	sty  p8v_bbs_name+1
p8_label_gen_347_afterif
	; source: menu.p8:174   session.send_string("BBS Name: ")
	ldy  #>prog8_interned_strings.string_39
	lda  #<prog8_interned_strings.string_39
	jsr  p8b_session.p8s_send_string
	; source: menu.p8:175   session.send_string(bbs_name)
	ldy  p8v_bbs_name+1
	lda  p8v_bbs_name
	jsr  p8b_session.p8s_send_string
	; source: menu.p8:176   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:178   uword sysop_name = config.getdirective("sysopname")
	ldy  #>prog8_interned_strings.string_43
	lda  #<prog8_interned_strings.string_43
	jsr  p8b_config.p8s_getdirective
	sta  p8v_sysop_name
	sty  p8v_sysop_name+1
	; source: menu.p8:179   if strings.length(sysop_name) == 0 {
	jsr  strings.length
	tya
	bne  p8_label_gen_348_afterif
	; source: menu.p8:180   sysop_name = "SysOp"
	lda  #<prog8_interned_strings.string_44
	ldy  #>prog8_interned_strings.string_44
	sta  p8v_sysop_name
	sty  p8v_sysop_name+1
p8_label_gen_348_afterif
	; source: menu.p8:182   session.send_string("SysOp: ")
	ldy  #>prog8_interned_strings.string_103
	lda  #<prog8_interned_strings.string_103
	jsr  p8b_session.p8s_send_string
	; source: menu.p8:183   session.send_string(sysop_name)
	ldy  p8v_sysop_name+1
	lda  p8v_sysop_name
	jsr  p8b_session.p8s_send_string
	; source: menu.p8:184   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:186   session.send_line("Status: Online")
	ldy  #>prog8_interned_strings.string_104
	lda  #<prog8_interned_strings.string_104
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:187   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:189   uword username = login.get_username()
	lda  p8b_login.p8v_current_username
	ldy  p8b_login.p8v_current_username+1
	sta  p8v_username
	sty  p8v_username+1
	; source: menu.p8:190   ubyte level = login.get_user_level()
	lda  p8b_login.p8v_current_user_level
	sta  p8v_level
	; source: menu.p8:191   session.send_string("Logged in as: ")
	ldy  #>prog8_interned_strings.string_105
	lda  #<prog8_interned_strings.string_105
	jsr  p8b_session.p8s_send_string
	; source: menu.p8:192   session.send_string(username)
	ldy  p8v_username+1
	lda  p8v_username
	jsr  p8b_session.p8s_send_string
	; source: menu.p8:193   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:194   session.send_string("User Level: ")
	ldy  #>prog8_interned_strings.string_106
	lda  #<prog8_interned_strings.string_106
	jsr  p8b_session.p8s_send_string
	; source: menu.p8:195   uword level_str = conv.str_ub(level)
	lda  p8v_level
	jsr  conv.str_ub
	sta  p8v_level_str
	sty  p8v_level_str+1
	; source: menu.p8:196   session.send_string(level_str)
	jsr  p8b_session.p8s_send_string
	; source: menu.p8:197   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: menu.p8:198   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jmp  p8b_session.p8s_send_line
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_bbs_name	.word  ?
p8v_level	.byte  ?
p8v_level_str	.word  ?
p8v_sysop_name	.word  ?
p8v_username	.word  ?
	.send BSS
	.pend
prog8_init_vars	.block
	rts
	.bend
	.pend

; ---- block: 'p8b_boards' ----
p8b_boards	.proc
	; source: boards.p8:13   boards {
	p8c_MSG_AUTHOR_MAX = $14
	p8c_MSG_BOARD_MAX = 10
	p8c_MSG_BODY_MAX = $3c
	p8c_MSG_RECORD_SIZE = $80
	p8c_MSG_SUBJECT_MAX = $28
	p8c_REL_CHANNEL = 3
	p8c_REL_DEVICE = 8
	p8c_REL_SECONDARY = 0

; non-zeropage variables
	.section BSS
p8v_REL_FILENAME	.word  ?
p8v_boards_initialized	.byte  ?
p8v_max_messages	.word  ?
	.send BSS

	; source: boards.p8:15   const ubyte REL_CHANNEL = 3
	; source: boards.p8:16   const ubyte REL_DEVICE = 8
	; source: boards.p8:17   const ubyte REL_SECONDARY = 0
	; source: boards.p8:18   uword REL_FILENAME = "bbsmsgs"
	; source: boards.p8:21   const ubyte MSG_RECORD_SIZE = 128  ; Fixed record size
	; source: boards.p8:22   const ubyte MSG_BOARD_MAX = 10     ; Maximum board name length
	; source: boards.p8:23   const ubyte MSG_AUTHOR_MAX = 20    ; Maximum author name length
	; source: boards.p8:24   const ubyte MSG_SUBJECT_MAX = 40   ; Maximum subject length
	; source: boards.p8:25   const ubyte MSG_BODY_MAX = 60      ; Maximum body length (truncated if longer)
	; source: boards.p8:37   ubyte @shared boards_initialized = false
	; source: boards.p8:38   uword @shared max_messages = 500  ; Maximum number of messages
	; source: boards.p8:41   sub init() -> bool {

p8s_init	.proc
; statements
	; source: boards.p8:62   ubyte status = cbm.READST()
	; source: boards.p8:56   ubyte rel_filename_len = strings.length(rel_filename)
	; source: boards.p8:55   uword rel_filename = "bbsmsgs,L,128,R,500"
	; source: boards.p8:42   diskio.drivenumber = REL_DEVICE
	lda  #8
	sta  diskio.drivenumber
	; source: boards.p8:45   if not diskio.exists(REL_FILENAME) {
	ldy  p8b_boards.p8v_REL_FILENAME+1
	lda  p8b_boards.p8v_REL_FILENAME
	jsr  diskio.exists
	cmp  #0
	bne  p8_label_gen_349_afterif
	; source: boards.p8:47   txt.print("Creating message boards database...")
	ldy  #>prog8_interned_strings.string_107
	lda  #<prog8_interned_strings.string_107
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: boards.p8:51   cbm.SETLFS(REL_CHANNEL, REL_DEVICE, REL_SECONDARY)
	ldy  #0
	ldx  #8
	lda  #3
	jsr  cbm.SETLFS
	; source: boards.p8:55   uword rel_filename = "bbsmsgs,L,128,R,500"
	lda  #<prog8_interned_strings.string_108
	ldy  #>prog8_interned_strings.string_108
	sta  p8v_rel_filename
	sty  p8v_rel_filename+1
	; source: boards.p8:56   ubyte rel_filename_len = strings.length(rel_filename)
	jsr  strings.length
	sty  p8v_rel_filename_len
	; source: boards.p8:57   cbm.SETNAM(rel_filename_len, rel_filename)
	ldy  p8v_rel_filename+1
	ldx  p8v_rel_filename
	lda  p8v_rel_filename_len
	jsr  cbm.SETNAM
	; source: boards.p8:60   cbm.OPEN()
	jsr  cbm.OPEN
	; source: boards.p8:62   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: boards.p8:63   if status != 0 {
	lda  p8v_status
	beq  p8_label_gen_350_afterif
	; source: boards.p8:64   txt.print("Error creating message boards file: ")
	ldy  #>prog8_interned_strings.string_109
	lda  #<prog8_interned_strings.string_109
	jsr  txt.print
	; source: boards.p8:65   txt.print_ub(status)
	lda  p8v_status
	jsr  txt.print_ub
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: boards.p8:67   return false
	lda  #0
	rts
p8_label_gen_350_afterif
	; source: boards.p8:71   cbm.CLOSE(REL_CHANNEL)
	lda  #3
	jsr  cbm.CLOSE
	; source: boards.p8:72   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: boards.p8:74   txt.print("Message boards database created successfully")
	ldy  #>prog8_interned_strings.string_110
	lda  #<prog8_interned_strings.string_110
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
p8_label_gen_349_afterif
	; source: boards.p8:78   boards_initialized = 1
	lda  #1
	sta  p8b_boards.p8v_boards_initialized
	; source: boards.p8:79   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_rel_filename	.word  ?
p8v_rel_filename_len	.byte  ?
p8v_status	.byte  ?
	.send BSS
	.pend
	; source: boards.p8:83   sub open_rel() -> bool {

p8s_open_rel	.proc
; statements
	; source: boards.p8:88   ubyte status = cbm.READST()
	; source: boards.p8:84   cbm.SETLFS(REL_CHANNEL, REL_DEVICE, REL_SECONDARY)
	ldy  #0
	ldx  #8
	lda  #3
	jsr  cbm.SETLFS
	; source: boards.p8:85   cbm.SETNAM(strings.length(REL_FILENAME), REL_FILENAME)
	ldy  p8b_boards.p8v_REL_FILENAME+1
	ldx  p8b_boards.p8v_REL_FILENAME
	txa
	pha
	tya
	pha
	ldy  p8b_boards.p8v_REL_FILENAME+1
	lda  p8b_boards.p8v_REL_FILENAME
	jsr  strings.length
	tya
	sta  P8ZP_SCRATCH_REG
	pla
	tay
	lda  P8ZP_SCRATCH_REG
	pla
	tax
	lda  P8ZP_SCRATCH_REG
	jsr  cbm.SETNAM
	; source: boards.p8:86   cbm.OPEN()
	jsr  cbm.OPEN
	; source: boards.p8:88   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: boards.p8:89   if status != 0 {
	lda  p8v_status
	beq  p8_label_gen_351_afterif
	; source: boards.p8:90   return false
	lda  #0
	rts
p8_label_gen_351_afterif
	; source: boards.p8:93   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_status	.byte  ?
	.send BSS
	.pend
	; source: boards.p8:97   sub close_rel() {

p8s_close_rel	.proc
; statements
	; source: boards.p8:98   cbm.CLOSE(REL_CHANNEL)
	lda  #3
	jsr  cbm.CLOSE
	; source: boards.p8:99   cbm.CLRCHN()
	jmp  cbm.CLRCHN
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: boards.p8:103   sub seek_record(ubyte record_num) -> bool {

p8s_seek_record	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_record_num
; statements
	; source: boards.p8:113   uword rec_str = conv.str_ub(record_num)
	; source: boards.p8:114   uword i = 0
	; source: boards.p8:122   ubyte status = cbm.READST()
	; source: boards.p8:104   cbm.CHKOUT(REL_CHANNEL)
	ldx  #3
	jsr  cbm.CHKOUT
	; source: boards.p8:107   cbm.CHROUT($52)  ; 'R'
	lda  #$52
	jsr  cbm.CHROUT
	; source: boards.p8:108   cbm.CHROUT($23)  ; '#'
	lda  #$23
	jsr  cbm.CHROUT
	; source: boards.p8:109   cbm.CHROUT(REL_CHANNEL + $30)
	lda  #$33
	jsr  cbm.CHROUT
	; source: boards.p8:110   cbm.CHROUT($2c)  ; ','
	lda  #$2c
	jsr  cbm.CHROUT
	; source: boards.p8:113   uword rec_str = conv.str_ub(record_num)
	lda  p8v_record_num
	jsr  conv.str_ub
	sta  p8v_rec_str
	sty  p8v_rec_str+1
	; source: boards.p8:114   uword i = 0
	lda  #0
	sta  p8v_i
	sta  p8v_i+1
	; source: boards.p8:115   while i < strings.length(rec_str) {
p8_label_gen_91_whileloop
	ldy  p8v_rec_str+1
	lda  p8v_rec_str
	jsr  strings.length
	tya
	sta  P8ZP_SCRATCH_W2
	lda  #0
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8v_i+1
	lda  p8v_i
	cmp  P8ZP_SCRATCH_W2
	tya
	sbc  P8ZP_SCRATCH_W2+1
	bcs  p8_label_gen_92_afterwhile
	; source: boards.p8:116   cbm.CHROUT(@(rec_str + i))
	lda  p8b_boards.p8s_seek_record.p8v_rec_str
	sta  P8ZP_SCRATCH_W2
	lda  p8b_boards.p8s_seek_record.p8v_rec_str+1
	clc
	adc  p8b_boards.p8s_seek_record.p8v_i+1
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8b_boards.p8s_seek_record.p8v_i
	lda  (P8ZP_SCRATCH_W2),y
	jsr  cbm.CHROUT
	; source: boards.p8:117   i++
	inc  p8v_i
	bne  +
	inc  p8v_i+1
+
	; source: boards.p8:115   while i < strings.length(rec_str) {
	jmp  p8_label_gen_91_whileloop
p8_label_gen_92_afterwhile
	; source: boards.p8:120   cbm.CHROUT($0d)
	lda  #13
	jsr  cbm.CHROUT
	; source: boards.p8:122   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: boards.p8:123   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: boards.p8:125   return status == 0
	lda  p8v_status
	beq  +
	lda  #1
+                           eor  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_i	.word  ?
p8v_rec_str	.word  ?
p8v_record_num	.byte  ?
p8v_status	.byte  ?
	.send BSS
	.pend
	; source: boards.p8:129   sub read_message(ubyte record_num, uword buffer) -> bool {

p8s_read_message	.proc
; statements
	; source: boards.p8:143   ubyte ch = cbm.CHRIN()
	; source: boards.p8:141   uword i = 0
	; source: boards.p8:130   if not open_rel() {
	jsr  p8b_boards.p8s_open_rel
	cmp  #0
	bne  p8_label_gen_352_afterif
	; source: boards.p8:131   return false
	lda  #0
	rts
p8_label_gen_352_afterif
	; source: boards.p8:134   if not seek_record(record_num) {
	lda  p8v_record_num
	jsr  p8b_boards.p8s_seek_record
	cmp  #0
	bne  p8_label_gen_353_afterif
	; source: boards.p8:135   close_rel()
	jsr  p8b_boards.p8s_close_rel
	; source: boards.p8:136   return false
	lda  #0
	rts
p8_label_gen_353_afterif
	; source: boards.p8:139   cbm.CHKIN(REL_CHANNEL)
	ldx  #3
	jsr  cbm.CHKIN
	; source: boards.p8:141   uword i = 0
	lda  #0
	sta  p8v_i
	sta  p8v_i+1
	; source: boards.p8:142   while i < MSG_RECORD_SIZE {
p8_label_gen_93_whileloop
	ldy  p8v_i+1
	lda  p8v_i
	cmp  #<$80
	tya
	sbc  #>$80
	bcs  p8_label_gen_94_afterwhile
	; source: boards.p8:143   ubyte ch = cbm.CHRIN()
	jsr  cbm.CHRIN
	sta  p8v_ch
	; source: boards.p8:144   @(buffer + i) = ch
	tax
	lda  p8b_boards.p8s_read_message.p8v_buffer
	sta  P8ZP_SCRATCH_W2
	lda  p8b_boards.p8s_read_message.p8v_buffer+1
	clc
	adc  p8b_boards.p8s_read_message.p8v_i+1
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8b_boards.p8s_read_message.p8v_i
	txa
	sta  (P8ZP_SCRATCH_W2),y
	; source: boards.p8:145   i++
	inc  p8v_i
	bne  +
	inc  p8v_i+1
+
	; source: boards.p8:142   while i < MSG_RECORD_SIZE {
	jmp  p8_label_gen_93_whileloop
p8_label_gen_94_afterwhile
	; source: boards.p8:148   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: boards.p8:149   close_rel()
	jsr  p8b_boards.p8s_close_rel
	; source: boards.p8:151   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_buffer	.word  ?
p8v_ch	.byte  ?
p8v_i	.word  ?
p8v_record_num	.byte  ?
	.send BSS
	.pend
	; source: boards.p8:155   sub write_message(ubyte record_num, uword buffer) -> bool {

p8s_write_message	.proc
; statements
	; source: boards.p8:167   uword i = 0
	; source: boards.p8:156   if not open_rel() {
	jsr  p8b_boards.p8s_open_rel
	cmp  #0
	bne  p8_label_gen_354_afterif
	; source: boards.p8:157   return false
	lda  #0
	rts
p8_label_gen_354_afterif
	; source: boards.p8:160   if not seek_record(record_num) {
	lda  p8v_record_num
	jsr  p8b_boards.p8s_seek_record
	cmp  #0
	bne  p8_label_gen_355_afterif
	; source: boards.p8:161   close_rel()
	jsr  p8b_boards.p8s_close_rel
	; source: boards.p8:162   return false
	lda  #0
	rts
p8_label_gen_355_afterif
	; source: boards.p8:165   cbm.CHKOUT(REL_CHANNEL)
	ldx  #3
	jsr  cbm.CHKOUT
	; source: boards.p8:167   uword i = 0
	lda  #0
	sta  p8v_i
	sta  p8v_i+1
	; source: boards.p8:168   while i < MSG_RECORD_SIZE {
p8_label_gen_95_whileloop
	ldy  p8v_i+1
	lda  p8v_i
	cmp  #<$80
	tya
	sbc  #>$80
	bcs  p8_label_gen_96_afterwhile
	; source: boards.p8:169   cbm.CHROUT(@(buffer + i))
	lda  p8b_boards.p8s_write_message.p8v_buffer
	sta  P8ZP_SCRATCH_W2
	lda  p8b_boards.p8s_write_message.p8v_buffer+1
	clc
	adc  p8b_boards.p8s_write_message.p8v_i+1
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8b_boards.p8s_write_message.p8v_i
	lda  (P8ZP_SCRATCH_W2),y
	jsr  cbm.CHROUT
	; source: boards.p8:170   i++
	inc  p8v_i
	bne  +
	inc  p8v_i+1
+
	; source: boards.p8:168   while i < MSG_RECORD_SIZE {
	jmp  p8_label_gen_95_whileloop
p8_label_gen_96_afterwhile
	; source: boards.p8:173   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: boards.p8:174   close_rel()
	jsr  p8b_boards.p8s_close_rel
	; source: boards.p8:176   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_buffer	.word  ?
p8v_i	.word  ?
p8v_record_num	.byte  ?
	.send BSS
	.pend
	; source: boards.p8:180   sub find_free_message() -> ubyte {

p8s_find_free_message	.proc
; statements
	; source: boards.p8:181   ubyte[MSG_RECORD_SIZE] msg_buffer
	; source: boards.p8:182   ubyte i = 0
	lda  #0
	sta  p8v_i
	; source: boards.p8:184   while i < max_messages {
p8_label_gen_97_whileloop
	ldy  #0
	lda  p8v_i
	cmp  p8b_boards.p8v_max_messages
	tya
	sbc  p8b_boards.p8v_max_messages+1
	bcs  p8_label_gen_98_afterwhile
	; source: boards.p8:185   if read_message(i, &msg_buffer) {
	lda  p8v_i
	sta  p8b_boards.p8s_read_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_boards.p8s_read_message.p8v_buffer
	sty  p8b_boards.p8s_read_message.p8v_buffer+1
	jsr  p8b_boards.p8s_read_message
	cmp  #0
	beq  p8_label_gen_356_afterif
	; source: boards.p8:187   if msg_buffer[0] == 0 {
	lda  p8v_msg_buffer+0
	bne  p8_label_gen_357_afterif
	; source: boards.p8:188   return i
	lda  p8v_i
	rts
p8_label_gen_357_afterif
p8_label_gen_356_afterif
	; source: boards.p8:191   i++
	inc  p8v_i
	; source: boards.p8:184   while i < max_messages {
	jmp  p8_label_gen_97_whileloop
p8_label_gen_98_afterwhile
	; source: boards.p8:194   return 255  ; No free records
	lda  #$ff
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_i	.byte  ?
p8v_msg_buffer	.fill  128
	.send BSS
	.pend
	; source: boards.p8:198   sub get_next_message_id() -> uword {

p8s_get_next_message_id	.proc
; statements
	; source: boards.p8:207   uword msg_id = @(&msg_buffer + 130) | (@(&msg_buffer + 131) << 8)
	; source: boards.p8:199   ubyte[MSG_RECORD_SIZE] msg_buffer
	; source: boards.p8:200   uword max_id = 0
	; source: boards.p8:201   ubyte i = 0
	; source: boards.p8:200   uword max_id = 0
	lda  #0
	sta  p8v_max_id
	sta  p8v_max_id+1
	; source: boards.p8:201   ubyte i = 0
	lda  #0
	sta  p8v_i
	; source: boards.p8:203   while i < max_messages {
p8_label_gen_99_whileloop
	ldy  #0
	lda  p8v_i
	cmp  p8b_boards.p8v_max_messages
	tya
	sbc  p8b_boards.p8v_max_messages+1
	bcs  p8_label_gen_100_afterwhile
	; source: boards.p8:204   if read_message(i, &msg_buffer) {
	lda  p8v_i
	sta  p8b_boards.p8s_read_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_boards.p8s_read_message.p8v_buffer
	sty  p8b_boards.p8s_read_message.p8v_buffer+1
	jsr  p8b_boards.p8s_read_message
	cmp  #0
	beq  p8_label_gen_358_afterif
	; source: boards.p8:205   if msg_buffer[0] != 0 {  ; Active message
	lda  p8v_msg_buffer+0
	beq  p8_label_gen_359_afterif
	; source: boards.p8:207   uword msg_id = @(&msg_buffer + 130) | (@(&msg_buffer + 131) << 8)
	lda  p8v_msg_buffer+130
	ldy  #0
	sta  p8v_msg_id
	sty  p8v_msg_id+1
	; source: boards.p8:208   if msg_id > max_id {
	ldy  p8v_max_id+1
	lda  p8v_max_id
	cmp  p8v_msg_id
	tya
	sbc  p8v_msg_id+1
	bcs  p8_label_gen_360_afterif
	; source: boards.p8:209   max_id = msg_id
	lda  p8v_msg_id
	ldy  p8v_msg_id+1
	sta  p8v_max_id
	sty  p8v_max_id+1
p8_label_gen_360_afterif
p8_label_gen_359_afterif
p8_label_gen_358_afterif
	; source: boards.p8:213   i++
	inc  p8v_i
	; source: boards.p8:203   while i < max_messages {
	jmp  p8_label_gen_99_whileloop
p8_label_gen_100_afterwhile
	; source: boards.p8:216   return max_id + 1
	ldy  p8v_max_id+1
	lda  p8v_max_id
	clc
	adc  #1
	bcc  +
	iny
+
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_i	.byte  ?
p8v_max_id	.word  ?
p8v_msg_buffer	.fill  128
p8v_msg_id	.word  ?
	.send BSS
	.pend
	; source: boards.p8:220   sub list_messages(uword board_name) {

p8s_list_messages	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_board_name
	sty  p8v_board_name+1
; statements
	; source: boards.p8:281   ubyte j2 = 0
	; source: boards.p8:280   bool match2 = true
	; source: boards.p8:304   uword id_str = conv.str_uw(msg_id)
	; source: boards.p8:300   uword author = &msg_buffer + 10
	; source: boards.p8:299   uword subject = &msg_buffer + 30
	; source: boards.p8:298   uword msg_id = @(&msg_buffer + 130) | (@(&msg_buffer + 131) << 8)
	; source: boards.p8:284   ubyte brd_char2 = @(board_name + j2)
	; source: boards.p8:283   ubyte rec_char2 = msg_buffer[j2]
	; source: boards.p8:238   ubyte j = 0
	; source: boards.p8:237   bool match = true
	; source: boards.p8:241   ubyte brd_char = @(board_name + j)
	; source: boards.p8:240   ubyte rec_char = msg_buffer[j]
	; source: boards.p8:228   ubyte[MSG_RECORD_SIZE] msg_buffer
	; source: boards.p8:229   ubyte count = 0
	; source: boards.p8:230   ubyte i = 0
	; source: boards.p8:268   uword count_str = conv.str_ub(count)
	; source: boards.p8:275   ubyte displayed = 0
	; source: boards.p8:221   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:222   session.send_line("=== Message Board ===")
	ldy  #>prog8_interned_strings.string_111
	lda  #<prog8_interned_strings.string_111
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:223   session.send_string("Board: ")
	ldy  #>prog8_interned_strings.string_112
	lda  #<prog8_interned_strings.string_112
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:224   session.send_string(board_name)
	ldy  p8v_board_name+1
	lda  p8v_board_name
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:225   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:226   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:229   ubyte count = 0
	lda  #0
	sta  p8v_count
	; source: boards.p8:230   ubyte i = 0
	sta  p8v_i
	; source: boards.p8:233   while i < max_messages {
p8_label_gen_105_whileloop
	ldy  #0
	lda  p8v_i
	cmp  p8b_boards.p8v_max_messages
	tya
	sbc  p8b_boards.p8v_max_messages+1
	bcs  p8_label_gen_106_afterwhile
	; source: boards.p8:234   if read_message(i, &msg_buffer) {
	lda  p8v_i
	sta  p8b_boards.p8s_read_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_boards.p8s_read_message.p8v_buffer
	sty  p8b_boards.p8s_read_message.p8v_buffer+1
	jsr  p8b_boards.p8s_read_message
	cmp  #0
	beq  p8_label_gen_361_afterif
	; source: boards.p8:235   if msg_buffer[0] != 0 {  ; Active message
	lda  p8v_msg_buffer+0
	beq  p8_label_gen_362_afterif
	; source: boards.p8:237   bool match = true
	lda  #1
	sta  p8v_match
	; source: boards.p8:238   ubyte j = 0
	lda  #0
	sta  p8v_j
	; source: boards.p8:239   while j < MSG_BOARD_MAX {
p8_label_gen_103_whileloop
	lda  p8v_j
	cmp  #10
	bcs  p8_label_gen_104_afterwhile
	; source: boards.p8:240   ubyte rec_char = msg_buffer[j]
	ldy  p8v_j
	lda  p8v_msg_buffer,y
	sta  p8v_rec_char
	; source: boards.p8:241   ubyte brd_char = @(board_name + j)
	lda  p8v_board_name
	ldy  p8v_board_name+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  p8v_j
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8v_brd_char
	; source: boards.p8:243   if rec_char == 0 and brd_char == 0 {
	lda  p8v_rec_char
	ora  p8v_brd_char
	beq  p8_label_gen_101_after
	; source: boards.p8:246   if rec_char != brd_char {
	lda  p8v_rec_char
	cmp  p8v_brd_char
	beq  p8_label_gen_363_afterif
	; source: boards.p8:247   match = false
	lda  #0
	sta  p8v_match
	; source: boards.p8:248   break
	jmp  p8_label_gen_102_after
p8_label_gen_363_afterif
	; source: boards.p8:250   j++
	inc  p8v_j
	; source: boards.p8:239   while j < MSG_BOARD_MAX {
	jmp  p8_label_gen_103_whileloop
p8_label_gen_104_afterwhile
	; source: boards.p8:248   break
p8_label_gen_102_after
	; source: boards.p8:244   break
p8_label_gen_101_after
	; source: boards.p8:253   if match {
	lda  p8v_match
	beq  p8_label_gen_364_afterif
	; source: boards.p8:254   count++
	inc  p8v_count
p8_label_gen_364_afterif
p8_label_gen_362_afterif
p8_label_gen_361_afterif
	; source: boards.p8:258   i++
	inc  p8v_i
	; source: boards.p8:233   while i < max_messages {
	jmp  p8_label_gen_105_whileloop
p8_label_gen_106_afterwhile
	; source: boards.p8:261   if count == 0 {
	lda  p8v_count
	bne  p8_label_gen_365_afterif
	; source: boards.p8:262   session.send_line("No messages in this board.")
	ldy  #>prog8_interned_strings.string_113
	lda  #<prog8_interned_strings.string_113
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:263   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jmp  p8b_session.p8s_send_line
	; source: boards.p8:264   return
p8_label_gen_365_afterif
	; source: boards.p8:267   session.send_string("Messages: ")
	ldy  #>prog8_interned_strings.string_114
	lda  #<prog8_interned_strings.string_114
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:268   uword count_str = conv.str_ub(count)
	lda  p8v_count
	jsr  conv.str_ub
	sta  p8v_count_str
	sty  p8v_count_str+1
	; source: boards.p8:269   session.send_string(count_str)
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:270   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:271   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:274   i = 0
	lda  #0
	sta  p8v_i
	; source: boards.p8:275   ubyte displayed = 0
	sta  p8v_displayed
	; source: boards.p8:276   while i < max_messages and displayed < 20 {  ; Limit to 20 messages
p8_label_gen_111_whileloop
	ldy  #0
	lda  p8v_i
	cmp  p8b_boards.p8v_max_messages
	tya
	sbc  p8b_boards.p8v_max_messages+1
	bcs  p8_label_gen_368_else
	lda  #1
	jmp  p8_label_gen_367_afterif
p8_label_gen_368_else
	lda  #0
p8_label_gen_367_afterif
	beq  p8_label_gen_366_shortcut
	lda  p8v_displayed
	cmp  #20
	rol  a
	and  #1
	eor  #1
p8_label_gen_366_shortcut
	beq  p8_label_gen_112_afterwhile
	; source: boards.p8:277   if read_message(i, &msg_buffer) {
	lda  p8v_i
	sta  p8b_boards.p8s_read_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_boards.p8s_read_message.p8v_buffer
	sty  p8b_boards.p8s_read_message.p8v_buffer+1
	jsr  p8b_boards.p8s_read_message
	cmp  #0
	beq  p8_label_gen_369_afterif
	; source: boards.p8:278   if msg_buffer[0] != 0 {
	lda  p8v_msg_buffer+0
	beq  p8_label_gen_370_afterif
	; source: boards.p8:280   bool match2 = true
	lda  #1
	sta  p8v_match2
	; source: boards.p8:281   ubyte j2 = 0
	lda  #0
	sta  p8v_j2
	; source: boards.p8:282   while j2 < MSG_BOARD_MAX {
p8_label_gen_109_whileloop
	lda  p8v_j2
	cmp  #10
	bcs  p8_label_gen_110_afterwhile
	; source: boards.p8:283   ubyte rec_char2 = msg_buffer[j2]
	ldy  p8v_j2
	lda  p8v_msg_buffer,y
	sta  p8v_rec_char2
	; source: boards.p8:284   ubyte brd_char2 = @(board_name + j2)
	lda  p8v_board_name
	ldy  p8v_board_name+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  p8v_j2
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8v_brd_char2
	; source: boards.p8:286   if rec_char2 == 0 and brd_char2 == 0 {
	lda  p8v_rec_char2
	ora  p8v_brd_char2
	beq  p8_label_gen_107_after
	; source: boards.p8:289   if rec_char2 != brd_char2 {
	lda  p8v_rec_char2
	cmp  p8v_brd_char2
	beq  p8_label_gen_371_afterif
	; source: boards.p8:290   match2 = false
	lda  #0
	sta  p8v_match2
	; source: boards.p8:291   break
	jmp  p8_label_gen_108_after
p8_label_gen_371_afterif
	; source: boards.p8:293   j2++
	inc  p8v_j2
	; source: boards.p8:282   while j2 < MSG_BOARD_MAX {
	jmp  p8_label_gen_109_whileloop
p8_label_gen_110_afterwhile
	; source: boards.p8:291   break
p8_label_gen_108_after
	; source: boards.p8:287   break
p8_label_gen_107_after
	; source: boards.p8:296   if match2 {
	lda  p8v_match2
	beq  p8_label_gen_372_afterif
	; source: boards.p8:298   uword msg_id = @(&msg_buffer + 130) | (@(&msg_buffer + 131) << 8)
	lda  p8v_msg_buffer+130
	ldy  #0
	sta  p8v_msg_id
	sty  p8v_msg_id+1
	; source: boards.p8:299   uword subject = &msg_buffer + 30
	ldy  #>p8v_msg_buffer
	lda  #<p8v_msg_buffer
	clc
	adc  #$1e
	bcc  +
	iny
+
	sta  p8v_subject
	sty  p8v_subject+1
	; source: boards.p8:300   uword author = &msg_buffer + 10
	ldy  #>p8v_msg_buffer
	lda  #<p8v_msg_buffer
	clc
	adc  #10
	bcc  +
	iny
+
	sta  p8v_author
	sty  p8v_author+1
	; source: boards.p8:303   session.send_string("[")
	ldy  #>prog8_interned_strings.string_115
	lda  #<prog8_interned_strings.string_115
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:304   uword id_str = conv.str_uw(msg_id)
	ldy  p8v_msg_id+1
	lda  p8v_msg_id
	jsr  conv.str_uw
	sta  p8v_id_str
	sty  p8v_id_str+1
	; source: boards.p8:305   session.send_string(id_str)
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:306   session.send_string("] ")
	ldy  #>prog8_interned_strings.string_116
	lda  #<prog8_interned_strings.string_116
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:307   session.send_string(subject)
	ldy  p8v_subject+1
	lda  p8v_subject
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:308   session.send_string(" by ")
	ldy  #>prog8_interned_strings.string_117
	lda  #<prog8_interned_strings.string_117
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:309   session.send_string(author)
	ldy  p8v_author+1
	lda  p8v_author
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:310   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:312   displayed++
	inc  p8v_displayed
p8_label_gen_372_afterif
p8_label_gen_370_afterif
p8_label_gen_369_afterif
	; source: boards.p8:316   i++
	inc  p8v_i
	; source: boards.p8:276   while i < max_messages and displayed < 20 {  ; Limit to 20 messages
	jmp  p8_label_gen_111_whileloop
p8_label_gen_112_afterwhile
	; source: boards.p8:319   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jmp  p8b_session.p8s_send_line
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_author	.word  ?
p8v_board_name	.word  ?
p8v_brd_char	.byte  ?
p8v_brd_char2	.byte  ?
p8v_count	.byte  ?
p8v_count_str	.word  ?
p8v_displayed	.byte  ?
p8v_i	.byte  ?
p8v_id_str	.word  ?
p8v_j	.byte  ?
p8v_j2	.byte  ?
p8v_match	.byte  ?
p8v_match2	.byte  ?
p8v_msg_buffer	.fill  128
p8v_msg_id	.word  ?
p8v_rec_char	.byte  ?
p8v_rec_char2	.byte  ?
p8v_subject	.word  ?
	.send BSS
	.pend
	; source: boards.p8:323   sub read_message_by_id(uword msg_id) -> bool {

p8s_read_message_by_id	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_msg_id
	sty  p8v_msg_id+1
; statements
	; source: boards.p8:330   uword id = @(&msg_buffer + 130) | (@(&msg_buffer + 131) << 8)
	; source: boards.p8:339   uword body = &msg_buffer + 70
	; source: boards.p8:338   uword author = &msg_buffer + 10
	; source: boards.p8:337   uword subject = &msg_buffer + 30
	; source: boards.p8:324   ubyte[MSG_RECORD_SIZE] msg_buffer
	; source: boards.p8:325   ubyte i = 0
	lda  #0
	sta  p8v_i
	; source: boards.p8:327   while i < max_messages {
p8_label_gen_113_whileloop
	ldy  #0
	lda  p8v_i
	cmp  p8b_boards.p8v_max_messages
	tya
	sbc  p8b_boards.p8v_max_messages+1
	bcs  p8_label_gen_114_afterwhile
	; source: boards.p8:328   if read_message(i, &msg_buffer) {
	lda  p8v_i
	sta  p8b_boards.p8s_read_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_boards.p8s_read_message.p8v_buffer
	sty  p8b_boards.p8s_read_message.p8v_buffer+1
	jsr  p8b_boards.p8s_read_message
	cmp  #0
	beq  p8_label_gen_373_afterif
	; source: boards.p8:329   if msg_buffer[0] != 0 {
	lda  p8v_msg_buffer+0
	beq  p8_label_gen_374_afterif
	; source: boards.p8:330   uword id = @(&msg_buffer + 130) | (@(&msg_buffer + 131) << 8)
	lda  p8v_msg_buffer+130
	ldy  #0
	sta  p8v_id
	sty  p8v_id+1
	; source: boards.p8:331   if id == msg_id {
	lda  p8b_boards.p8s_read_message_by_id.p8v_id
	cmp  p8b_boards.p8s_read_message_by_id.p8v_msg_id
	bne  p8_label_gen_375_afterif
	lda  p8b_boards.p8s_read_message_by_id.p8v_id+1
	cmp  p8b_boards.p8s_read_message_by_id.p8v_msg_id+1
	bne  p8_label_gen_375_afterif
	; source: boards.p8:333   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:334   session.send_line("=== Message ===")
	ldy  #>prog8_interned_strings.string_118
	lda  #<prog8_interned_strings.string_118
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:335   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:337   uword subject = &msg_buffer + 30
	ldy  #>p8v_msg_buffer
	lda  #<p8v_msg_buffer
	clc
	adc  #$1e
	bcc  +
	iny
+
	sta  p8v_subject
	sty  p8v_subject+1
	; source: boards.p8:338   uword author = &msg_buffer + 10
	ldy  #>p8v_msg_buffer
	lda  #<p8v_msg_buffer
	clc
	adc  #10
	bcc  +
	iny
+
	sta  p8v_author
	sty  p8v_author+1
	; source: boards.p8:339   uword body = &msg_buffer + 70
	ldy  #>p8v_msg_buffer
	lda  #<p8v_msg_buffer
	clc
	adc  #$46
	bcc  +
	iny
+
	sta  p8v_body
	sty  p8v_body+1
	; source: boards.p8:341   session.send_string("Subject: ")
	ldy  #>prog8_interned_strings.string_119
	lda  #<prog8_interned_strings.string_119
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:342   session.send_string(subject)
	ldy  p8v_subject+1
	lda  p8v_subject
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:343   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:344   session.send_string("From: ")
	ldy  #>prog8_interned_strings.string_120
	lda  #<prog8_interned_strings.string_120
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:345   session.send_string(author)
	ldy  p8v_author+1
	lda  p8v_author
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:346   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:347   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:348   session.send_string(body)
	ldy  p8v_body+1
	lda  p8v_body
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:349   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:350   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:352   return true
	lda  #1
	rts
p8_label_gen_375_afterif
p8_label_gen_374_afterif
p8_label_gen_373_afterif
	; source: boards.p8:356   i++
	inc  p8v_i
	; source: boards.p8:327   while i < max_messages {
	jmp  p8_label_gen_113_whileloop
p8_label_gen_114_afterwhile
	; source: boards.p8:359   return false
	lda  #0
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_author	.word  ?
p8v_body	.word  ?
p8v_i	.byte  ?
p8v_id	.word  ?
p8v_msg_buffer	.fill  128
p8v_msg_id	.word  ?
p8v_subject	.word  ?
	.send BSS
	.pend
	; source: boards.p8:363   sub post_message(uword board_name, uword subject, uword body, uword reply_to_id) -> bool {

p8s_post_message	.proc
; statements
	; source: boards.p8:364   ubyte record_num = find_free_message()
	; source: boards.p8:370   uword username = login.get_username()
	; source: boards.p8:371   uword msg_id = get_next_message_id()
	; source: boards.p8:374   ubyte[MSG_RECORD_SIZE] msg_buffer
	; source: boards.p8:377   ubyte i = 0
	; source: boards.p8:384   ubyte board_len = strings.length(board_name)
	; source: boards.p8:395   ubyte author_len = strings.length(username)
	; source: boards.p8:406   ubyte subject_len = strings.length(subject)
	; source: boards.p8:417   ubyte body_len = strings.length(body)
	; source: boards.p8:364   ubyte record_num = find_free_message()
	jsr  p8b_boards.p8s_find_free_message
	sta  p8v_record_num
	; source: boards.p8:365   if record_num == 255 {
	cmp  #255
	bne  p8_label_gen_376_afterif
	; source: boards.p8:366   session.send_line("Error: Message database full!")
	ldy  #>prog8_interned_strings.string_121
	lda  #<prog8_interned_strings.string_121
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:367   return false
	lda  #0
	rts
p8_label_gen_376_afterif
	; source: boards.p8:370   uword username = login.get_username()
	lda  p8b_login.p8v_current_username
	ldy  p8b_login.p8v_current_username+1
	sta  p8v_username
	sty  p8v_username+1
	; source: boards.p8:371   uword msg_id = get_next_message_id()
	jsr  p8b_boards.p8s_get_next_message_id
	sta  p8v_msg_id
	sty  p8v_msg_id+1
	; source: boards.p8:377   ubyte i = 0
	lda  #0
	sta  p8v_i
	; source: boards.p8:378   while i < MSG_RECORD_SIZE {
p8_label_gen_115_whileloop
	lda  p8v_i
	cmp  #128
	bcs  p8_label_gen_116_afterwhile
	; source: boards.p8:379   msg_buffer[i] = 0
	ldy  p8v_i
	lda  #0
	sta  p8v_msg_buffer,y
	; source: boards.p8:380   i++
	inc  p8v_i
	; source: boards.p8:378   while i < MSG_RECORD_SIZE {
	jmp  p8_label_gen_115_whileloop
p8_label_gen_116_afterwhile
	; source: boards.p8:384   ubyte board_len = strings.length(board_name)
	ldy  p8v_board_name+1
	lda  p8v_board_name
	jsr  strings.length
	sty  p8v_board_len
	; source: boards.p8:385   if board_len > MSG_BOARD_MAX {
	lda  p8v_board_len
	cmp  #11
	bcc  p8_label_gen_377_afterif
	; source: boards.p8:386   board_len = MSG_BOARD_MAX
	lda  #10
	sta  p8v_board_len
p8_label_gen_377_afterif
	; source: boards.p8:388   i = 0
	lda  #0
	sta  p8v_i
	; source: boards.p8:389   while i < board_len {
p8_label_gen_117_whileloop
	lda  p8v_i
	cmp  p8v_board_len
	bcs  p8_label_gen_118_afterwhile
	; source: boards.p8:390   msg_buffer[i] = @(board_name + i)
	lda  p8v_board_name
	ldy  p8v_board_name+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  p8v_i
	lda  (P8ZP_SCRATCH_W2),y
	ldy  p8v_i
	sta  p8v_msg_buffer,y
	; source: boards.p8:391   i++
	inc  p8v_i
	; source: boards.p8:389   while i < board_len {
	jmp  p8_label_gen_117_whileloop
p8_label_gen_118_afterwhile
	; source: boards.p8:395   ubyte author_len = strings.length(username)
	ldy  p8v_username+1
	lda  p8v_username
	jsr  strings.length
	sty  p8v_author_len
	; source: boards.p8:396   if author_len > MSG_AUTHOR_MAX {
	lda  p8v_author_len
	cmp  #21
	bcc  p8_label_gen_378_afterif
	; source: boards.p8:397   author_len = MSG_AUTHOR_MAX
	lda  #$14
	sta  p8v_author_len
p8_label_gen_378_afterif
	; source: boards.p8:399   i = 0
	lda  #0
	sta  p8v_i
	; source: boards.p8:400   while i < author_len {
p8_label_gen_119_whileloop
	lda  p8v_i
	cmp  p8v_author_len
	bcs  p8_label_gen_120_afterwhile
	; source: boards.p8:401   msg_buffer[10 + i] = @(username + i)
	lda  p8v_username
	ldy  p8v_username+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  p8v_i
	lda  (P8ZP_SCRATCH_W2),y
	pha
	lda  p8v_i
	clc
	adc  #10
	tay
	pla
	sta  p8v_msg_buffer,y
	; source: boards.p8:402   i++
	inc  p8v_i
	; source: boards.p8:400   while i < author_len {
	jmp  p8_label_gen_119_whileloop
p8_label_gen_120_afterwhile
	; source: boards.p8:406   ubyte subject_len = strings.length(subject)
	ldy  p8v_subject+1
	lda  p8v_subject
	jsr  strings.length
	sty  p8v_subject_len
	; source: boards.p8:407   if subject_len > MSG_SUBJECT_MAX {
	lda  p8v_subject_len
	cmp  #41
	bcc  p8_label_gen_379_afterif
	; source: boards.p8:408   subject_len = MSG_SUBJECT_MAX
	lda  #$28
	sta  p8v_subject_len
p8_label_gen_379_afterif
	; source: boards.p8:410   i = 0
	lda  #0
	sta  p8v_i
	; source: boards.p8:411   while i < subject_len {
p8_label_gen_121_whileloop
	lda  p8v_i
	cmp  p8v_subject_len
	bcs  p8_label_gen_122_afterwhile
	; source: boards.p8:412   msg_buffer[30 + i] = @(subject + i)
	lda  p8v_subject
	ldy  p8v_subject+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  p8v_i
	lda  (P8ZP_SCRATCH_W2),y
	pha
	lda  p8v_i
	clc
	adc  #$1e
	tay
	pla
	sta  p8v_msg_buffer,y
	; source: boards.p8:413   i++
	inc  p8v_i
	; source: boards.p8:411   while i < subject_len {
	jmp  p8_label_gen_121_whileloop
p8_label_gen_122_afterwhile
	; source: boards.p8:417   ubyte body_len = strings.length(body)
	ldy  p8v_body+1
	lda  p8v_body
	jsr  strings.length
	sty  p8v_body_len
	; source: boards.p8:418   if body_len > MSG_BODY_MAX {
	lda  p8v_body_len
	cmp  #61
	bcc  p8_label_gen_380_afterif
	; source: boards.p8:419   body_len = MSG_BODY_MAX
	lda  #$3c
	sta  p8v_body_len
p8_label_gen_380_afterif
	; source: boards.p8:421   i = 0
	lda  #0
	sta  p8v_i
	; source: boards.p8:422   while i < body_len {
p8_label_gen_123_whileloop
	lda  p8v_i
	cmp  p8v_body_len
	bcs  p8_label_gen_124_afterwhile
	; source: boards.p8:423   msg_buffer[70 + i] = @(body + i)
	lda  p8v_body
	ldy  p8v_body+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  p8v_i
	lda  (P8ZP_SCRATCH_W2),y
	pha
	lda  p8v_i
	clc
	adc  #$46
	tay
	pla
	sta  p8v_msg_buffer,y
	; source: boards.p8:424   i++
	inc  p8v_i
	; source: boards.p8:422   while i < body_len {
	jmp  p8_label_gen_123_whileloop
p8_label_gen_124_afterwhile
	; source: boards.p8:428   @(&msg_buffer + 130) = lsb(msg_id)
	lda  p8v_msg_id
	sta  p8v_msg_buffer+130
	; source: boards.p8:429   @(&msg_buffer + 131) = msb(msg_id)
	lda  p8v_msg_id+1
	sta  p8v_msg_buffer+131
	; source: boards.p8:432   @(&msg_buffer + 132) = lsb(reply_to_id)
	lda  p8v_reply_to_id
	sta  p8v_msg_buffer+132
	; source: boards.p8:433   @(&msg_buffer + 133) = msb(reply_to_id)
	lda  p8v_reply_to_id+1
	sta  p8v_msg_buffer+133
	; source: boards.p8:438   if write_message(record_num, &msg_buffer) {
	lda  p8v_record_num
	sta  p8b_boards.p8s_write_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_boards.p8s_write_message.p8v_buffer
	sty  p8b_boards.p8s_write_message.p8v_buffer+1
	jsr  p8b_boards.p8s_write_message
	cmp  #0
	beq  p8_label_gen_381_afterif
	; source: boards.p8:439   session.send_line("Message posted successfully!")
	ldy  #>prog8_interned_strings.string_122
	lda  #<prog8_interned_strings.string_122
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:440   return true
	lda  #1
	rts
p8_label_gen_381_afterif
	; source: boards.p8:443   return false
	lda  #0
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_author_len	.byte  ?
p8v_board_len	.byte  ?
p8v_board_name	.word  ?
p8v_body	.word  ?
p8v_body_len	.byte  ?
p8v_i	.byte  ?
p8v_msg_buffer	.fill  128
p8v_msg_id	.word  ?
p8v_record_num	.byte  ?
p8v_reply_to_id	.word  ?
p8v_subject	.word  ?
p8v_subject_len	.byte  ?
p8v_username	.word  ?
	.send BSS
	.pend
	; source: boards.p8:447   sub show_menu() {

p8s_show_menu	.proc
; statements
	; source: boards.p8:469   ubyte choice = @(input)
	; source: boards.p8:463   uword input = session.get_input_line()
	; source: boards.p8:448   bool running = true
	lda  #1
	sta  p8v_running
	; source: boards.p8:466   continue
p8_label_gen_125_cont
	; source: boards.p8:474   continue
p8_label_gen_126_cont
	; source: boards.p8:450   while running and session.is_active() {
p8_label_gen_127_whileloop
	lda  p8v_running
	beq  p8_label_gen_382_shortcut
	jsr  p8b_session.p8s_is_active
p8_label_gen_382_shortcut
	beq  p8_label_gen_128_afterwhile
	; source: boards.p8:451   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:452   session.send_line("=== Message Boards ===")
	ldy  #>prog8_interned_strings.string_123
	lda  #<prog8_interned_strings.string_123
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:453   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:454   session.send_line("1. General Discussion")
	ldy  #>prog8_interned_strings.string_124
	lda  #<prog8_interned_strings.string_124
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:455   session.send_line("2. Announcements")
	ldy  #>prog8_interned_strings.string_125
	lda  #<prog8_interned_strings.string_125
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:456   session.send_line("3. Help & Support")
	ldy  #>prog8_interned_strings.string_126
	lda  #<prog8_interned_strings.string_126
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:457   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:458   session.send_line("0. Return to Main Menu")
	ldy  #>prog8_interned_strings.string_127
	lda  #<prog8_interned_strings.string_127
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:459   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:460   session.send_string("Enter choice: ")
	ldy  #>prog8_interned_strings.string_93
	lda  #<prog8_interned_strings.string_93
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:462   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_384_else
	; source: boards.p8:463   uword input = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_input
	sty  p8v_input+1
	; source: boards.p8:465   if strings.length(input) == 0 {
	jsr  strings.length
	tya
	beq  p8_label_gen_125_cont
	; source: boards.p8:469   ubyte choice = @(input)
	lda  p8v_input
	ldy  p8v_input+1
	sta  P8ZP_SCRATCH_PTR
	sty  P8ZP_SCRATCH_PTR+1
	ldy  #0
	lda  (P8ZP_SCRATCH_PTR),y
	sta  p8v_choice
	; source: boards.p8:470   if choice >= $30 and choice <= $39 {
	cmp  #48
	rol  a
	and  #1
	beq  p8_label_gen_385_shortcut
	lda  p8v_choice
	cmp  #58
	rol  a
	and  #1
	eor  #1
p8_label_gen_385_shortcut
	beq  p8_label_gen_387_else
	; source: boards.p8:471   choice = choice - $30
	lda  p8v_choice
	sec
	sbc  #48
	sta  p8v_choice
	jmp  p8_label_gen_386_afterif
p8_label_gen_387_else
	; source: boards.p8:473   session.send_line("Invalid choice.")
	ldy  #>prog8_interned_strings.string_96
	lda  #<prog8_interned_strings.string_96
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:474   continue
	jmp  p8_label_gen_126_cont
p8_label_gen_386_afterif
	; source: boards.p8:477   if choice == 0 {
	lda  p8v_choice
	bne  p8_label_gen_389_else
	; source: boards.p8:478   running = false
	lda  #0
	sta  p8v_running
	jmp  p8_label_gen_388_afterif
p8_label_gen_389_else
	; source: boards.p8:480   else if choice == 1 {
	lda  p8v_choice
	cmp  #1
	bne  p8_label_gen_391_else
	; source: boards.p8:481   show_board("General")
	ldy  #>prog8_interned_strings.string_128
	lda  #<prog8_interned_strings.string_128
	jsr  p8b_boards.p8s_show_board
	jmp  p8_label_gen_390_afterif
p8_label_gen_391_else
	; source: boards.p8:483   else if choice == 2 {
	lda  p8v_choice
	cmp  #2
	bne  p8_label_gen_393_else
	; source: boards.p8:484   show_board("Announce")
	ldy  #>prog8_interned_strings.string_129
	lda  #<prog8_interned_strings.string_129
	jsr  p8b_boards.p8s_show_board
	jmp  p8_label_gen_392_afterif
p8_label_gen_393_else
	; source: boards.p8:486   else if choice == 3 {
	lda  p8v_choice
	cmp  #3
	bne  p8_label_gen_395_else
	; source: boards.p8:487   show_board("Help")
	ldy  #>prog8_interned_strings.string_130
	lda  #<prog8_interned_strings.string_130
	jsr  p8b_boards.p8s_show_board
	jmp  p8_label_gen_394_afterif
p8_label_gen_395_else
	; source: boards.p8:490   session.send_line("Invalid choice.")
	ldy  #>prog8_interned_strings.string_96
	lda  #<prog8_interned_strings.string_96
	jsr  p8b_session.p8s_send_line
p8_label_gen_394_afterif
p8_label_gen_392_afterif
p8_label_gen_390_afterif
p8_label_gen_388_afterif
	jmp  p8_label_gen_383_afterif
p8_label_gen_384_else
	; source: boards.p8:493   running = false
	lda  #0
	sta  p8v_running
p8_label_gen_383_afterif
	; source: boards.p8:450   while running and session.is_active() {
	jmp  p8_label_gen_127_whileloop
p8_label_gen_128_afterwhile
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_choice	.byte  ?
p8v_input	.word  ?
p8v_running	.byte  ?
	.send BSS
	.pend
	; source: boards.p8:499   sub show_board(uword board_name) {

p8s_show_board	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_board_name
	sty  p8v_board_name+1
; statements
	; source: boards.p8:521   ubyte choice = @(input)
	; source: boards.p8:515   uword input = session.get_input_line()
	; source: boards.p8:560   uword reply_id = conv.str2uword(reply_id_input)
	; source: boards.p8:559   uword reply_id_input = session.get_input_line()
	; source: boards.p8:563   uword subject2 = session.get_input_line()
	; source: boards.p8:566   uword body2 = session.get_input_line()
	; source: boards.p8:547   uword subject = session.get_input_line()
	; source: boards.p8:550   uword body = session.get_input_line()
	; source: boards.p8:537   uword msg_id = conv.str2uword(id_input)
	; source: boards.p8:536   uword id_input = session.get_input_line()
	; source: boards.p8:500   bool running = true
	lda  #1
	sta  p8v_running
	; source: boards.p8:518   continue
p8_label_gen_129_cont
	; source: boards.p8:526   continue
p8_label_gen_130_cont
	; source: boards.p8:502   while running and session.is_active() {
p8_label_gen_131_whileloop
	lda  p8v_running
	beq  p8_label_gen_396_shortcut
	jsr  p8b_session.p8s_is_active
p8_label_gen_396_shortcut
	beq  p8_label_gen_132_afterwhile
	; source: boards.p8:503   list_messages(board_name)
	ldy  p8v_board_name+1
	lda  p8v_board_name
	jsr  p8b_boards.p8s_list_messages
	; source: boards.p8:505   session.send_line("Options:")
	ldy  #>prog8_interned_strings.string_131
	lda  #<prog8_interned_strings.string_131
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:506   session.send_line("1. Read message")
	ldy  #>prog8_interned_strings.string_132
	lda  #<prog8_interned_strings.string_132
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:507   session.send_line("2. Post new message")
	ldy  #>prog8_interned_strings.string_133
	lda  #<prog8_interned_strings.string_133
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:508   session.send_line("3. Reply to message")
	ldy  #>prog8_interned_strings.string_134
	lda  #<prog8_interned_strings.string_134
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:509   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:510   session.send_line("0. Back to boards")
	ldy  #>prog8_interned_strings.string_135
	lda  #<prog8_interned_strings.string_135
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:511   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:512   session.send_string("Enter choice: ")
	ldy  #>prog8_interned_strings.string_93
	lda  #<prog8_interned_strings.string_93
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:514   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_398_else
	; source: boards.p8:515   uword input = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_input
	sty  p8v_input+1
	; source: boards.p8:517   if strings.length(input) == 0 {
	jsr  strings.length
	tya
	beq  p8_label_gen_129_cont
	; source: boards.p8:521   ubyte choice = @(input)
	lda  p8v_input
	ldy  p8v_input+1
	sta  P8ZP_SCRATCH_PTR
	sty  P8ZP_SCRATCH_PTR+1
	ldy  #0
	lda  (P8ZP_SCRATCH_PTR),y
	sta  p8v_choice
	; source: boards.p8:522   if choice >= $30 and choice <= $39 {
	cmp  #48
	rol  a
	and  #1
	beq  p8_label_gen_399_shortcut
	lda  p8v_choice
	cmp  #58
	rol  a
	and  #1
	eor  #1
p8_label_gen_399_shortcut
	beq  p8_label_gen_401_else
	; source: boards.p8:523   choice = choice - $30
	lda  p8v_choice
	sec
	sbc  #48
	sta  p8v_choice
	jmp  p8_label_gen_400_afterif
p8_label_gen_401_else
	; source: boards.p8:525   session.send_line("Invalid choice.")
	ldy  #>prog8_interned_strings.string_96
	lda  #<prog8_interned_strings.string_96
	jsr  p8b_session.p8s_send_line
	; source: boards.p8:526   continue
	jmp  p8_label_gen_130_cont
p8_label_gen_400_afterif
	; source: boards.p8:529   if choice == 0 {
	lda  p8v_choice
	bne  p8_label_gen_403_else
	; source: boards.p8:530   running = false
	lda  #0
	sta  p8v_running
	jmp  p8_label_gen_402_afterif
p8_label_gen_403_else
	; source: boards.p8:532   else if choice == 1 {
	lda  p8v_choice
	cmp  #1
	bne  p8_label_gen_405_else
	; source: boards.p8:534   session.send_string("Enter message ID: ")
	ldy  #>prog8_interned_strings.string_136
	lda  #<prog8_interned_strings.string_136
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:535   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_406_afterif
	; source: boards.p8:536   uword id_input = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_id_input
	sty  p8v_id_input+1
	; source: boards.p8:537   uword msg_id = conv.str2uword(id_input)
	jsr  conv.str2uword
	sta  p8v_msg_id
	sty  p8v_msg_id+1
	; source: boards.p8:538   if not read_message_by_id(msg_id) {
	jsr  p8b_boards.p8s_read_message_by_id
	cmp  #0
	bne  p8_label_gen_407_afterif
	; source: boards.p8:539   session.send_line("Message not found.")
	ldy  #>prog8_interned_strings.string_137
	lda  #<prog8_interned_strings.string_137
	jsr  p8b_session.p8s_send_line
p8_label_gen_407_afterif
p8_label_gen_406_afterif
	jmp  p8_label_gen_404_afterif
p8_label_gen_405_else
	; source: boards.p8:543   else if choice == 2 {
	lda  p8v_choice
	cmp  #2
	bne  p8_label_gen_409_else
	; source: boards.p8:545   session.send_string("Subject: ")
	ldy  #>prog8_interned_strings.string_119
	lda  #<prog8_interned_strings.string_119
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:546   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_410_afterif
	; source: boards.p8:547   uword subject = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_subject
	sty  p8v_subject+1
	; source: boards.p8:548   session.send_string("Message: ")
	ldy  #>prog8_interned_strings.string_138
	lda  #<prog8_interned_strings.string_138
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:549   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_411_afterif
	; source: boards.p8:550   uword body = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_body
	sty  p8v_body+1
	; source: boards.p8:551   post_message(board_name, subject, body, 0)
	lda  p8v_board_name
	ldy  p8v_board_name+1
	sta  p8b_boards.p8s_post_message.p8v_board_name
	sty  p8b_boards.p8s_post_message.p8v_board_name+1
	lda  p8v_subject
	ldy  p8v_subject+1
	sta  p8b_boards.p8s_post_message.p8v_subject
	sty  p8b_boards.p8s_post_message.p8v_subject+1
	lda  p8v_body
	ldy  p8v_body+1
	sta  p8b_boards.p8s_post_message.p8v_body
	sty  p8b_boards.p8s_post_message.p8v_body+1
	lda  #0
	sta  p8b_boards.p8s_post_message.p8v_reply_to_id
	sta  p8b_boards.p8s_post_message.p8v_reply_to_id+1
	jsr  p8b_boards.p8s_post_message
p8_label_gen_411_afterif
p8_label_gen_410_afterif
	jmp  p8_label_gen_408_afterif
p8_label_gen_409_else
	; source: boards.p8:555   else if choice == 3 {
	lda  p8v_choice
	cmp  #3
	bne  p8_label_gen_412_afterif
	; source: boards.p8:557   session.send_string("Reply to message ID: ")
	ldy  #>prog8_interned_strings.string_139
	lda  #<prog8_interned_strings.string_139
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:558   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_413_afterif
	; source: boards.p8:559   uword reply_id_input = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_reply_id_input
	sty  p8v_reply_id_input+1
	; source: boards.p8:560   uword reply_id = conv.str2uword(reply_id_input)
	jsr  conv.str2uword
	sta  p8v_reply_id
	sty  p8v_reply_id+1
	; source: boards.p8:561   session.send_string("Subject: ")
	ldy  #>prog8_interned_strings.string_119
	lda  #<prog8_interned_strings.string_119
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:562   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_414_afterif
	; source: boards.p8:563   uword subject2 = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_subject2
	sty  p8v_subject2+1
	; source: boards.p8:564   session.send_string("Message: ")
	ldy  #>prog8_interned_strings.string_138
	lda  #<prog8_interned_strings.string_138
	jsr  p8b_session.p8s_send_string
	; source: boards.p8:565   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_415_afterif
	; source: boards.p8:566   uword body2 = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_body2
	sty  p8v_body2+1
	; source: boards.p8:567   post_message(board_name, subject2, body2, reply_id)
	lda  p8v_board_name
	ldy  p8v_board_name+1
	sta  p8b_boards.p8s_post_message.p8v_board_name
	sty  p8b_boards.p8s_post_message.p8v_board_name+1
	lda  p8v_subject2
	ldy  p8v_subject2+1
	sta  p8b_boards.p8s_post_message.p8v_subject
	sty  p8b_boards.p8s_post_message.p8v_subject+1
	lda  p8v_body2
	ldy  p8v_body2+1
	sta  p8b_boards.p8s_post_message.p8v_body
	sty  p8b_boards.p8s_post_message.p8v_body+1
	lda  p8v_reply_id
	ldy  p8v_reply_id+1
	sta  p8b_boards.p8s_post_message.p8v_reply_to_id
	sty  p8b_boards.p8s_post_message.p8v_reply_to_id+1
	jsr  p8b_boards.p8s_post_message
p8_label_gen_415_afterif
p8_label_gen_414_afterif
p8_label_gen_413_afterif
p8_label_gen_412_afterif
p8_label_gen_408_afterif
p8_label_gen_404_afterif
p8_label_gen_402_afterif
	jmp  p8_label_gen_397_afterif
p8_label_gen_398_else
	; source: boards.p8:573   running = false
	lda  #0
	sta  p8v_running
p8_label_gen_397_afterif
	; source: boards.p8:502   while running and session.is_active() {
	jmp  p8_label_gen_131_whileloop
p8_label_gen_132_afterwhile
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_board_name	.word  ?
p8v_body	.word  ?
p8v_body2	.word  ?
p8v_choice	.byte  ?
p8v_id_input	.word  ?
p8v_input	.word  ?
p8v_msg_id	.word  ?
p8v_reply_id	.word  ?
p8v_reply_id_input	.word  ?
p8v_running	.byte  ?
p8v_subject	.word  ?
p8v_subject2	.word  ?
	.send BSS
	.pend
prog8_init_vars	.block
	; source: boards.p8:18   uword REL_FILENAME = "bbsmsgs"
	lda  #<prog8_interned_strings.string_196
	ldy  #>prog8_interned_strings.string_196
	sta  p8b_boards.p8v_REL_FILENAME
	sty  p8b_boards.p8v_REL_FILENAME+1
	; source: boards.p8:38   uword @shared max_messages = 500  ; Maximum number of messages
	lda  #<$01f4
	ldy  #>$01f4
	sta  p8b_boards.p8v_max_messages
	sty  p8b_boards.p8v_max_messages+1
	rts
	.bend
	.pend

; ---- block: 'p8b_messaging' ----
p8b_messaging	.proc
	; source: messaging.p8:13   messaging {
p8v_messaging_initialized 	= 99 	; zp ubyte
p8v_max_messages 	= 100 	; zp uword
p8v_REL_FILENAME 	= 102 	; zp uword
	p8c_MSG_BODY_MAX = $30
	p8c_MSG_FROM_MAX = $14
	p8c_MSG_RECORD_SIZE = $80
	p8c_MSG_SUBJECT_MAX = $28
	p8c_MSG_TO_MAX = $14
	p8c_REL_CHANNEL = 4
	p8c_REL_DEVICE = 8
	p8c_REL_SECONDARY = 0


	; source: messaging.p8:15   const ubyte REL_CHANNEL = 4
	; source: messaging.p8:16   const ubyte REL_DEVICE = 8
	; source: messaging.p8:17   const ubyte REL_SECONDARY = 0
	; source: messaging.p8:18   uword REL_FILENAME = "bbsmail"
	; source: messaging.p8:21   const ubyte MSG_RECORD_SIZE = 128  ; Fixed record size
	; source: messaging.p8:22   const ubyte MSG_TO_MAX = 20        ; Maximum recipient name length
	; source: messaging.p8:23   const ubyte MSG_FROM_MAX = 20      ; Maximum sender name length
	; source: messaging.p8:24   const ubyte MSG_SUBJECT_MAX = 40   ; Maximum subject length
	; source: messaging.p8:25   const ubyte MSG_BODY_MAX = 48      ; Maximum body length
	; source: messaging.p8:34   ubyte @shared messaging_initialized = false
	; source: messaging.p8:35   uword @shared max_messages = 1000  ; Maximum number of messages
	; source: messaging.p8:38   sub init() -> bool {

p8s_init	.proc
; statements
	; source: messaging.p8:58   ubyte status = cbm.READST()
	; source: messaging.p8:52   ubyte rel_filename_len = strings.length(rel_filename)
	; source: messaging.p8:51   uword rel_filename = "bbsmail,L,128,R,1000"
	; source: messaging.p8:39   diskio.drivenumber = REL_DEVICE
	lda  #8
	sta  diskio.drivenumber
	; source: messaging.p8:42   if not diskio.exists(REL_FILENAME) {
	ldy  p8b_messaging.p8v_REL_FILENAME+1
	lda  p8b_messaging.p8v_REL_FILENAME
	jsr  diskio.exists
	cmp  #0
	bne  p8_label_gen_416_afterif
	; source: messaging.p8:44   txt.print("Creating messaging database...")
	ldy  #>prog8_interned_strings.string_140
	lda  #<prog8_interned_strings.string_140
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: messaging.p8:48   cbm.SETLFS(REL_CHANNEL, REL_DEVICE, REL_SECONDARY)
	ldy  #0
	ldx  #8
	lda  #4
	jsr  cbm.SETLFS
	; source: messaging.p8:51   uword rel_filename = "bbsmail,L,128,R,1000"
	lda  #<prog8_interned_strings.string_141
	ldy  #>prog8_interned_strings.string_141
	sta  p8v_rel_filename
	sty  p8v_rel_filename+1
	; source: messaging.p8:52   ubyte rel_filename_len = strings.length(rel_filename)
	jsr  strings.length
	sty  p8v_rel_filename_len
	; source: messaging.p8:53   cbm.SETNAM(rel_filename_len, rel_filename)
	ldy  p8v_rel_filename+1
	ldx  p8v_rel_filename
	lda  p8v_rel_filename_len
	jsr  cbm.SETNAM
	; source: messaging.p8:56   cbm.OPEN()
	jsr  cbm.OPEN
	; source: messaging.p8:58   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: messaging.p8:59   if status != 0 {
	lda  p8v_status
	beq  p8_label_gen_417_afterif
	; source: messaging.p8:60   txt.print("Error creating messaging file: ")
	ldy  #>prog8_interned_strings.string_142
	lda  #<prog8_interned_strings.string_142
	jsr  txt.print
	; source: messaging.p8:61   txt.print_ub(status)
	lda  p8v_status
	jsr  txt.print_ub
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
	; source: messaging.p8:63   return false
	lda  #0
	rts
p8_label_gen_417_afterif
	; source: messaging.p8:67   cbm.CLOSE(REL_CHANNEL)
	lda  #4
	jsr  cbm.CLOSE
	; source: messaging.p8:68   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: messaging.p8:70   txt.print("Messaging database created successfully")
	ldy  #>prog8_interned_strings.string_143
	lda  #<prog8_interned_strings.string_143
	jsr  txt.print
	; source: library:/prog8lib/shared_cbm_textio_functions.p8:19   chrout('\n')
	lda  #13
	jsr  txt.chrout
p8_label_gen_416_afterif
	; source: messaging.p8:74   messaging_initialized = 1
	lda  #1
	sta  p8b_messaging.p8v_messaging_initialized
	; source: messaging.p8:75   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_rel_filename	.word  ?
p8v_rel_filename_len	.byte  ?
p8v_status	.byte  ?
	.send BSS
	.pend
	; source: messaging.p8:79   sub open_rel() -> bool {

p8s_open_rel	.proc
; statements
	; source: messaging.p8:84   ubyte status = cbm.READST()
	; source: messaging.p8:80   cbm.SETLFS(REL_CHANNEL, REL_DEVICE, REL_SECONDARY)
	ldy  #0
	ldx  #8
	lda  #4
	jsr  cbm.SETLFS
	; source: messaging.p8:81   cbm.SETNAM(strings.length(REL_FILENAME), REL_FILENAME)
	ldy  p8b_messaging.p8v_REL_FILENAME+1
	ldx  p8b_messaging.p8v_REL_FILENAME
	txa
	pha
	tya
	pha
	ldy  p8b_messaging.p8v_REL_FILENAME+1
	lda  p8b_messaging.p8v_REL_FILENAME
	jsr  strings.length
	tya
	sta  P8ZP_SCRATCH_REG
	pla
	tay
	lda  P8ZP_SCRATCH_REG
	pla
	tax
	lda  P8ZP_SCRATCH_REG
	jsr  cbm.SETNAM
	; source: messaging.p8:82   cbm.OPEN()
	jsr  cbm.OPEN
	; source: messaging.p8:84   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: messaging.p8:85   if status != 0 {
	lda  p8v_status
	beq  p8_label_gen_418_afterif
	; source: messaging.p8:86   return false
	lda  #0
	rts
p8_label_gen_418_afterif
	; source: messaging.p8:89   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_status	.byte  ?
	.send BSS
	.pend
	; source: messaging.p8:93   sub close_rel() {

p8s_close_rel	.proc
; statements
	; source: messaging.p8:94   cbm.CLOSE(REL_CHANNEL)
	lda  #4
	jsr  cbm.CLOSE
	; source: messaging.p8:95   cbm.CLRCHN()
	jmp  cbm.CLRCHN
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: messaging.p8:99   sub seek_record(ubyte record_num) -> bool {

p8s_seek_record	.proc
p8v_status 	= 143 	; zp ubyte
p8v_record_num 	= 155 	; zp ubyte
p8v_rec_str 	= 158 	; zp uword
p8v_i 	= 167 	; zp uword
; simple int arg(s) passed via cpu register(s)
	sta  p8v_record_num
; statements
	; source: messaging.p8:109   uword rec_str = conv.str_ub(record_num)
	; source: messaging.p8:110   uword i = 0
	; source: messaging.p8:118   ubyte status = cbm.READST()
	; source: messaging.p8:100   cbm.CHKOUT(REL_CHANNEL)
	ldx  #4
	jsr  cbm.CHKOUT
	; source: messaging.p8:103   cbm.CHROUT($52)  ; 'R'
	lda  #$52
	jsr  cbm.CHROUT
	; source: messaging.p8:104   cbm.CHROUT($23)  ; '#'
	lda  #$23
	jsr  cbm.CHROUT
	; source: messaging.p8:105   cbm.CHROUT(REL_CHANNEL + $30)
	lda  #$34
	jsr  cbm.CHROUT
	; source: messaging.p8:106   cbm.CHROUT($2c)  ; ','
	lda  #$2c
	jsr  cbm.CHROUT
	; source: messaging.p8:109   uword rec_str = conv.str_ub(record_num)
	lda  p8v_record_num
	jsr  conv.str_ub
	sta  p8v_rec_str
	sty  p8v_rec_str+1
	; source: messaging.p8:110   uword i = 0
	lda  #0
	sta  p8v_i
	sta  p8v_i+1
	; source: messaging.p8:111   while i < strings.length(rec_str) {
p8_label_gen_133_whileloop
	ldy  p8v_rec_str+1
	lda  p8v_rec_str
	jsr  strings.length
	tya
	sta  P8ZP_SCRATCH_W2
	lda  #0
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8v_i+1
	lda  p8v_i
	cmp  P8ZP_SCRATCH_W2
	tya
	sbc  P8ZP_SCRATCH_W2+1
	bcs  p8_label_gen_134_afterwhile
	; source: messaging.p8:112   cbm.CHROUT(@(rec_str + i))
	lda  p8b_messaging.p8s_seek_record.p8v_rec_str
	sta  P8ZP_SCRATCH_W2
	lda  p8b_messaging.p8s_seek_record.p8v_rec_str+1
	clc
	adc  p8b_messaging.p8s_seek_record.p8v_i+1
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8b_messaging.p8s_seek_record.p8v_i
	lda  (P8ZP_SCRATCH_W2),y
	jsr  cbm.CHROUT
	; source: messaging.p8:113   i++
	inc  p8v_i
	bne  +
	inc  p8v_i+1
+
	; source: messaging.p8:111   while i < strings.length(rec_str) {
	jmp  p8_label_gen_133_whileloop
p8_label_gen_134_afterwhile
	; source: messaging.p8:116   cbm.CHROUT($0d)
	lda  #13
	jsr  cbm.CHROUT
	; source: messaging.p8:118   ubyte status = cbm.READST()
	jsr  cbm.READST
	sta  p8v_status
	; source: messaging.p8:119   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: messaging.p8:121   return status == 0
	lda  p8v_status
	beq  +
	lda  #1
+                           eor  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: messaging.p8:125   sub read_message(ubyte record_num, uword buffer) -> bool {

p8s_read_message	.proc
; statements
	; source: messaging.p8:139   ubyte ch = cbm.CHRIN()
	; source: messaging.p8:137   uword i = 0
	; source: messaging.p8:126   if not open_rel() {
	jsr  p8b_messaging.p8s_open_rel
	cmp  #0
	bne  p8_label_gen_419_afterif
	; source: messaging.p8:127   return false
	lda  #0
	rts
p8_label_gen_419_afterif
	; source: messaging.p8:130   if not seek_record(record_num) {
	lda  p8v_record_num
	jsr  p8b_messaging.p8s_seek_record
	cmp  #0
	bne  p8_label_gen_420_afterif
	; source: messaging.p8:131   close_rel()
	jsr  p8b_messaging.p8s_close_rel
	; source: messaging.p8:132   return false
	lda  #0
	rts
p8_label_gen_420_afterif
	; source: messaging.p8:135   cbm.CHKIN(REL_CHANNEL)
	ldx  #4
	jsr  cbm.CHKIN
	; source: messaging.p8:137   uword i = 0
	lda  #0
	sta  p8v_i
	sta  p8v_i+1
	; source: messaging.p8:138   while i < MSG_RECORD_SIZE {
p8_label_gen_135_whileloop
	ldy  p8v_i+1
	lda  p8v_i
	cmp  #<$80
	tya
	sbc  #>$80
	bcs  p8_label_gen_136_afterwhile
	; source: messaging.p8:139   ubyte ch = cbm.CHRIN()
	jsr  cbm.CHRIN
	sta  p8v_ch
	; source: messaging.p8:140   @(buffer + i) = ch
	tax
	lda  p8b_messaging.p8s_read_message.p8v_buffer
	sta  P8ZP_SCRATCH_W2
	lda  p8b_messaging.p8s_read_message.p8v_buffer+1
	clc
	adc  p8b_messaging.p8s_read_message.p8v_i+1
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8b_messaging.p8s_read_message.p8v_i
	txa
	sta  (P8ZP_SCRATCH_W2),y
	; source: messaging.p8:141   i++
	inc  p8v_i
	bne  +
	inc  p8v_i+1
+
	; source: messaging.p8:138   while i < MSG_RECORD_SIZE {
	jmp  p8_label_gen_135_whileloop
p8_label_gen_136_afterwhile
	; source: messaging.p8:144   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: messaging.p8:145   close_rel()
	jsr  p8b_messaging.p8s_close_rel
	; source: messaging.p8:147   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_buffer	.word  ?
p8v_ch	.byte  ?
p8v_i	.word  ?
p8v_record_num	.byte  ?
	.send BSS
	.pend
	; source: messaging.p8:151   sub write_message(ubyte record_num, uword buffer) -> bool {

p8s_write_message	.proc
p8v_record_num 	= 104 	; zp ubyte
p8v_i 	= 105 	; zp uword
p8v_buffer 	= 107 	; zp uword
; statements
	; source: messaging.p8:163   uword i = 0
	; source: messaging.p8:152   if not open_rel() {
	jsr  p8b_messaging.p8s_open_rel
	cmp  #0
	bne  p8_label_gen_421_afterif
	; source: messaging.p8:153   return false
	lda  #0
	rts
p8_label_gen_421_afterif
	; source: messaging.p8:156   if not seek_record(record_num) {
	lda  p8v_record_num
	jsr  p8b_messaging.p8s_seek_record
	cmp  #0
	bne  p8_label_gen_422_afterif
	; source: messaging.p8:157   close_rel()
	jsr  p8b_messaging.p8s_close_rel
	; source: messaging.p8:158   return false
	lda  #0
	rts
p8_label_gen_422_afterif
	; source: messaging.p8:161   cbm.CHKOUT(REL_CHANNEL)
	ldx  #4
	jsr  cbm.CHKOUT
	; source: messaging.p8:163   uword i = 0
	lda  #0
	sta  p8v_i
	sta  p8v_i+1
	; source: messaging.p8:164   while i < MSG_RECORD_SIZE {
p8_label_gen_137_whileloop
	ldy  p8v_i+1
	lda  p8v_i
	cmp  #<$80
	tya
	sbc  #>$80
	bcs  p8_label_gen_138_afterwhile
	; source: messaging.p8:165   cbm.CHROUT(@(buffer + i))
	lda  p8b_messaging.p8s_write_message.p8v_buffer
	sta  P8ZP_SCRATCH_W2
	lda  p8b_messaging.p8s_write_message.p8v_buffer+1
	clc
	adc  p8b_messaging.p8s_write_message.p8v_i+1
	sta  P8ZP_SCRATCH_W2+1
	ldy  p8b_messaging.p8s_write_message.p8v_i
	lda  (P8ZP_SCRATCH_W2),y
	jsr  cbm.CHROUT
	; source: messaging.p8:166   i++
	inc  p8v_i
	bne  +
	inc  p8v_i+1
+
	; source: messaging.p8:164   while i < MSG_RECORD_SIZE {
	jmp  p8_label_gen_137_whileloop
p8_label_gen_138_afterwhile
	; source: messaging.p8:169   cbm.CLRCHN()
	jsr  cbm.CLRCHN
	; source: messaging.p8:170   close_rel()
	jsr  p8b_messaging.p8s_close_rel
	; source: messaging.p8:172   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
	; source: messaging.p8:176   sub find_free_message() -> ubyte {

p8s_find_free_message	.proc
; statements
	; source: messaging.p8:177   ubyte[MSG_RECORD_SIZE] msg_buffer
	; source: messaging.p8:178   ubyte i = 0
	lda  #0
	sta  p8v_i
	; source: messaging.p8:180   while i < max_messages {
p8_label_gen_139_whileloop
	ldy  #0
	lda  p8v_i
	cmp  p8b_messaging.p8v_max_messages
	tya
	sbc  p8b_messaging.p8v_max_messages+1
	bcs  p8_label_gen_140_afterwhile
	; source: messaging.p8:181   if read_message(i, &msg_buffer) {
	lda  p8v_i
	sta  p8b_messaging.p8s_read_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_messaging.p8s_read_message.p8v_buffer
	sty  p8b_messaging.p8s_read_message.p8v_buffer+1
	jsr  p8b_messaging.p8s_read_message
	cmp  #0
	beq  p8_label_gen_423_afterif
	; source: messaging.p8:183   if msg_buffer[0] == 0 {
	lda  p8v_msg_buffer+0
	bne  p8_label_gen_424_afterif
	; source: messaging.p8:184   return i
	lda  p8v_i
	rts
p8_label_gen_424_afterif
p8_label_gen_423_afterif
	; source: messaging.p8:187   i++
	inc  p8v_i
	; source: messaging.p8:180   while i < max_messages {
	jmp  p8_label_gen_139_whileloop
p8_label_gen_140_afterwhile
	; source: messaging.p8:190   return 255  ; No free records
	lda  #$ff
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_i	.byte  ?
p8v_msg_buffer	.fill  128
	.send BSS
	.pend
	; source: messaging.p8:194   sub count_inbox(uword username) -> ubyte {

p8s_count_inbox	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_username
	sty  p8v_username+1
; statements
	; source: messaging.p8:204   ubyte j = 0
	; source: messaging.p8:203   bool match = true
	; source: messaging.p8:207   ubyte usr_char = @(username + j)
	; source: messaging.p8:206   ubyte rec_char = msg_buffer[j]
	; source: messaging.p8:195   ubyte[MSG_RECORD_SIZE] msg_buffer
	; source: messaging.p8:196   ubyte count = 0
	; source: messaging.p8:197   ubyte i = 0
	; source: messaging.p8:196   ubyte count = 0
	lda  #0
	sta  p8v_count
	; source: messaging.p8:197   ubyte i = 0
	sta  p8v_i
	; source: messaging.p8:199   while i < max_messages {
p8_label_gen_145_whileloop
	ldy  #0
	lda  p8v_i
	cmp  p8b_messaging.p8v_max_messages
	tya
	sbc  p8b_messaging.p8v_max_messages+1
	bcs  p8_label_gen_146_afterwhile
	; source: messaging.p8:200   if read_message(i, &msg_buffer) {
	lda  p8v_i
	sta  p8b_messaging.p8s_read_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_messaging.p8s_read_message.p8v_buffer
	sty  p8b_messaging.p8s_read_message.p8v_buffer+1
	jsr  p8b_messaging.p8s_read_message
	cmp  #0
	beq  p8_label_gen_425_afterif
	; source: messaging.p8:201   if msg_buffer[0] != 0 {  ; Active message
	lda  p8v_msg_buffer+0
	beq  p8_label_gen_426_afterif
	; source: messaging.p8:203   bool match = true
	lda  #1
	sta  p8v_match
	; source: messaging.p8:204   ubyte j = 0
	lda  #0
	sta  p8v_j
	; source: messaging.p8:205   while j < MSG_TO_MAX {
p8_label_gen_143_whileloop
	lda  p8v_j
	cmp  #20
	bcs  p8_label_gen_144_afterwhile
	; source: messaging.p8:206   ubyte rec_char = msg_buffer[j]
	ldy  p8v_j
	lda  p8v_msg_buffer,y
	sta  p8v_rec_char
	; source: messaging.p8:207   ubyte usr_char = @(username + j)
	lda  p8v_username
	ldy  p8v_username+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  p8v_j
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8v_usr_char
	; source: messaging.p8:209   if rec_char == 0 and usr_char == 0 {
	lda  p8v_rec_char
	ora  p8v_usr_char
	beq  p8_label_gen_141_after
	; source: messaging.p8:212   if rec_char != usr_char {
	lda  p8v_rec_char
	cmp  p8v_usr_char
	beq  p8_label_gen_427_afterif
	; source: messaging.p8:213   match = false
	lda  #0
	sta  p8v_match
	; source: messaging.p8:214   break
	jmp  p8_label_gen_142_after
p8_label_gen_427_afterif
	; source: messaging.p8:216   j++
	inc  p8v_j
	; source: messaging.p8:205   while j < MSG_TO_MAX {
	jmp  p8_label_gen_143_whileloop
p8_label_gen_144_afterwhile
	; source: messaging.p8:214   break
p8_label_gen_142_after
	; source: messaging.p8:210   break
p8_label_gen_141_after
	; source: messaging.p8:219   if match {
	lda  p8v_match
	beq  p8_label_gen_428_afterif
	; source: messaging.p8:221   if (msg_buffer[127] & $02) == 0 {
	lda  p8v_msg_buffer+127
	and  #2
	bne  p8_label_gen_429_afterif
	; source: messaging.p8:222   count++
	inc  p8v_count
p8_label_gen_429_afterif
p8_label_gen_428_afterif
p8_label_gen_426_afterif
p8_label_gen_425_afterif
	; source: messaging.p8:227   i++
	inc  p8v_i
	; source: messaging.p8:199   while i < max_messages {
	jmp  p8_label_gen_145_whileloop
p8_label_gen_146_afterwhile
	; source: messaging.p8:230   return count
	lda  p8v_count
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_count	.byte  ?
p8v_i	.byte  ?
p8v_j	.byte  ?
p8v_match	.byte  ?
p8v_msg_buffer	.fill  128
p8v_rec_char	.byte  ?
p8v_username	.word  ?
p8v_usr_char	.byte  ?
	.send BSS
	.pend
	; source: messaging.p8:234   sub count_unread(uword username) -> ubyte {

p8s_count_unread	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_username
	sty  p8v_username+1
; statements
	; source: messaging.p8:244   ubyte j = 0
	; source: messaging.p8:243   bool match = true
	; source: messaging.p8:247   ubyte usr_char = @(username + j)
	; source: messaging.p8:246   ubyte rec_char = msg_buffer[j]
	; source: messaging.p8:235   ubyte[MSG_RECORD_SIZE] msg_buffer
	; source: messaging.p8:236   ubyte count = 0
	; source: messaging.p8:237   ubyte i = 0
	; source: messaging.p8:236   ubyte count = 0
	lda  #0
	sta  p8v_count
	; source: messaging.p8:237   ubyte i = 0
	sta  p8v_i
	; source: messaging.p8:239   while i < max_messages {
p8_label_gen_151_whileloop
	ldy  #0
	lda  p8v_i
	cmp  p8b_messaging.p8v_max_messages
	tya
	sbc  p8b_messaging.p8v_max_messages+1
	bcs  p8_label_gen_152_afterwhile
	; source: messaging.p8:240   if read_message(i, &msg_buffer) {
	lda  p8v_i
	sta  p8b_messaging.p8s_read_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_messaging.p8s_read_message.p8v_buffer
	sty  p8b_messaging.p8s_read_message.p8v_buffer+1
	jsr  p8b_messaging.p8s_read_message
	cmp  #0
	beq  p8_label_gen_430_afterif
	; source: messaging.p8:241   if msg_buffer[0] != 0 {
	lda  p8v_msg_buffer+0
	beq  p8_label_gen_431_afterif
	; source: messaging.p8:243   bool match = true
	lda  #1
	sta  p8v_match
	; source: messaging.p8:244   ubyte j = 0
	lda  #0
	sta  p8v_j
	; source: messaging.p8:245   while j < MSG_TO_MAX {
p8_label_gen_149_whileloop
	lda  p8v_j
	cmp  #20
	bcs  p8_label_gen_150_afterwhile
	; source: messaging.p8:246   ubyte rec_char = msg_buffer[j]
	ldy  p8v_j
	lda  p8v_msg_buffer,y
	sta  p8v_rec_char
	; source: messaging.p8:247   ubyte usr_char = @(username + j)
	lda  p8v_username
	ldy  p8v_username+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  p8v_j
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8v_usr_char
	; source: messaging.p8:249   if rec_char == 0 and usr_char == 0 {
	lda  p8v_rec_char
	ora  p8v_usr_char
	beq  p8_label_gen_147_after
	; source: messaging.p8:252   if rec_char != usr_char {
	lda  p8v_rec_char
	cmp  p8v_usr_char
	beq  p8_label_gen_432_afterif
	; source: messaging.p8:253   match = false
	lda  #0
	sta  p8v_match
	; source: messaging.p8:254   break
	jmp  p8_label_gen_148_after
p8_label_gen_432_afterif
	; source: messaging.p8:256   j++
	inc  p8v_j
	; source: messaging.p8:245   while j < MSG_TO_MAX {
	jmp  p8_label_gen_149_whileloop
p8_label_gen_150_afterwhile
	; source: messaging.p8:254   break
p8_label_gen_148_after
	; source: messaging.p8:250   break
p8_label_gen_147_after
	; source: messaging.p8:259   if match {
	lda  p8v_match
	beq  p8_label_gen_433_afterif
	; source: messaging.p8:261   if (msg_buffer[127] & $01) == 0 and (msg_buffer[127] & $02) == 0 {
	lda  p8v_msg_buffer+127
	and  #1
	beq  +
	lda  #1
+                           eor  #1
	beq  p8_label_gen_434_shortcut
	lda  p8v_msg_buffer+127
	and  #2
	beq  +
	lda  #1
+                           eor  #1
p8_label_gen_434_shortcut
	beq  p8_label_gen_435_afterif
	; source: messaging.p8:262   count++
	inc  p8v_count
p8_label_gen_435_afterif
p8_label_gen_433_afterif
p8_label_gen_431_afterif
p8_label_gen_430_afterif
	; source: messaging.p8:267   i++
	inc  p8v_i
	; source: messaging.p8:239   while i < max_messages {
	jmp  p8_label_gen_151_whileloop
p8_label_gen_152_afterwhile
	; source: messaging.p8:270   return count
	lda  p8v_count
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_count	.byte  ?
p8v_i	.byte  ?
p8v_j	.byte  ?
p8v_match	.byte  ?
p8v_msg_buffer	.fill  128
p8v_rec_char	.byte  ?
p8v_username	.word  ?
p8v_usr_char	.byte  ?
	.send BSS
	.pend
	; source: messaging.p8:274   sub list_inbox(uword username) {

p8s_list_inbox	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_username
	sty  p8v_username+1
; statements
	; source: messaging.p8:307   ubyte j = 0
	; source: messaging.p8:306   bool match = true
	; source: messaging.p8:335   uword num_str = conv.str_ub(i)
	; source: messaging.p8:325   uword subject = &msg_buffer + 40
	; source: messaging.p8:324   uword from = &msg_buffer + 20
	; source: messaging.p8:310   ubyte usr_char = @(username + j)
	; source: messaging.p8:309   ubyte rec_char = msg_buffer[j]
	; source: messaging.p8:279   ubyte unread = count_unread(username)
	; source: messaging.p8:280   ubyte total = count_inbox(username)
	; source: messaging.p8:283   uword total_str = conv.str_ub(total)
	; source: messaging.p8:286   uword unread_str = conv.str_ub(unread)
	; source: messaging.p8:298   ubyte[MSG_RECORD_SIZE] msg_buffer
	; source: messaging.p8:299   ubyte displayed = 0
	; source: messaging.p8:300   ubyte i = 0
	; source: messaging.p8:275   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:276   session.send_line("=== Inbox ===")
	ldy  #>prog8_interned_strings.string_144
	lda  #<prog8_interned_strings.string_144
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:277   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:279   ubyte unread = count_unread(username)
	ldy  p8v_username+1
	lda  p8v_username
	jsr  p8b_messaging.p8s_count_unread
	sta  p8v_unread
	; source: messaging.p8:280   ubyte total = count_inbox(username)
	ldy  p8v_username+1
	lda  p8v_username
	jsr  p8b_messaging.p8s_count_inbox
	sta  p8v_total
	; source: messaging.p8:282   session.send_string("Messages: ")
	ldy  #>prog8_interned_strings.string_114
	lda  #<prog8_interned_strings.string_114
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:283   uword total_str = conv.str_ub(total)
	lda  p8v_total
	jsr  conv.str_ub
	sta  p8v_total_str
	sty  p8v_total_str+1
	; source: messaging.p8:284   session.send_string(total_str)
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:285   session.send_string(" (")
	ldy  #>prog8_interned_strings.string_145
	lda  #<prog8_interned_strings.string_145
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:286   uword unread_str = conv.str_ub(unread)
	lda  p8v_unread
	jsr  conv.str_ub
	sta  p8v_unread_str
	sty  p8v_unread_str+1
	; source: messaging.p8:287   session.send_string(unread_str)
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:288   session.send_string(" unread)")
	ldy  #>prog8_interned_strings.string_146
	lda  #<prog8_interned_strings.string_146
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:289   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:290   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:292   if total == 0 {
	lda  p8v_total
	bne  p8_label_gen_436_afterif
	; source: messaging.p8:293   session.send_line("No messages.")
	ldy  #>prog8_interned_strings.string_147
	lda  #<prog8_interned_strings.string_147
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:294   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jmp  p8b_session.p8s_send_line
	; source: messaging.p8:295   return
p8_label_gen_436_afterif
	; source: messaging.p8:299   ubyte displayed = 0
	lda  #0
	sta  p8v_displayed
	; source: messaging.p8:300   ubyte i = 0
	sta  p8v_i
	; source: messaging.p8:302   while i < max_messages and displayed < 20 {
p8_label_gen_157_whileloop
	ldy  #0
	lda  p8v_i
	cmp  p8b_messaging.p8v_max_messages
	tya
	sbc  p8b_messaging.p8v_max_messages+1
	bcs  p8_label_gen_439_else
	lda  #1
	jmp  p8_label_gen_438_afterif
p8_label_gen_439_else
	lda  #0
p8_label_gen_438_afterif
	beq  p8_label_gen_437_shortcut
	lda  p8v_displayed
	cmp  #20
	rol  a
	and  #1
	eor  #1
p8_label_gen_437_shortcut
	beq  p8_label_gen_158_afterwhile
	; source: messaging.p8:303   if read_message(i, &msg_buffer) {
	lda  p8v_i
	sta  p8b_messaging.p8s_read_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_messaging.p8s_read_message.p8v_buffer
	sty  p8b_messaging.p8s_read_message.p8v_buffer+1
	jsr  p8b_messaging.p8s_read_message
	cmp  #0
	beq  p8_label_gen_440_afterif
	; source: messaging.p8:304   if msg_buffer[0] != 0 {
	lda  p8v_msg_buffer+0
	beq  p8_label_gen_441_afterif
	; source: messaging.p8:306   bool match = true
	lda  #1
	sta  p8v_match
	; source: messaging.p8:307   ubyte j = 0
	lda  #0
	sta  p8v_j
	; source: messaging.p8:308   while j < MSG_TO_MAX {
p8_label_gen_155_whileloop
	lda  p8v_j
	cmp  #20
	bcs  p8_label_gen_156_afterwhile
	; source: messaging.p8:309   ubyte rec_char = msg_buffer[j]
	ldy  p8v_j
	lda  p8v_msg_buffer,y
	sta  p8v_rec_char
	; source: messaging.p8:310   ubyte usr_char = @(username + j)
	lda  p8v_username
	ldy  p8v_username+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  p8v_j
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8v_usr_char
	; source: messaging.p8:312   if rec_char == 0 and usr_char == 0 {
	lda  p8v_rec_char
	ora  p8v_usr_char
	beq  p8_label_gen_153_after
	; source: messaging.p8:315   if rec_char != usr_char {
	lda  p8v_rec_char
	cmp  p8v_usr_char
	beq  p8_label_gen_442_afterif
	; source: messaging.p8:316   match = false
	lda  #0
	sta  p8v_match
	; source: messaging.p8:317   break
	jmp  p8_label_gen_154_after
p8_label_gen_442_afterif
	; source: messaging.p8:319   j++
	inc  p8v_j
	; source: messaging.p8:308   while j < MSG_TO_MAX {
	jmp  p8_label_gen_155_whileloop
p8_label_gen_156_afterwhile
	; source: messaging.p8:317   break
p8_label_gen_154_after
	; source: messaging.p8:313   break
p8_label_gen_153_after
	; source: messaging.p8:322   if match and (msg_buffer[127] & $02) == 0 {  ; Not deleted
	lda  p8v_match
	beq  p8_label_gen_443_shortcut
	lda  p8v_msg_buffer+127
	and  #2
	beq  +
	lda  #1
+                           eor  #1
p8_label_gen_443_shortcut
	beq  p8_label_gen_444_afterif
	; source: messaging.p8:324   uword from = &msg_buffer + 20
	ldy  #>p8v_msg_buffer
	lda  #<p8v_msg_buffer
	clc
	adc  #$14
	bcc  +
	iny
+
	sta  p8v_from
	sty  p8v_from+1
	; source: messaging.p8:325   uword subject = &msg_buffer + 40
	ldy  #>p8v_msg_buffer
	lda  #<p8v_msg_buffer
	clc
	adc  #$28
	bcc  +
	iny
+
	sta  p8v_subject
	sty  p8v_subject+1
	; source: messaging.p8:328   if (msg_buffer[127] & $01) == 0 {
	lda  p8v_msg_buffer+127
	and  #1
	bne  p8_label_gen_446_else
	; source: messaging.p8:329   session.send_string("* ")  ; Unread
	ldy  #>prog8_interned_strings.string_148
	lda  #<prog8_interned_strings.string_148
	jsr  p8b_session.p8s_send_string
	jmp  p8_label_gen_445_afterif
p8_label_gen_446_else
	; source: messaging.p8:331   session.send_string("  ")  ; Read
	ldy  #>prog8_interned_strings.string_149
	lda  #<prog8_interned_strings.string_149
	jsr  p8b_session.p8s_send_string
p8_label_gen_445_afterif
	; source: messaging.p8:334   session.send_string("[")
	ldy  #>prog8_interned_strings.string_115
	lda  #<prog8_interned_strings.string_115
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:335   uword num_str = conv.str_ub(i)
	lda  p8v_i
	jsr  conv.str_ub
	sta  p8v_num_str
	sty  p8v_num_str+1
	; source: messaging.p8:336   session.send_string(num_str)
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:337   session.send_string("] ")
	ldy  #>prog8_interned_strings.string_116
	lda  #<prog8_interned_strings.string_116
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:338   session.send_string(subject)
	ldy  p8v_subject+1
	lda  p8v_subject
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:339   session.send_string(" from ")
	ldy  #>prog8_interned_strings.string_150
	lda  #<prog8_interned_strings.string_150
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:340   session.send_string(from)
	ldy  p8v_from+1
	lda  p8v_from
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:341   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:343   displayed++
	inc  p8v_displayed
p8_label_gen_444_afterif
p8_label_gen_441_afterif
p8_label_gen_440_afterif
	; source: messaging.p8:347   i++
	inc  p8v_i
	; source: messaging.p8:302   while i < max_messages and displayed < 20 {
	jmp  p8_label_gen_157_whileloop
p8_label_gen_158_afterwhile
	; source: messaging.p8:350   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jmp  p8b_session.p8s_send_line
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_displayed	.byte  ?
p8v_from	.word  ?
p8v_i	.byte  ?
p8v_j	.byte  ?
p8v_match	.byte  ?
p8v_msg_buffer	.fill  128
p8v_num_str	.word  ?
p8v_rec_char	.byte  ?
p8v_subject	.word  ?
p8v_total	.byte  ?
p8v_total_str	.word  ?
p8v_unread	.byte  ?
p8v_unread_str	.word  ?
p8v_username	.word  ?
p8v_usr_char	.byte  ?
	.send BSS
	.pend
	; source: messaging.p8:354   sub read_message_by_num(ubyte msg_num, uword username) -> bool {

p8s_read_message_by_num	.proc
p8v_usr_char 	= 156 	; zp ubyte
p8v_username 	= 169 	; zp uword
p8v_rec_char 	= 171 	; zp ubyte
p8v_subject 	= 176 	; zp uword
p8v_msg_num 	= 180 	; zp ubyte
p8v_match 	= 181 	; zp bool
p8v_j 	= 182 	; zp ubyte
; statements
	; source: messaging.p8:370   ubyte usr_char = @(username + j)
	; source: messaging.p8:369   ubyte rec_char = msg_buffer[j]
	; source: messaging.p8:355   ubyte[MSG_RECORD_SIZE] msg_buffer
	; source: messaging.p8:366   bool match = true
	; source: messaging.p8:367   ubyte j = 0
	; source: messaging.p8:391   uword from = &msg_buffer + 20
	; source: messaging.p8:392   uword subject = &msg_buffer + 40
	; source: messaging.p8:393   uword body = &msg_buffer + 80
	; source: messaging.p8:357   if not read_message(msg_num, &msg_buffer) {
	lda  p8v_msg_num
	sta  p8b_messaging.p8s_read_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_messaging.p8s_read_message.p8v_buffer
	sty  p8b_messaging.p8s_read_message.p8v_buffer+1
	jsr  p8b_messaging.p8s_read_message
	cmp  #0
	bne  p8_label_gen_447_afterif
	; source: messaging.p8:358   return false
	lda  #0
	rts
p8_label_gen_447_afterif
	; source: messaging.p8:361   if msg_buffer[0] == 0 {
	lda  p8v_msg_buffer+0
	bne  p8_label_gen_448_afterif
	; source: messaging.p8:362   return false  ; Empty record
	lda  #0
	rts
p8_label_gen_448_afterif
	; source: messaging.p8:366   bool match = true
	lda  #1
	sta  p8v_match
	; source: messaging.p8:367   ubyte j = 0
	lda  #0
	sta  p8v_j
	; source: messaging.p8:368   while j < MSG_TO_MAX {
p8_label_gen_161_whileloop
	lda  p8v_j
	cmp  #20
	bcs  p8_label_gen_162_afterwhile
	; source: messaging.p8:369   ubyte rec_char = msg_buffer[j]
	ldy  p8v_j
	lda  p8v_msg_buffer,y
	sta  p8v_rec_char
	; source: messaging.p8:370   ubyte usr_char = @(username + j)
	ldy  p8v_j
	lda  (p8v_username),y
	sta  p8v_usr_char
	; source: messaging.p8:372   if rec_char == 0 and usr_char == 0 {
	lda  p8v_rec_char
	ora  p8v_usr_char
	beq  p8_label_gen_159_after
	; source: messaging.p8:375   if rec_char != usr_char {
	lda  p8v_rec_char
	cmp  p8v_usr_char
	beq  p8_label_gen_449_afterif
	; source: messaging.p8:376   match = false
	lda  #0
	sta  p8v_match
	; source: messaging.p8:377   break
	jmp  p8_label_gen_160_after
p8_label_gen_449_afterif
	; source: messaging.p8:379   j++
	inc  p8v_j
	; source: messaging.p8:368   while j < MSG_TO_MAX {
	jmp  p8_label_gen_161_whileloop
p8_label_gen_162_afterwhile
	; source: messaging.p8:377   break
p8_label_gen_160_after
	; source: messaging.p8:373   break
p8_label_gen_159_after
	; source: messaging.p8:382   if not match {
	lda  p8v_match
	bne  p8_label_gen_450_afterif
	; source: messaging.p8:383   return false  ; Not for this user
	lda  #0
	rts
p8_label_gen_450_afterif
	; source: messaging.p8:387   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:388   session.send_line("=== Message ===")
	ldy  #>prog8_interned_strings.string_118
	lda  #<prog8_interned_strings.string_118
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:389   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:391   uword from = &msg_buffer + 20
	ldy  #>p8v_msg_buffer
	lda  #<p8v_msg_buffer
	clc
	adc  #$14
	bcc  +
	iny
+
	sta  p8v_from
	sty  p8v_from+1
	; source: messaging.p8:392   uword subject = &msg_buffer + 40
	ldy  #>p8v_msg_buffer
	lda  #<p8v_msg_buffer
	clc
	adc  #$28
	bcc  +
	iny
+
	sta  p8v_subject
	sty  p8v_subject+1
	; source: messaging.p8:393   uword body = &msg_buffer + 80
	ldy  #>p8v_msg_buffer
	lda  #<p8v_msg_buffer
	clc
	adc  #$50
	bcc  +
	iny
+
	sta  p8v_body
	sty  p8v_body+1
	; source: messaging.p8:395   session.send_string("From: ")
	ldy  #>prog8_interned_strings.string_120
	lda  #<prog8_interned_strings.string_120
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:396   session.send_string(from)
	ldy  p8v_from+1
	lda  p8v_from
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:397   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:398   session.send_string("Subject: ")
	ldy  #>prog8_interned_strings.string_119
	lda  #<prog8_interned_strings.string_119
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:399   session.send_string(subject)
	ldy  p8v_subject+1
	lda  p8v_subject
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:400   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:401   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:402   session.send_string(body)
	ldy  p8v_body+1
	lda  p8v_body
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:403   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:404   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:407   msg_buffer[127] = msg_buffer[127] | $01  ; Set read bit
	lda  p8v_msg_buffer + 127
	ora  #1
	sta  p8v_msg_buffer + 127
	; source: messaging.p8:408   write_message(msg_num, &msg_buffer)
	lda  p8v_msg_num
	sta  p8b_messaging.p8s_write_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_messaging.p8s_write_message.p8v_buffer
	sty  p8b_messaging.p8s_write_message.p8v_buffer+1
	jsr  p8b_messaging.p8s_write_message
	; source: messaging.p8:410   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_body	.word  ?
p8v_from	.word  ?
p8v_msg_buffer	.fill  128
	.send BSS
	.pend
	; source: messaging.p8:414   sub send_message(uword to_username, uword subject, uword body) -> bool {

p8s_send_message	.proc
p8v_to_username 	= 129 	; zp uword
p8v_to_len 	= 131 	; zp ubyte
p8v_subject_len 	= 132 	; zp ubyte
p8v_subject 	= 133 	; zp uword
p8v_record_num 	= 135 	; zp ubyte
p8v_i 	= 136 	; zp ubyte
p8v_from_username 	= 137 	; zp uword
p8v_from_len 	= 139 	; zp ubyte
p8v_body_len 	= 140 	; zp ubyte
p8v_body 	= 141 	; zp uword
; statements
	; source: messaging.p8:415   ubyte record_num = find_free_message()
	; source: messaging.p8:421   uword from_username = login.get_username()
	; source: messaging.p8:424   ubyte[MSG_RECORD_SIZE] msg_buffer
	; source: messaging.p8:427   ubyte i = 0
	; source: messaging.p8:434   ubyte to_len = strings.length(to_username)
	; source: messaging.p8:445   ubyte from_len = strings.length(from_username)
	; source: messaging.p8:456   ubyte subject_len = strings.length(subject)
	; source: messaging.p8:467   ubyte body_len = strings.length(body)
	; source: messaging.p8:415   ubyte record_num = find_free_message()
	jsr  p8b_messaging.p8s_find_free_message
	sta  p8v_record_num
	; source: messaging.p8:416   if record_num == 255 {
	cmp  #255
	bne  p8_label_gen_451_afterif
	; source: messaging.p8:417   session.send_line("Error: Message database full!")
	ldy  #>prog8_interned_strings.string_121
	lda  #<prog8_interned_strings.string_121
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:418   return false
	lda  #0
	rts
p8_label_gen_451_afterif
	; source: messaging.p8:421   uword from_username = login.get_username()
	lda  p8b_login.p8v_current_username
	ldy  p8b_login.p8v_current_username+1
	sta  p8v_from_username
	sty  p8v_from_username+1
	; source: messaging.p8:427   ubyte i = 0
	lda  #0
	sta  p8v_i
	; source: messaging.p8:428   while i < MSG_RECORD_SIZE {
p8_label_gen_163_whileloop
	lda  p8v_i
	cmp  #128
	bcs  p8_label_gen_164_afterwhile
	; source: messaging.p8:429   msg_buffer[i] = 0
	ldy  p8v_i
	lda  #0
	sta  p8v_msg_buffer,y
	; source: messaging.p8:430   i++
	inc  p8v_i
	; source: messaging.p8:428   while i < MSG_RECORD_SIZE {
	jmp  p8_label_gen_163_whileloop
p8_label_gen_164_afterwhile
	; source: messaging.p8:434   ubyte to_len = strings.length(to_username)
	ldy  p8v_to_username+1
	lda  p8v_to_username
	jsr  strings.length
	sty  p8v_to_len
	; source: messaging.p8:435   if to_len > MSG_TO_MAX {
	lda  p8v_to_len
	cmp  #21
	bcc  p8_label_gen_452_afterif
	; source: messaging.p8:436   to_len = MSG_TO_MAX
	lda  #$14
	sta  p8v_to_len
p8_label_gen_452_afterif
	; source: messaging.p8:438   i = 0
	lda  #0
	sta  p8v_i
	; source: messaging.p8:439   while i < to_len {
p8_label_gen_165_whileloop
	lda  p8v_i
	cmp  p8v_to_len
	bcs  p8_label_gen_166_afterwhile
	; source: messaging.p8:440   msg_buffer[i] = @(to_username + i)
	ldy  p8v_i
	lda  (p8v_to_username),y
	ldy  p8v_i
	sta  p8v_msg_buffer,y
	; source: messaging.p8:441   i++
	inc  p8v_i
	; source: messaging.p8:439   while i < to_len {
	jmp  p8_label_gen_165_whileloop
p8_label_gen_166_afterwhile
	; source: messaging.p8:445   ubyte from_len = strings.length(from_username)
	ldy  p8v_from_username+1
	lda  p8v_from_username
	jsr  strings.length
	sty  p8v_from_len
	; source: messaging.p8:446   if from_len > MSG_FROM_MAX {
	lda  p8v_from_len
	cmp  #21
	bcc  p8_label_gen_453_afterif
	; source: messaging.p8:447   from_len = MSG_FROM_MAX
	lda  #$14
	sta  p8v_from_len
p8_label_gen_453_afterif
	; source: messaging.p8:449   i = 0
	lda  #0
	sta  p8v_i
	; source: messaging.p8:450   while i < from_len {
p8_label_gen_167_whileloop
	lda  p8v_i
	cmp  p8v_from_len
	bcs  p8_label_gen_168_afterwhile
	; source: messaging.p8:451   msg_buffer[20 + i] = @(from_username + i)
	ldy  p8v_i
	lda  (p8v_from_username),y
	pha
	lda  p8v_i
	clc
	adc  #$14
	tay
	pla
	sta  p8v_msg_buffer,y
	; source: messaging.p8:452   i++
	inc  p8v_i
	; source: messaging.p8:450   while i < from_len {
	jmp  p8_label_gen_167_whileloop
p8_label_gen_168_afterwhile
	; source: messaging.p8:456   ubyte subject_len = strings.length(subject)
	ldy  p8v_subject+1
	lda  p8v_subject
	jsr  strings.length
	sty  p8v_subject_len
	; source: messaging.p8:457   if subject_len > MSG_SUBJECT_MAX {
	lda  p8v_subject_len
	cmp  #41
	bcc  p8_label_gen_454_afterif
	; source: messaging.p8:458   subject_len = MSG_SUBJECT_MAX
	lda  #$28
	sta  p8v_subject_len
p8_label_gen_454_afterif
	; source: messaging.p8:460   i = 0
	lda  #0
	sta  p8v_i
	; source: messaging.p8:461   while i < subject_len {
p8_label_gen_169_whileloop
	lda  p8v_i
	cmp  p8v_subject_len
	bcs  p8_label_gen_170_afterwhile
	; source: messaging.p8:462   msg_buffer[40 + i] = @(subject + i)
	ldy  p8v_i
	lda  (p8v_subject),y
	pha
	lda  p8v_i
	clc
	adc  #$28
	tay
	pla
	sta  p8v_msg_buffer,y
	; source: messaging.p8:463   i++
	inc  p8v_i
	; source: messaging.p8:461   while i < subject_len {
	jmp  p8_label_gen_169_whileloop
p8_label_gen_170_afterwhile
	; source: messaging.p8:467   ubyte body_len = strings.length(body)
	ldy  p8v_body+1
	lda  p8v_body
	jsr  strings.length
	sty  p8v_body_len
	; source: messaging.p8:468   if body_len > MSG_BODY_MAX {
	lda  p8v_body_len
	cmp  #49
	bcc  p8_label_gen_455_afterif
	; source: messaging.p8:469   body_len = MSG_BODY_MAX
	lda  #$30
	sta  p8v_body_len
p8_label_gen_455_afterif
	; source: messaging.p8:471   i = 0
	lda  #0
	sta  p8v_i
	; source: messaging.p8:472   while i < body_len {
p8_label_gen_171_whileloop
	lda  p8v_i
	cmp  p8v_body_len
	bcs  p8_label_gen_172_afterwhile
	; source: messaging.p8:473   msg_buffer[80 + i] = @(body + i)
	ldy  p8v_i
	lda  (p8v_body),y
	pha
	lda  p8v_i
	clc
	adc  #$50
	tay
	pla
	sta  p8v_msg_buffer,y
	; source: messaging.p8:474   i++
	inc  p8v_i
	; source: messaging.p8:472   while i < body_len {
	jmp  p8_label_gen_171_whileloop
p8_label_gen_172_afterwhile
	; source: messaging.p8:478   msg_buffer[127] = $00
	lda  #0
	sta  p8v_msg_buffer+127
	; source: messaging.p8:481   if write_message(record_num, &msg_buffer) {
	lda  p8v_record_num
	sta  p8b_messaging.p8s_write_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_messaging.p8s_write_message.p8v_buffer
	sty  p8b_messaging.p8s_write_message.p8v_buffer+1
	jsr  p8b_messaging.p8s_write_message
	cmp  #0
	beq  p8_label_gen_456_afterif
	; source: messaging.p8:482   session.send_line("Message sent successfully!")
	ldy  #>prog8_interned_strings.string_151
	lda  #<prog8_interned_strings.string_151
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:483   return true
	lda  #1
	rts
p8_label_gen_456_afterif
	; source: messaging.p8:486   return false
	lda  #0
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_msg_buffer	.fill  128
	.send BSS
	.pend
	; source: messaging.p8:490   sub delete_message(ubyte msg_num, uword username) -> bool {

p8s_delete_message	.proc
; statements
	; source: messaging.p8:502   ubyte usr_char = @(username + j)
	; source: messaging.p8:501   ubyte rec_char = msg_buffer[j]
	; source: messaging.p8:491   ubyte[MSG_RECORD_SIZE] msg_buffer
	; source: messaging.p8:498   bool match = true
	; source: messaging.p8:499   ubyte j = 0
	; source: messaging.p8:493   if not read_message(msg_num, &msg_buffer) {
	lda  p8v_msg_num
	sta  p8b_messaging.p8s_read_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_messaging.p8s_read_message.p8v_buffer
	sty  p8b_messaging.p8s_read_message.p8v_buffer+1
	jsr  p8b_messaging.p8s_read_message
	cmp  #0
	bne  p8_label_gen_457_afterif
	; source: messaging.p8:494   return false
	lda  #0
	rts
p8_label_gen_457_afterif
	; source: messaging.p8:498   bool match = true
	lda  #1
	sta  p8v_match
	; source: messaging.p8:499   ubyte j = 0
	lda  #0
	sta  p8v_j
	; source: messaging.p8:500   while j < MSG_TO_MAX {
p8_label_gen_175_whileloop
	lda  p8v_j
	cmp  #20
	bcs  p8_label_gen_176_afterwhile
	; source: messaging.p8:501   ubyte rec_char = msg_buffer[j]
	ldy  p8v_j
	lda  p8v_msg_buffer,y
	sta  p8v_rec_char
	; source: messaging.p8:502   ubyte usr_char = @(username + j)
	lda  p8v_username
	ldy  p8v_username+1
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  p8v_j
	lda  (P8ZP_SCRATCH_W2),y
	sta  p8v_usr_char
	; source: messaging.p8:504   if rec_char == 0 and usr_char == 0 {
	lda  p8v_rec_char
	ora  p8v_usr_char
	beq  p8_label_gen_173_after
	; source: messaging.p8:507   if rec_char != usr_char {
	lda  p8v_rec_char
	cmp  p8v_usr_char
	beq  p8_label_gen_458_afterif
	; source: messaging.p8:508   match = false
	lda  #0
	sta  p8v_match
	; source: messaging.p8:509   break
	jmp  p8_label_gen_174_after
p8_label_gen_458_afterif
	; source: messaging.p8:511   j++
	inc  p8v_j
	; source: messaging.p8:500   while j < MSG_TO_MAX {
	jmp  p8_label_gen_175_whileloop
p8_label_gen_176_afterwhile
	; source: messaging.p8:509   break
p8_label_gen_174_after
	; source: messaging.p8:505   break
p8_label_gen_173_after
	; source: messaging.p8:514   if not match {
	lda  p8v_match
	bne  p8_label_gen_459_afterif
	; source: messaging.p8:515   return false
	lda  #0
	rts
p8_label_gen_459_afterif
	; source: messaging.p8:519   msg_buffer[127] = msg_buffer[127] | $02  ; Set deleted bit
	lda  p8v_msg_buffer + 127
	ora  #2
	sta  p8v_msg_buffer + 127
	; source: messaging.p8:520   return write_message(msg_num, &msg_buffer)
	lda  p8v_msg_num
	sta  p8b_messaging.p8s_write_message.p8v_record_num
	lda  #<p8v_msg_buffer
	ldy  #>p8v_msg_buffer
	sta  p8b_messaging.p8s_write_message.p8v_buffer
	sty  p8b_messaging.p8s_write_message.p8v_buffer+1
	jmp  p8b_messaging.p8s_write_message
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_j	.byte  ?
p8v_match	.byte  ?
p8v_msg_buffer	.fill  128
p8v_msg_num	.byte  ?
p8v_rec_char	.byte  ?
p8v_username	.word  ?
p8v_usr_char	.byte  ?
	.send BSS
	.pend
	; source: messaging.p8:524   sub show_menu() {

p8s_show_menu	.proc
p8v_username 	= 109 	; zp uword
p8v_to_user 	= 111 	; zp uword
p8v_subject 	= 113 	; zp uword
p8v_running 	= 115 	; zp bool
p8v_num_input2 	= 118 	; zp uword
p8v_num_input 	= 120 	; zp uword
p8v_msg_num2 	= 122 	; zp ubyte
p8v_msg_num 	= 123 	; zp ubyte
p8v_input 	= 124 	; zp uword
p8v_choice 	= 126 	; zp ubyte
p8v_body 	= 127 	; zp uword
; statements
	; source: messaging.p8:547   ubyte choice = @(input)
	; source: messaging.p8:541   uword input = session.get_input_line()
	; source: messaging.p8:594   ubyte msg_num = conv.str2ubyte(num_input)
	; source: messaging.p8:593   uword num_input = session.get_input_line()
	; source: messaging.p8:576   uword to_user = session.get_input_line()
	; source: messaging.p8:579   uword subject = session.get_input_line()
	; source: messaging.p8:582   uword body = session.get_input_line()
	; source: messaging.p8:564   ubyte msg_num2 = conv.str2ubyte(num_input2)
	; source: messaging.p8:563   uword num_input2 = session.get_input_line()
	; source: messaging.p8:525   bool running = true
	; source: messaging.p8:526   uword username = login.get_username()
	; source: messaging.p8:525   bool running = true
	lda  #1
	sta  p8v_running
	; source: messaging.p8:526   uword username = login.get_username()
	lda  p8b_login.p8v_current_username
	ldy  p8b_login.p8v_current_username+1
	sta  p8v_username
	sty  p8v_username+1
	; source: messaging.p8:544   continue
p8_label_gen_177_cont
	; source: messaging.p8:552   continue
p8_label_gen_178_cont
	; source: messaging.p8:528   while running and session.is_active() {
p8_label_gen_179_whileloop
	lda  p8v_running
	beq  p8_label_gen_460_shortcut
	jsr  p8b_session.p8s_is_active
p8_label_gen_460_shortcut
	beq  p8_label_gen_180_afterwhile
	; source: messaging.p8:529   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:530   session.send_line("=== Private Messages ===")
	ldy  #>prog8_interned_strings.string_152
	lda  #<prog8_interned_strings.string_152
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:531   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:532   session.send_line("1. Read Inbox")
	ldy  #>prog8_interned_strings.string_153
	lda  #<prog8_interned_strings.string_153
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:533   session.send_line("2. Send Message")
	ldy  #>prog8_interned_strings.string_154
	lda  #<prog8_interned_strings.string_154
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:534   session.send_line("3. Delete Message")
	ldy  #>prog8_interned_strings.string_155
	lda  #<prog8_interned_strings.string_155
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:535   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:536   session.send_line("0. Return to Main Menu")
	ldy  #>prog8_interned_strings.string_127
	lda  #<prog8_interned_strings.string_127
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:537   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:538   session.send_string("Enter choice: ")
	ldy  #>prog8_interned_strings.string_93
	lda  #<prog8_interned_strings.string_93
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:540   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_462_else
	; source: messaging.p8:541   uword input = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_input
	sty  p8v_input+1
	; source: messaging.p8:543   if strings.length(input) == 0 {
	jsr  strings.length
	tya
	beq  p8_label_gen_177_cont
	; source: messaging.p8:547   ubyte choice = @(input)
	ldy  #0
	lda  (p8v_input),y
	sta  p8v_choice
	; source: messaging.p8:548   if choice >= $30 and choice <= $39 {
	cmp  #48
	rol  a
	and  #1
	beq  p8_label_gen_463_shortcut
	lda  p8v_choice
	cmp  #58
	rol  a
	and  #1
	eor  #1
p8_label_gen_463_shortcut
	beq  p8_label_gen_465_else
	; source: messaging.p8:549   choice = choice - $30
	lda  p8v_choice
	sec
	sbc  #48
	sta  p8v_choice
	jmp  p8_label_gen_464_afterif
p8_label_gen_465_else
	; source: messaging.p8:551   session.send_line("Invalid choice.")
	ldy  #>prog8_interned_strings.string_96
	lda  #<prog8_interned_strings.string_96
	jsr  p8b_session.p8s_send_line
	; source: messaging.p8:552   continue
	jmp  p8_label_gen_178_cont
p8_label_gen_464_afterif
	; source: messaging.p8:555   if choice == 0 {
	lda  p8v_choice
	bne  p8_label_gen_467_else
	; source: messaging.p8:556   running = false
	lda  #0
	sta  p8v_running
	jmp  p8_label_gen_466_afterif
p8_label_gen_467_else
	; source: messaging.p8:558   else if choice == 1 {
	lda  p8v_choice
	cmp  #1
	bne  p8_label_gen_469_else
	; source: messaging.p8:560   list_inbox(username)
	ldy  p8v_username+1
	lda  p8v_username
	jsr  p8b_messaging.p8s_list_inbox
	; source: messaging.p8:561   session.send_string("Enter message number to read (or 0 to go back): ")
	ldy  #>prog8_interned_strings.string_156
	lda  #<prog8_interned_strings.string_156
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:562   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_470_afterif
	; source: messaging.p8:563   uword num_input2 = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_num_input2
	sty  p8v_num_input2+1
	; source: messaging.p8:564   ubyte msg_num2 = conv.str2ubyte(num_input2)
	; inlined routine follows: str2ubyte
	; source: library:/prog8lib/conv.p8:368   %asm {{
		jsr  conv.str2uword
	; inlined routine end: str2ubyte
	sta  p8v_msg_num2
	; source: messaging.p8:565   if msg_num2 != 0 {
	lda  p8v_msg_num2
	beq  p8_label_gen_471_afterif
	; source: messaging.p8:566   if not read_message_by_num(msg_num2, username) {
	lda  p8v_msg_num2
	sta  p8b_messaging.p8s_read_message_by_num.p8v_msg_num
	lda  p8v_username
	ldy  p8v_username+1
	sta  p8b_messaging.p8s_read_message_by_num.p8v_username
	sty  p8b_messaging.p8s_read_message_by_num.p8v_username+1
	jsr  p8b_messaging.p8s_read_message_by_num
	cmp  #0
	bne  p8_label_gen_472_afterif
	; source: messaging.p8:567   session.send_line("Message not found or access denied.")
	ldy  #>prog8_interned_strings.string_157
	lda  #<prog8_interned_strings.string_157
	jsr  p8b_session.p8s_send_line
p8_label_gen_472_afterif
p8_label_gen_471_afterif
p8_label_gen_470_afterif
	jmp  p8_label_gen_468_afterif
p8_label_gen_469_else
	; source: messaging.p8:572   else if choice == 2 {
	lda  p8v_choice
	cmp  #2
	bne  p8_label_gen_474_else
	; source: messaging.p8:574   session.send_string("To: ")
	ldy  #>prog8_interned_strings.string_158
	lda  #<prog8_interned_strings.string_158
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:575   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_475_afterif
	; source: messaging.p8:576   uword to_user = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_to_user
	sty  p8v_to_user+1
	; source: messaging.p8:577   session.send_string("Subject: ")
	ldy  #>prog8_interned_strings.string_119
	lda  #<prog8_interned_strings.string_119
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:578   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_476_afterif
	; source: messaging.p8:579   uword subject = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_subject
	sty  p8v_subject+1
	; source: messaging.p8:580   session.send_string("Message: ")
	ldy  #>prog8_interned_strings.string_138
	lda  #<prog8_interned_strings.string_138
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:581   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_477_afterif
	; source: messaging.p8:582   uword body = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_body
	sty  p8v_body+1
	; source: messaging.p8:583   send_message(to_user, subject, body)
	lda  p8v_to_user
	ldy  p8v_to_user+1
	sta  p8b_messaging.p8s_send_message.p8v_to_username
	sty  p8b_messaging.p8s_send_message.p8v_to_username+1
	lda  p8v_subject
	ldy  p8v_subject+1
	sta  p8b_messaging.p8s_send_message.p8v_subject
	sty  p8b_messaging.p8s_send_message.p8v_subject+1
	lda  p8v_body
	ldy  p8v_body+1
	sta  p8b_messaging.p8s_send_message.p8v_body
	sty  p8b_messaging.p8s_send_message.p8v_body+1
	jsr  p8b_messaging.p8s_send_message
p8_label_gen_477_afterif
p8_label_gen_476_afterif
p8_label_gen_475_afterif
	jmp  p8_label_gen_473_afterif
p8_label_gen_474_else
	; source: messaging.p8:588   else if choice == 3 {
	lda  p8v_choice
	cmp  #3
	bne  p8_label_gen_479_else
	; source: messaging.p8:590   list_inbox(username)
	ldy  p8v_username+1
	lda  p8v_username
	jsr  p8b_messaging.p8s_list_inbox
	; source: messaging.p8:591   session.send_string("Enter message number to delete (or 0 to cancel): ")
	ldy  #>prog8_interned_strings.string_159
	lda  #<prog8_interned_strings.string_159
	jsr  p8b_session.p8s_send_string
	; source: messaging.p8:592   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_480_afterif
	; source: messaging.p8:593   uword num_input = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_num_input
	sty  p8v_num_input+1
	; source: messaging.p8:594   ubyte msg_num = conv.str2ubyte(num_input)
	; inlined routine follows: str2ubyte
	; source: library:/prog8lib/conv.p8:368   %asm {{
		jsr  conv.str2uword
	; inlined routine end: str2ubyte
	sta  p8v_msg_num
	; source: messaging.p8:595   if msg_num != 0 {
	lda  p8v_msg_num
	beq  p8_label_gen_481_afterif
	; source: messaging.p8:596   if delete_message(msg_num, username) {
	lda  p8v_msg_num
	sta  p8b_messaging.p8s_delete_message.p8v_msg_num
	lda  p8v_username
	ldy  p8v_username+1
	sta  p8b_messaging.p8s_delete_message.p8v_username
	sty  p8b_messaging.p8s_delete_message.p8v_username+1
	jsr  p8b_messaging.p8s_delete_message
	cmp  #0
	beq  p8_label_gen_483_else
	; source: messaging.p8:597   session.send_line("Message deleted.")
	ldy  #>prog8_interned_strings.string_160
	lda  #<prog8_interned_strings.string_160
	jsr  p8b_session.p8s_send_line
	jmp  p8_label_gen_482_afterif
p8_label_gen_483_else
	; source: messaging.p8:599   session.send_line("Error deleting message.")
	ldy  #>prog8_interned_strings.string_161
	lda  #<prog8_interned_strings.string_161
	jsr  p8b_session.p8s_send_line
p8_label_gen_482_afterif
p8_label_gen_481_afterif
p8_label_gen_480_afterif
	jmp  p8_label_gen_478_afterif
p8_label_gen_479_else
	; source: messaging.p8:605   session.send_line("Invalid choice.")
	ldy  #>prog8_interned_strings.string_96
	lda  #<prog8_interned_strings.string_96
	jsr  p8b_session.p8s_send_line
p8_label_gen_478_afterif
p8_label_gen_473_afterif
p8_label_gen_468_afterif
p8_label_gen_466_afterif
	jmp  p8_label_gen_461_afterif
p8_label_gen_462_else
	; source: messaging.p8:608   running = false
	lda  #0
	sta  p8v_running
p8_label_gen_461_afterif
	; source: messaging.p8:528   while running and session.is_active() {
	jmp  p8_label_gen_179_whileloop
p8_label_gen_180_afterwhile
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

	.pend
prog8_init_vars	.block
	; source: messaging.p8:18   uword REL_FILENAME = "bbsmail"
	lda  #<prog8_interned_strings.string_197
	ldy  #>prog8_interned_strings.string_197
	sta  p8b_messaging.p8v_REL_FILENAME
	sty  p8b_messaging.p8v_REL_FILENAME+1
	; source: messaging.p8:34   ubyte @shared messaging_initialized = false
	lda  #0
	sta  p8b_messaging.p8v_messaging_initialized
	; source: messaging.p8:35   uword @shared max_messages = 1000  ; Maximum number of messages
	lda  #<$03e8
	ldy  #>$03e8
	sta  p8b_messaging.p8v_max_messages
	sty  p8b_messaging.p8v_max_messages+1
	rts
	.bend
	.pend

; ---- block: 'p8b_files' ----
p8b_files	.proc
	; source: files.p8:13   files {

; non-zeropage variables
	.section BSS
p8v_file_area	.word  ?
p8v_file_drive	.byte  ?
p8v_files_initialized	.byte  ?
	.send BSS

	; source: files.p8:15   ubyte @shared files_initialized = false
	; source: files.p8:16   ubyte @shared file_drive = 8
	; source: files.p8:17   uword @shared file_area = "files"  ; Default file area directory
	; source: files.p8:26   sub list_files(uword pattern) {

p8s_list_files	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_pattern
	sty  p8v_pattern+1
; statements
	; source: files.p8:65   uword count_str = conv.str_ub(count)
	; source: files.p8:35   ubyte count = 0
	; source: files.p8:43   uword blocks_str = conv.str_uw(diskio.list_blocks)
	; source: files.p8:27   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:28   session.send_line("=== File Listing ===")
	ldy  #>prog8_interned_strings.string_162
	lda  #<prog8_interned_strings.string_162
	jsr  p8b_session.p8s_send_line
	; source: files.p8:29   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:31   diskio.drivenumber = file_drive
	lda  p8b_files.p8v_file_drive
	sta  diskio.drivenumber
	; source: files.p8:34   if diskio.lf_start_list(pattern) {
	ldy  p8v_pattern+1
	lda  p8v_pattern
	jsr  diskio.lf_start_list
	cmp  #0
	beq  p8_label_gen_485_else
	; source: files.p8:35   ubyte count = 0
	lda  #0
	sta  p8v_count
	; source: files.p8:37   session.send_line("Files:")
	ldy  #>prog8_interned_strings.string_163
	lda  #<prog8_interned_strings.string_163
	jsr  p8b_session.p8s_send_line
	; source: files.p8:38   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:40   while diskio.lf_next_entry() {
p8_label_gen_182_whileloop
	jsr  diskio.lf_next_entry
	cmp  #0
	beq  p8_label_gen_183_afterwhile
	; source: files.p8:42   session.send_string("[")
	ldy  #>prog8_interned_strings.string_115
	lda  #<prog8_interned_strings.string_115
	jsr  p8b_session.p8s_send_string
	; source: files.p8:43   uword blocks_str = conv.str_uw(diskio.list_blocks)
	ldy  diskio.list_blocks+1
	lda  diskio.list_blocks
	jsr  conv.str_uw
	sta  p8v_blocks_str
	sty  p8v_blocks_str+1
	; source: files.p8:44   session.send_string(blocks_str)
	jsr  p8b_session.p8s_send_string
	; source: files.p8:45   session.send_string("] ")
	ldy  #>prog8_interned_strings.string_116
	lda  #<prog8_interned_strings.string_116
	jsr  p8b_session.p8s_send_string
	; source: files.p8:46   session.send_string(diskio.list_filename)
	ldy  #>diskio.list_filename
	lda  #<diskio.list_filename
	jsr  p8b_session.p8s_send_string
	; source: files.p8:47   session.send_string(" (")
	ldy  #>prog8_interned_strings.string_145
	lda  #<prog8_interned_strings.string_145
	jsr  p8b_session.p8s_send_string
	; source: files.p8:48   session.send_string(diskio.list_filetype)
	ldy  #>diskio.list_filetype
	lda  #<diskio.list_filetype
	jsr  p8b_session.p8s_send_string
	; source: files.p8:49   session.send_string(")")
	ldy  #>prog8_interned_strings.string_164
	lda  #<prog8_interned_strings.string_164
	jsr  p8b_session.p8s_send_string
	; source: files.p8:50   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:52   count++
	inc  p8v_count
	; source: files.p8:55   if count >= 50 {
	lda  p8v_count
	cmp  #50
	bcc  p8_label_gen_486_afterif
	; source: files.p8:56   session.send_line("... (more files available)")
	ldy  #>prog8_interned_strings.string_165
	lda  #<prog8_interned_strings.string_165
	jsr  p8b_session.p8s_send_line
	; source: files.p8:57   break
	jmp  p8_label_gen_181_after
p8_label_gen_486_afterif
	; source: files.p8:40   while diskio.lf_next_entry() {
	jmp  p8_label_gen_182_whileloop
p8_label_gen_183_afterwhile
	; source: files.p8:57   break
p8_label_gen_181_after
	; source: files.p8:61   diskio.lf_end_list()
	jsr  diskio.lf_end_list
	; source: files.p8:63   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:64   session.send_string("Total: ")
	ldy  #>prog8_interned_strings.string_166
	lda  #<prog8_interned_strings.string_166
	jsr  p8b_session.p8s_send_string
	; source: files.p8:65   uword count_str = conv.str_ub(count)
	lda  p8v_count
	jsr  conv.str_ub
	sta  p8v_count_str
	sty  p8v_count_str+1
	; source: files.p8:66   session.send_string(count_str)
	jsr  p8b_session.p8s_send_string
	; source: files.p8:67   session.send_line(" files")
	ldy  #>prog8_interned_strings.string_167
	lda  #<prog8_interned_strings.string_167
	jsr  p8b_session.p8s_send_line
	jmp  p8_label_gen_484_afterif
p8_label_gen_485_else
	; source: files.p8:69   session.send_line("Error listing files.")
	ldy  #>prog8_interned_strings.string_168
	lda  #<prog8_interned_strings.string_168
	jsr  p8b_session.p8s_send_line
p8_label_gen_484_afterif
	; source: files.p8:72   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jmp  p8b_session.p8s_send_line
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_blocks_str	.word  ?
p8v_count	.byte  ?
p8v_count_str	.word  ?
p8v_pattern	.word  ?
	.send BSS
	.pend
	; source: files.p8:76   sub download_file(uword filename) -> bool {

p8s_download_file	.proc
; simple int arg(s) passed via cpu register(s)
	sta  p8v_filename
	sty  p8v_filename+1
; statements
	; source: files.p8:112   ubyte i = 0
	; source: files.p8:105   uword bytes_read = diskio.f_read(&buffer, 256)
	; source: files.p8:100   ubyte[256] buffer
	; source: files.p8:101   uword total_bytes = 0
	; source: files.p8:102   bool error = false
	; source: files.p8:137   uword size_str = conv.str_uw(total_bytes)
	; source: files.p8:77   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:78   session.send_string("Downloading: ")
	ldy  #>prog8_interned_strings.string_169
	lda  #<prog8_interned_strings.string_169
	jsr  p8b_session.p8s_send_string
	; source: files.p8:79   session.send_string(filename)
	ldy  p8v_filename+1
	lda  p8v_filename
	jsr  p8b_session.p8s_send_string
	; source: files.p8:80   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:82   diskio.drivenumber = file_drive
	lda  p8b_files.p8v_file_drive
	sta  diskio.drivenumber
	; source: files.p8:85   if not diskio.exists(filename) {
	ldy  p8v_filename+1
	lda  p8v_filename
	jsr  diskio.exists
	cmp  #0
	bne  p8_label_gen_487_afterif
	; source: files.p8:86   session.send_line("File not found.")
	ldy  #>prog8_interned_strings.string_170
	lda  #<prog8_interned_strings.string_170
	jsr  p8b_session.p8s_send_line
	; source: files.p8:87   return false
	lda  #0
	rts
p8_label_gen_487_afterif
	; source: files.p8:91   if not diskio.f_open(filename) {
	ldy  p8v_filename+1
	lda  p8v_filename
	jsr  diskio.f_open
	cmp  #0
	bne  p8_label_gen_488_afterif
	; source: files.p8:92   session.send_line("Error opening file.")
	ldy  #>prog8_interned_strings.string_171
	lda  #<prog8_interned_strings.string_171
	jsr  p8b_session.p8s_send_line
	; source: files.p8:93   return false
	lda  #0
	rts
p8_label_gen_488_afterif
	; source: files.p8:96   session.send_line("File transfer starting...")
	ldy  #>prog8_interned_strings.string_172
	lda  #<prog8_interned_strings.string_172
	jsr  p8b_session.p8s_send_line
	; source: files.p8:97   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:101   uword total_bytes = 0
	lda  #0
	sta  p8v_total_bytes
	sta  p8v_total_bytes+1
	; source: files.p8:102   bool error = false
	lda  #0
	sta  p8v_error
	; source: files.p8:104   while true {
p8_label_gen_198_repeat
	; source: files.p8:105   uword bytes_read = diskio.f_read(&buffer, 256)
	lda  #<p8v_buffer
	ldy  #>p8v_buffer
	sta  diskio.f_read.bufferpointer
	sty  diskio.f_read.bufferpointer+1
	lda  #<$0100
	ldy  #>$0100
	sta  diskio.f_read.num_bytes
	sty  diskio.f_read.num_bytes+1
	jsr  diskio.f_read
	sta  p8v_bytes_read
	sty  p8v_bytes_read+1
	; source: files.p8:107   if bytes_read == 0 {
	ora  p8v_bytes_read+1
	beq  p8_label_gen_184_after
	; source: files.p8:112   ubyte i = 0
	lda  #0
	sta  p8v_i
	; source: files.p8:113   while i < bytes_read {
p8_label_gen_186_whileloop
	ldy  #0
	lda  p8v_i
	cmp  p8v_bytes_read
	tya
	sbc  p8v_bytes_read+1
	bcs  p8_label_gen_187_afterwhile
	; source: files.p8:114   if not com.write_char(buffer[i]) {
	ldy  p8v_i
	lda  p8v_buffer,y
	jsr  p8b_com.p8s_write_char
	cmp  #0
	bne  p8_label_gen_489_afterif
	; source: files.p8:115   error = true
	lda  #1
	sta  p8v_error
	; source: files.p8:116   break
	jmp  p8_label_gen_185_after
p8_label_gen_489_afterif
	; source: files.p8:118   total_bytes++
	inc  p8v_total_bytes
	bne  +
	inc  p8v_total_bytes+1
+
	; source: files.p8:119   i++
	inc  p8v_i
	; source: files.p8:113   while i < bytes_read {
	jmp  p8_label_gen_186_whileloop
p8_label_gen_187_afterwhile
	; source: files.p8:116   break
p8_label_gen_185_after
	; source: files.p8:122   if error {
	lda  p8v_error
	; source: files.p8:104   while true {
	beq  p8_label_gen_198_repeat
	; source: files.p8:123   break
p8_label_gen_188_after
	; source: files.p8:108   break  ; EOF
p8_label_gen_184_after
	; source: files.p8:127   diskio.f_close()
	jsr  diskio.f_close
	; source: files.p8:129   if error {
	lda  p8v_error
	beq  p8_label_gen_490_afterif
	; source: files.p8:130   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:131   session.send_line("Transfer error occurred.")
	ldy  #>prog8_interned_strings.string_173
	lda  #<prog8_interned_strings.string_173
	jsr  p8b_session.p8s_send_line
	; source: files.p8:132   return false
	lda  #0
	rts
p8_label_gen_490_afterif
	; source: files.p8:135   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:136   session.send_string("Transfer complete: ")
	ldy  #>prog8_interned_strings.string_174
	lda  #<prog8_interned_strings.string_174
	jsr  p8b_session.p8s_send_string
	; source: files.p8:137   uword size_str = conv.str_uw(total_bytes)
	ldy  p8v_total_bytes+1
	lda  p8v_total_bytes
	jsr  conv.str_uw
	sta  p8v_size_str
	sty  p8v_size_str+1
	; source: files.p8:138   session.send_string(size_str)
	jsr  p8b_session.p8s_send_string
	; source: files.p8:139   session.send_string(" bytes")
	ldy  #>prog8_interned_strings.string_22
	lda  #<prog8_interned_strings.string_22
	jsr  p8b_session.p8s_send_string
	; source: files.p8:140   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:142   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_buffer	.fill  256
p8v_bytes_read	.word  ?
p8v_error	.byte  ?
p8v_filename	.word  ?
p8v_i	.byte  ?
p8v_size_str	.word  ?
p8v_total_bytes	.word  ?
	.send BSS
	.pend
	; source: files.p8:146   sub upload_file(uword filename, uword max_size) -> bool {

p8s_upload_file	.proc
; statements
	; source: files.p8:187   ubyte ch = com.read_char()
	; source: files.p8:152   uword max_str = conv.str_uw(max_size)
	; source: files.p8:160   ubyte user_level = login.get_user_level()
	; source: files.p8:178   uword bytes_received = 0
	; source: files.p8:179   ubyte[256] buffer
	; source: files.p8:180   ubyte buffer_pos = 0
	; source: files.p8:181   bool receiving = true
	; source: files.p8:182   bool cancelled = false
	; source: files.p8:243   uword size_str = conv.str_uw(bytes_received)
	; source: files.p8:147   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:148   session.send_string("Upload: ")
	ldy  #>prog8_interned_strings.string_175
	lda  #<prog8_interned_strings.string_175
	jsr  p8b_session.p8s_send_string
	; source: files.p8:149   session.send_string(filename)
	ldy  p8v_filename+1
	lda  p8v_filename
	jsr  p8b_session.p8s_send_string
	; source: files.p8:150   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:151   session.send_string("Maximum size: ")
	ldy  #>prog8_interned_strings.string_176
	lda  #<prog8_interned_strings.string_176
	jsr  p8b_session.p8s_send_string
	; source: files.p8:152   uword max_str = conv.str_uw(max_size)
	ldy  p8v_max_size+1
	lda  p8v_max_size
	jsr  conv.str_uw
	sta  p8v_max_str
	sty  p8v_max_str+1
	; source: files.p8:153   session.send_string(max_str)
	jsr  p8b_session.p8s_send_string
	; source: files.p8:154   session.send_string(" bytes")
	ldy  #>prog8_interned_strings.string_22
	lda  #<prog8_interned_strings.string_22
	jsr  p8b_session.p8s_send_string
	; source: files.p8:155   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:156   session.send_line("Send file now (or type 'cancel' to abort):")
	ldy  #>prog8_interned_strings.string_177
	lda  #<prog8_interned_strings.string_177
	jsr  p8b_session.p8s_send_line
	; source: files.p8:157   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:160   ubyte user_level = login.get_user_level()
	lda  p8b_login.p8v_current_user_level
	sta  p8v_user_level
	; source: files.p8:161   if user_level < 2 {  ; Only level 2+ can upload
	cmp  #2
	bcs  p8_label_gen_491_afterif
	; source: files.p8:162   session.send_line("Upload permission denied.")
	ldy  #>prog8_interned_strings.string_178
	lda  #<prog8_interned_strings.string_178
	jsr  p8b_session.p8s_send_line
	; source: files.p8:163   return false
	lda  #0
	rts
p8_label_gen_491_afterif
	; source: files.p8:166   diskio.drivenumber = file_drive
	lda  p8b_files.p8v_file_drive
	sta  diskio.drivenumber
	; source: files.p8:169   if not diskio.f_open_w(filename) {
	ldy  p8v_filename+1
	lda  p8v_filename
	jsr  diskio.f_open_w
	cmp  #0
	bne  p8_label_gen_492_afterif
	; source: files.p8:170   session.send_line("Error creating file.")
	ldy  #>prog8_interned_strings.string_179
	lda  #<prog8_interned_strings.string_179
	jsr  p8b_session.p8s_send_line
	; source: files.p8:171   return false
	lda  #0
	rts
p8_label_gen_492_afterif
	; source: files.p8:174   session.send_line("Ready to receive file...")
	ldy  #>prog8_interned_strings.string_180
	lda  #<prog8_interned_strings.string_180
	jsr  p8b_session.p8s_send_line
	; source: files.p8:175   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:178   uword bytes_received = 0
	lda  #0
	sta  p8v_bytes_received
	sta  p8v_bytes_received+1
	; source: files.p8:180   ubyte buffer_pos = 0
	lda  #0
	sta  p8v_buffer_pos
	; source: files.p8:181   bool receiving = true
	lda  #1
	sta  p8v_receiving
	; source: files.p8:182   bool cancelled = false
	lda  #0
	sta  p8v_cancelled
	; source: files.p8:192   continue
p8_label_gen_189_cont
	; source: files.p8:184   while receiving and bytes_received < max_size {
p8_label_gen_192_whileloop
	lda  p8v_receiving
	beq  p8_label_gen_493_shortcut
	ldy  p8v_bytes_received+1
	lda  p8v_bytes_received
	cmp  p8v_max_size
	tya
	sbc  p8v_max_size+1
	bcs  p8_label_gen_495_else
	lda  #1
	jmp  p8_label_gen_494_afterif
p8_label_gen_495_else
	lda  #0
p8_label_gen_494_afterif
p8_label_gen_493_shortcut
	beq  p8_label_gen_193_afterwhile
	; source: files.p8:186   if com.data_available() {
	jsr  p8b_com.p8s_data_available
	cmp  #0
	beq  p8_label_gen_497_else
	; source: files.p8:187   ubyte ch = com.read_char()
	jsr  p8b_com.p8s_read_char
	sta  p8v_ch
	; source: files.p8:189   if ch == 0 {
	lda  p8v_ch
	bne  p8_label_gen_498_afterif
	; source: files.p8:191   sys.wait(1)
	ldy  #>1
	lda  #<1
	jsr  sys.wait
	; source: files.p8:192   continue
	jmp  p8_label_gen_189_cont
p8_label_gen_498_afterif
	; source: files.p8:196   if ch == $03 {  ; Ctrl-C
	lda  p8v_ch
	cmp  #3
	bne  p8_label_gen_499_afterif
	; source: files.p8:197   cancelled = true
	lda  #1
	sta  p8v_cancelled
	; source: files.p8:198   break
	jmp  p8_label_gen_190_after
p8_label_gen_499_afterif
	; source: files.p8:202   buffer[buffer_pos] = ch
	ldy  p8v_buffer_pos
	lda  p8v_ch
	sta  p8v_buffer,y
	; source: files.p8:203   buffer_pos++
	inc  p8v_buffer_pos
	; source: files.p8:204   bytes_received++
	inc  p8v_bytes_received
	bne  +
	inc  p8v_bytes_received+1
+
	; source: files.p8:216   if (bytes_received & $03FF) == 0 {
	ldy  p8v_bytes_received+1
	lda  p8v_bytes_received
	and  #<1023
	tax
	tya
	and  #>1023
	tay
	txa
	sty  P8ZP_SCRATCH_REG
	ora  P8ZP_SCRATCH_REG
	bne  p8_label_gen_500_afterif
	; source: files.p8:217   session.send_string(".")
	ldy  #>prog8_interned_strings.string_181
	lda  #<prog8_interned_strings.string_181
	jsr  p8b_session.p8s_send_string
p8_label_gen_500_afterif
	jmp  p8_label_gen_496_afterif
p8_label_gen_497_else
	; source: files.p8:221   sys.wait(1)
	ldy  #>1
	lda  #<1
	jsr  sys.wait
p8_label_gen_496_afterif
	; source: files.p8:184   while receiving and bytes_received < max_size {
	jmp  p8_label_gen_192_whileloop
p8_label_gen_193_afterwhile
	; source: files.p8:210   break
p8_label_gen_191_after
	; source: files.p8:198   break
p8_label_gen_190_after
	; source: files.p8:229   if buffer_pos > 0 and not cancelled {
	lda  p8v_buffer_pos
	beq  +
	lda  #1
+
	pha
	lda  p8v_cancelled
	eor  #1
	sta  P8ZP_SCRATCH_B1
	pla
	and  P8ZP_SCRATCH_B1
	beq  p8_label_gen_501_afterif
	; source: files.p8:230   diskio.f_write(&buffer, buffer_pos)
	lda  #<p8v_buffer
	ldy  #>p8v_buffer
	sta  diskio.f_write.bufferpointer
	sty  diskio.f_write.bufferpointer+1
	lda  p8v_buffer_pos
	sta  diskio.f_write.num_bytes
	lda  #0
	sta  diskio.f_write.num_bytes+1
	jsr  diskio.f_write
p8_label_gen_501_afterif
	; source: files.p8:233   diskio.f_close_w()
	jsr  diskio.f_close_w
	; source: files.p8:235   if cancelled {
	lda  p8v_cancelled
	beq  p8_label_gen_502_afterif
	; source: files.p8:236   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:237   session.send_line("Upload cancelled.")
	ldy  #>prog8_interned_strings.string_182
	lda  #<prog8_interned_strings.string_182
	jsr  p8b_session.p8s_send_line
	; source: files.p8:238   return false
	lda  #0
	rts
p8_label_gen_502_afterif
	; source: files.p8:241   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:242   session.send_string("Upload complete: ")
	ldy  #>prog8_interned_strings.string_183
	lda  #<prog8_interned_strings.string_183
	jsr  p8b_session.p8s_send_string
	; source: files.p8:243   uword size_str = conv.str_uw(bytes_received)
	ldy  p8v_bytes_received+1
	lda  p8v_bytes_received
	jsr  conv.str_uw
	sta  p8v_size_str
	sty  p8v_size_str+1
	; source: files.p8:244   session.send_string(size_str)
	jsr  p8b_session.p8s_send_string
	; source: files.p8:245   session.send_string(" bytes")
	ldy  #>prog8_interned_strings.string_22
	lda  #<prog8_interned_strings.string_22
	jsr  p8b_session.p8s_send_string
	; source: files.p8:246   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:248   return true
	lda  #1
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_buffer	.fill  256
p8v_buffer_pos	.byte  ?
p8v_bytes_received	.word  ?
p8v_cancelled	.byte  ?
p8v_ch	.byte  ?
p8v_filename	.word  ?
p8v_max_size	.word  ?
p8v_max_str	.word  ?
p8v_receiving	.byte  ?
p8v_size_str	.word  ?
p8v_user_level	.byte  ?
	.send BSS
	.pend
	; source: files.p8:252   sub show_menu() {

p8s_show_menu	.proc
	p8c_max_size = $ffff
; statements
	; source: files.p8:274   ubyte choice = @(input)
	; source: files.p8:268   uword input = session.get_input_line()
	; source: files.p8:308   ubyte user_level = login.get_user_level()
	; source: files.p8:314   uword filename2 = session.get_input_line()
	; source: files.p8:316   uword max_size = 65535  ; 64KB max
	; source: files.p8:300   uword filename = session.get_input_line()
	; source: files.p8:289   uword pattern = session.get_input_line()
	; source: files.p8:253   bool running = true
	lda  #1
	sta  p8v_running
	; source: files.p8:271   continue
p8_label_gen_194_cont
	; source: files.p8:279   continue
p8_label_gen_195_cont
	; source: files.p8:255   while running and session.is_active() {
p8_label_gen_196_whileloop
	lda  p8v_running
	beq  p8_label_gen_503_shortcut
	jsr  p8b_session.p8s_is_active
p8_label_gen_503_shortcut
	beq  p8_label_gen_197_afterwhile
	; source: files.p8:256   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:257   session.send_line("=== File Areas ===")
	ldy  #>prog8_interned_strings.string_184
	lda  #<prog8_interned_strings.string_184
	jsr  p8b_session.p8s_send_line
	; source: files.p8:258   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:259   session.send_line("1. List Files")
	ldy  #>prog8_interned_strings.string_185
	lda  #<prog8_interned_strings.string_185
	jsr  p8b_session.p8s_send_line
	; source: files.p8:260   session.send_line("2. Download File")
	ldy  #>prog8_interned_strings.string_186
	lda  #<prog8_interned_strings.string_186
	jsr  p8b_session.p8s_send_line
	; source: files.p8:261   session.send_line("3. Upload File")
	ldy  #>prog8_interned_strings.string_187
	lda  #<prog8_interned_strings.string_187
	jsr  p8b_session.p8s_send_line
	; source: files.p8:262   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:263   session.send_line("0. Return to Main Menu")
	ldy  #>prog8_interned_strings.string_127
	lda  #<prog8_interned_strings.string_127
	jsr  p8b_session.p8s_send_line
	; source: files.p8:264   session.send_line("")
	ldy  #>prog8_interned_strings.string_23
	lda  #<prog8_interned_strings.string_23
	jsr  p8b_session.p8s_send_line
	; source: files.p8:265   session.send_string("Enter choice: ")
	ldy  #>prog8_interned_strings.string_93
	lda  #<prog8_interned_strings.string_93
	jsr  p8b_session.p8s_send_string
	; source: files.p8:267   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_505_else
	; source: files.p8:268   uword input = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_input
	sty  p8v_input+1
	; source: files.p8:270   if strings.length(input) == 0 {
	jsr  strings.length
	tya
	beq  p8_label_gen_194_cont
	; source: files.p8:274   ubyte choice = @(input)
	lda  p8v_input
	ldy  p8v_input+1
	sta  P8ZP_SCRATCH_PTR
	sty  P8ZP_SCRATCH_PTR+1
	ldy  #0
	lda  (P8ZP_SCRATCH_PTR),y
	sta  p8v_choice
	; source: files.p8:275   if choice >= $30 and choice <= $39 {
	cmp  #48
	rol  a
	and  #1
	beq  p8_label_gen_506_shortcut
	lda  p8v_choice
	cmp  #58
	rol  a
	and  #1
	eor  #1
p8_label_gen_506_shortcut
	beq  p8_label_gen_508_else
	; source: files.p8:276   choice = choice - $30
	lda  p8v_choice
	sec
	sbc  #48
	sta  p8v_choice
	jmp  p8_label_gen_507_afterif
p8_label_gen_508_else
	; source: files.p8:278   session.send_line("Invalid choice.")
	ldy  #>prog8_interned_strings.string_96
	lda  #<prog8_interned_strings.string_96
	jsr  p8b_session.p8s_send_line
	; source: files.p8:279   continue
	jmp  p8_label_gen_195_cont
p8_label_gen_507_afterif
	; source: files.p8:282   if choice == 0 {
	lda  p8v_choice
	bne  p8_label_gen_510_else
	; source: files.p8:283   running = false
	lda  #0
	sta  p8v_running
	jmp  p8_label_gen_509_afterif
p8_label_gen_510_else
	; source: files.p8:285   else if choice == 1 {
	lda  p8v_choice
	cmp  #1
	bne  p8_label_gen_512_else
	; source: files.p8:287   session.send_string("Enter file pattern (or * for all): ")
	ldy  #>prog8_interned_strings.string_188
	lda  #<prog8_interned_strings.string_188
	jsr  p8b_session.p8s_send_string
	; source: files.p8:288   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_513_afterif
	; source: files.p8:289   uword pattern = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_pattern
	sty  p8v_pattern+1
	; source: files.p8:290   if strings.length(pattern) == 0 {
	jsr  strings.length
	tya
	bne  p8_label_gen_514_afterif
	; source: files.p8:291   pattern = "*"
	lda  #<prog8_interned_strings.string_189
	ldy  #>prog8_interned_strings.string_189
	sta  p8v_pattern
	sty  p8v_pattern+1
p8_label_gen_514_afterif
	; source: files.p8:293   list_files(pattern)
	ldy  p8v_pattern+1
	lda  p8v_pattern
	jsr  p8b_files.p8s_list_files
p8_label_gen_513_afterif
	jmp  p8_label_gen_511_afterif
p8_label_gen_512_else
	; source: files.p8:296   else if choice == 2 {
	lda  p8v_choice
	cmp  #2
	bne  p8_label_gen_516_else
	; source: files.p8:298   session.send_string("Enter filename: ")
	ldy  #>prog8_interned_strings.string_190
	lda  #<prog8_interned_strings.string_190
	jsr  p8b_session.p8s_send_string
	; source: files.p8:299   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_517_afterif
	; source: files.p8:300   uword filename = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_filename
	sty  p8v_filename+1
	; source: files.p8:301   if strings.length(filename) > 0 {
	jsr  strings.length
	tya
	beq  p8_label_gen_518_afterif
	; source: files.p8:302   download_file(filename)
	ldy  p8v_filename+1
	lda  p8v_filename
	jsr  p8b_files.p8s_download_file
p8_label_gen_518_afterif
p8_label_gen_517_afterif
	jmp  p8_label_gen_515_afterif
p8_label_gen_516_else
	; source: files.p8:306   else if choice == 3 {
	lda  p8v_choice
	cmp  #3
	bne  p8_label_gen_520_else
	; source: files.p8:308   ubyte user_level = login.get_user_level()
	lda  p8b_login.p8v_current_user_level
	sta  p8v_user_level
	; source: files.p8:309   if user_level < 2 {
	cmp  #2
	bcs  p8_label_gen_522_else
	; source: files.p8:310   session.send_line("Upload permission denied. Level 2+ required.")
	ldy  #>prog8_interned_strings.string_191
	lda  #<prog8_interned_strings.string_191
	jsr  p8b_session.p8s_send_line
	jmp  p8_label_gen_521_afterif
p8_label_gen_522_else
	; source: files.p8:312   session.send_string("Enter filename: ")
	ldy  #>prog8_interned_strings.string_190
	lda  #<prog8_interned_strings.string_190
	jsr  p8b_session.p8s_send_string
	; source: files.p8:313   if session.read_line() {
	jsr  p8b_session.p8s_read_line
	cmp  #0
	beq  p8_label_gen_523_afterif
	; source: files.p8:314   uword filename2 = session.get_input_line()
	jsr  p8b_session.p8s_get_input_line
	sta  p8v_filename2
	sty  p8v_filename2+1
	; source: files.p8:315   if strings.length(filename2) > 0 {
	jsr  strings.length
	tya
	beq  p8_label_gen_524_afterif
	; source: files.p8:317   upload_file(filename2, max_size)
	lda  p8v_filename2
	ldy  p8v_filename2+1
	sta  p8b_files.p8s_upload_file.p8v_filename
	sty  p8b_files.p8s_upload_file.p8v_filename+1
	lda  #$ff
	sta  p8b_files.p8s_upload_file.p8v_max_size
	sta  p8b_files.p8s_upload_file.p8v_max_size+1
	jsr  p8b_files.p8s_upload_file
p8_label_gen_524_afterif
p8_label_gen_523_afterif
p8_label_gen_521_afterif
	jmp  p8_label_gen_519_afterif
p8_label_gen_520_else
	; source: files.p8:323   session.send_line("Invalid choice.")
	ldy  #>prog8_interned_strings.string_96
	lda  #<prog8_interned_strings.string_96
	jsr  p8b_session.p8s_send_line
p8_label_gen_519_afterif
p8_label_gen_515_afterif
p8_label_gen_511_afterif
p8_label_gen_509_afterif
	jmp  p8_label_gen_504_afterif
p8_label_gen_505_else
	; source: files.p8:326   running = false
	lda  #0
	sta  p8v_running
p8_label_gen_504_afterif
	; source: files.p8:255   while running and session.is_active() {
	jmp  p8_label_gen_196_whileloop
p8_label_gen_197_afterwhile
	rts
; variables
	.section BSS_NOCLEAR
	.send BSS_NOCLEAR

; non-zeropage variables
	.section BSS
p8v_choice	.byte  ?
p8v_filename	.word  ?
p8v_filename2	.word  ?
p8v_input	.word  ?
p8v_pattern	.word  ?
p8v_running	.byte  ?
p8v_user_level	.byte  ?
	.send BSS
	.pend
prog8_init_vars	.block
	; source: files.p8:16   ubyte @shared file_drive = 8
	lda  #8
	sta  p8b_files.p8v_file_drive
	; source: files.p8:17   uword @shared file_area = "files"  ; Default file area directory
	lda  #<prog8_interned_strings.string_198
	ldy  #>prog8_interned_strings.string_198
	sta  p8b_files.p8v_file_area
	sty  p8b_files.p8v_file_area+1
	rts
	.bend
	.pend

; ---- block: 'prog8_math' ----
prog8_math	.proc
	; source: library:/prog8lib/prog8_math.p8:1   prog8_math {


	; source: library:/prog8lib/prog8_math.p8:2   %option no_symbol_prefixing
	; source: library:/prog8lib/prog8_math.p8:4   %asminclude "library:math.asm"
; Internal Math library routines - always included by the compiler
; Generic machine independent 6502 code.
;
;  some more interesting routines can be found here:
;	http://6502org.wikidot.com/software-math
;	https://codebase64.net/doku.php?id=base:6502_6510_maths
;       https://github.com/TobyLobster/multiply_test
;       https://github.com/TobyLobster/sqrt_test


multiply_bytes	.proc
	; -- multiply 2 bytes A and Y, result as byte in A  (signed or unsigned)
	; https://github.com/TobyLobster/multiply_test/blob/main/tests/mult29.a

_multiplicand    = P8ZP_SCRATCH_B1
_multiplier      = P8ZP_SCRATCH_REG

    sty  _multiplicand
    lsr  a
    sta  _multiplier
    lda  #0
    ldx  #2
-
    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier
    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier

    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier
    bcc  +
    clc
    adc  _multiplicand
+
    ror  a
    ror  _multiplier
    dex
    bne  -
    ; tay       ; if you want 16 bits result in AY, enable this again
    lda  _multiplier
    rts
		.pend


multiply_words	.proc
	; -- multiply two 16-bit words into a 32-bit result  (UNSIGNED)
	;      input: A/Y = first 16-bit number, multiply_words.multiplier = second 16-bit number
	;      output: multiply_words.result, 4-bytes/32-bits product, LSB order (low-to-high)  low 16 bits also in AY.
	;      you can retrieve the upper 16 bits via math.mul16_last_upper()

	; NOTE FOR NEGATIVE VALUES:
	;      The routine also works for NEGATIVE (signed) word values, but ONLY the lower 16 bits of the result are correct then!
	;      Prog8 only uses those so that's not an issue, but math.mul16_last_upper() no longer gives the correct result here.

; mult62.a
; from: https://github.com/TobyLobster/multiply_test/blob/main/tests/mult62.a
; based on Dr Jefyll, http://forum.6502.org/viewtopic.php?f=9&t=689&start=0#p19958
; - adjusted to use fixed zero page addresses
; - removed 'decrement to avoid clc' as this is slower on average
; - rearranged memory use to remove final memory copy and give LSB first order to result
; - removed temp zp storage bytes
; - unrolled the outer loop
; - unrolled the two inner loops once
;
; 16 bit x 16 bit unsigned multiply, 32 bit result
; Average cycles: ~442 ?
; 93 bytes

_multiplicand    = P8ZP_SCRATCH_W2   ; 2 bytes
multiplier      = result

; 16 bit x 16 bit unsigned multiply, 32 bit result
;
; On Entry:
;   (multiplier, multiplier+1): two byte multiplier, four bytes needed for result
;   (multiplicand, multiplicand+1): two byte multiplicand
; On Exit:
;   (result, result+1, result+2, result+3): product

    sta  _multiplicand
    sty  _multiplicand+1

    lda  #0              ;
    sta  result+2        ; 16 bits of zero in A, result+2
                        ;  Note:    First 8 shifts are  A -> result+2 -> result
                        ;           Final 8 shifts are  A -> result+2 -> result+1

    ; --- 1st byte ---
    ldy  #4              ; count for inner loop
    lsr  result

    ; inner loop (8 times)
_inner_loop
    ; first time
    bcc +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                ; shift
    ror  result+2
    ror  result

    ; second time
    bcc +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                 ; shift
    ror  result+2
    ror  result

    dey
    bne  _inner_loop      ; go back for 1 more shift?

    ; --- 2nd byte ---
    ldy  #4              ; count for inner loop
    lsr  result+1

    ; inner loop (8 times)
_inner_loop2
    ; first time
    bcc  +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                ; shift
    ror  result+2
    ror  result+1

    ; second time
    bcc  +
    tax                 ; retain A
    lda  result+2
    clc
    adc  _multiplicand
    sta  result+2
    txa                 ; recall A
    adc  _multiplicand+1

+
    ror  a                ; shift
    ror  result+2
    ror  result+1
    dey
    bne  _inner_loop2     ; go back for 1 more shift?

    sta  result+3        ; ms byte of hi-word of result

    lda  result
    ldy  result+1
    rts

		.section BSS
result		.byte  ?,?,?,?       ; routine could be faster if this were in Zeropage...
		.send BSS
		.pend


divmod_b_asm	.proc
	; signed byte division: make everything positive and fix sign afterwards
		sta  P8ZP_SCRATCH_B1
		tya
		eor  P8ZP_SCRATCH_B1
		php			; save sign
		lda  P8ZP_SCRATCH_B1
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
+		pha
		tya
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
		tay
+		pla
		jsr  divmod_ub_asm
		sta  _remainder
		plp
		bpl  +
		tya
		eor  #$ff
		sec
		adc  #0			; negate result
		tay
+		rts
		.section BSS
_remainder	.byte  ?
		.send BSS
		.pend


divmod_ub_asm	.proc
	; -- divide A by Y, result quotient in Y, remainder in A   (unsigned)
	;    division by zero will result in quotient = 255 and remainder = original number
		sty  P8ZP_SCRATCH_REG
		sta  P8ZP_SCRATCH_B1

		lda  #0
		ldx  #8
		asl  P8ZP_SCRATCH_B1
-		rol  a
		cmp  P8ZP_SCRATCH_REG
		bcc  +
		sbc  P8ZP_SCRATCH_REG
+		rol  P8ZP_SCRATCH_B1
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
		rts
		.pend

remainder_ub_asm        .proc
		; -- divide A by Y, returns remainder in A   (unsigned)
		;    division by zero will result in just the original number.
		;    This routine specialcases 0,1,2 and otherwise is just a repeated subtraction.
		cpy  #0
		beq  _zero
		cpy  #1
		bne  +
		lda  #0
		rts
+		cpy  #2
		bne  +
		and  #1
		rts
+		sty  P8ZP_SCRATCH_REG
		sec
-		sbc  P8ZP_SCRATCH_REG
		bcs  -
		adc  P8ZP_SCRATCH_REG
_zero		rts
		.pend

divmod_w_asm	.proc
	; signed word division: make everything positive and fix sign afterwards
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  P8ZP_SCRATCH_W1+1
		eor  P8ZP_SCRATCH_W2+1
		php			; save sign
		lda  P8ZP_SCRATCH_W1+1
		bpl  +
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W1
		lda  #0
		sbc  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W1+1
+		lda  P8ZP_SCRATCH_W2+1
		bpl  +
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W2
		lda  #0
		sbc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W2+1
+		tay
		lda  P8ZP_SCRATCH_W2
		jsr  divmod_uw_asm
		plp			; restore sign
		bpl  +
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W2
		pha
		lda  #0
		sbc  P8ZP_SCRATCH_W2+1
		tay
		pla
+		rts
		.pend

divmod_uw_asm	.proc
	; -- divide two unsigned words (16 bit each) into 16 bit results
	;    input:  P8ZP_SCRATCH_W1 in ZP: 16 bit number, A/Y: 16 bit divisor
	;    output: P8ZP_SCRATCH_W2 in ZP: 16 bit remainder, A/Y: 16 bit division result
	;    division by zero will result in quotient = 65535 and remainder = divident

dividend = P8ZP_SCRATCH_W1
remainder = P8ZP_SCRATCH_W2
result = dividend ;save memory by reusing divident to store the result

		sta  _divisor
		sty  _divisor+1
		lda  #0	        	;preset remainder to 0
		sta  remainder
		sta  remainder+1
		ldx  #16	        ;repeat for each bit: ...

-		asl  dividend		;dividend lb & hb*2, msb -> Carry
		rol  dividend+1
		rol  remainder		;remainder lb & hb * 2 + msb from carry
		rol  remainder+1
		lda  remainder
		sec
		sbc  _divisor		;substract divisor to see if it fits in
		tay	       		;lb result -> Y, for we may need it later
		lda  remainder+1
		sbc  _divisor+1
		bcc  +			;if carry=0 then divisor didn't fit in yet

		sta  remainder+1	;else save substraction result as new remainder,
		sty  remainder
		inc  result		;and INCrement result cause divisor fit in 1 times

+		dex
		bne  -

		lda  result
		ldy  result+1
		rts
		.section BSS
_divisor	.word ?
		.send BSS
		.pend

randword	.proc
	; -- 16 bit pseudo random number generator into AY
	;    default seed = $00c2 $1137.  NOTE:  uses self-modifying code so won't work in ROM (use randword_rom instead)
        ;    routine from https://codebase64.net/doku.php?id=6502_6510_maths:x_abc_random_number_generator_8_16_bit
		inc x1
		clc
x1=*+1
		lda #$00	;x1
c1=*+1
		eor #$c2	;c1
a1=*+1
		eor #$11	;a1
		sta a1
b1=*+1
		adc #$37	;b1
		sta b1
		lsr a
		eor a1
		adc c1
		sta c1
		ldy b1
		rts
		.pend

randword_rom	.proc
	; -- 16 bit pseudo random number generator into AY. Can run from ROM.
	;    NOTE: you have to set the initial seed using randseed_rom! (a good default seed = $00c2 $1137)
        ;    routine from https://codebase64.net/doku.php?id=6502_6510_maths:x_abc_random_number_generator_8_16_bit
		inc  _x1
		clc
		lda  _x1
		eor  _c1
		eor  _a1
		sta  _a1
		adc  _b1
		sta  _b1
		lsr  a
		eor  _a1
		adc  _c1
		sta  _c1
		ldy  _b1
		rts
		.section BSS
_x1      .byte  ?
_c1      .byte  ?
_a1      .byte  ?
_b1      .byte  ?
		.send BSS
		.pend

randbyte = randword             ; -- 8 bit pseudo random number generator into A (by just reusing randword) NOTE: can not run from ROM
randbyte_rom = randword_rom     ; -- 8 bit pseudo random number generator into A (by just reusing randword). Can run from ROM


; ----------- optimized multiplications (in-place A (byte) and ?? (word)) : ---------
mul_byte_3	.proc
		; A = A + A*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_3	.proc
		; AY = AY*2 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend


mul_byte_5	.proc
		; A = A*4 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_5	.proc
		; AY = AY*4 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend


mul_byte_6	.proc
		; A = (A*2 + A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
                clc
                adc  P8ZP_SCRATCH_REG
		asl  a
		rts
		.pend

mul_word_6	.proc
		; AY = (AY*2 + AY)*2
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		tay
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		tya
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_7	.proc
		; A = A*8 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_7	.proc
		; AY = AY*8 - AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		sbc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_9	.proc
		; A = A*8 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_9	.proc
		; AY = AY*8 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_10	.proc
		; A=(A*4 + A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		rts
		.pend

mul_word_10	.proc
		; AY=(AY*4 + AY)*2
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_11	.proc
		; A=(A*2 + A)*4 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

; mul_word_11 is skipped (too much code)

mul_byte_12	.proc
		; A=(A*2 + A)*4
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		rts
		.pend

mul_word_12	.proc
		; AY=(AY*2 + AY)*4
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_13	.proc
		; A=(A*2 + A)*4 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
                clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
                clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

; mul_word_13 is skipped (too much code)

mul_byte_14	.proc
		; A=(A*8 - A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
                sec
		sbc  P8ZP_SCRATCH_REG
                asl  a
		rts
		.pend

; mul_word_14 is skipped (too much code)

mul_byte_15	.proc
		; A=A*16 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_15	.proc
		; AY = AY * 16 - AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		sbc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_20	.proc
		; A=(A*4 + A)*4
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		rts
		.pend

mul_word_20	.proc
		; AY = AY * 10 * 2
		jsr  mul_word_10
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_25	.proc
		; A=(A*2 + A)*8 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_25	.proc
		; AY = (AY*2 + AY) *8 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_40	.proc
		and  #7
		tay
		lda  _forties,y
		rts
_forties	.byte  0*40, 1*40, 2*40, 3*40, 4*40, 5*40, 6*40, 7*40 & 255
		.pend

mul_word_40	.proc
		; AY = (AY*4 + AY)*8
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		asl  P8ZP_SCRATCH_W1
		rol  a
		asl  P8ZP_SCRATCH_W1
		rol  a
		asl  P8ZP_SCRATCH_W1
		rol  a
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_50	.proc
		and  #7
		tay
		lda  _fifties, y
		rts
_fifties	.byte  0*50, 1*50, 2*50, 3*50, 4*50, 5*50, 6*50 & 255, 7*50 & 255
		.pend

mul_word_50	.proc
		; AY = AY * 25 * 2
		jsr  mul_word_25
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_80	.proc
		and  #3
		tay
		lda  _eighties, y
		rts
_eighties	.byte  0*80, 1*80, 2*80, 3*80
		.pend

mul_word_80	.proc
		; AY = AY * 40 * 2
		jsr  mul_word_40
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_100	.proc
		and  #3
		tay
		lda  _hundreds, y
		rts
_hundreds	.byte  0*100, 1*100, 2*100, 3*100 & 255
		.pend

mul_word_100	.proc
		; AY = AY * 25 * 4
		jsr  mul_word_25
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_320	.proc
		; AY = A * 256 + A * 64	 (msb in Y doesn't matter)
		sta  P8ZP_SCRATCH_B1
		ldy  #0
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		pha
		clc
		lda  P8ZP_SCRATCH_B1
		adc  P8ZP_SCRATCH_REG
		tay
		pla
		rts
		.pend

mul_word_640	.proc
		; AY = (A * 2 * 320) (msb in Y doesn't matter)
		asl  a
		jmp  mul_word_320
		.pend


; ----------- end optimized multiplications -----------


; support for bit shifting that is too large to be unrolled:

lsr_byte_A	.proc
		; -- lsr signed byte in A times the value in Y
		cpy  #0
		beq  +
		cmp  #0
		bpl  lsr_ubyte_A
-       	sec
		ror  a
		dey
		bne  -
+		rts
		.pend

lsr_ubyte_A	.proc
		; -- lsr unsigned byte in A times the value in Y
		cpy  #0
		beq  +
-		lsr  a
		dey
		bne  -
+		rts
		.pend

asl_byte_A      .proc
		; -- asl any byte in A times the value in Y
		cpy  #0
		beq  +
-		asl  a
		dey
		bne  -
+		rts
		.pend


lsr_word_AY     .proc
		; -- lsr signed word in AY times the value in X
		cpx  #0
		beq  +
		cpy  #0
		bpl  lsr_uword_AY
		sty  P8ZP_SCRATCH_B1
-		sec
		ror  P8ZP_SCRATCH_B1
		ror  a
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
+		rts
		.pend

lsr_uword_AY    .proc
		; -- lsr unsigned word in AY times the value in X
		cpx  #0
		beq  +
		sty  P8ZP_SCRATCH_B1
-		lsr  P8ZP_SCRATCH_B1
		ror  a
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
+		rts
		.pend

asl_word_AY     .proc
		; -- asl any word in AY times the value in X
		cpx  #0
		beq  +
		sty  P8ZP_SCRATCH_B1
-               asl  a
		rol  P8ZP_SCRATCH_B1
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
+		rts
		.pend


square          .proc
; -- calculate square of signed word (actually -255..255) in AY, result in AY
; routine by Lee Davison, source: http://6502.org/source/integers/square.htm
; using this routine is a lot faster as doing a regular multiplication (for words)
;
; Calculates the 16 bit unsigned integer square of the signed 16 bit integer in
; Numberl/Numberh.  The result is always in the range 0 to 65025 and is held in
; Squarel/Squareh
;
; The maximum input range is only +/-255 and no checking is done to ensure that
; this is so.
;
; This routine is useful if you are trying to draw circles as for any circle
;
; x^2+y^2=r^2 where x and y are the co-ordinates of any point on the circle and
; r is the circle radius

numberl = P8ZP_SCRATCH_W1       ; number to square low byte
numberh = P8ZP_SCRATCH_W1+1     ; number to square high byte
squarel = P8ZP_SCRATCH_W2       ; square low byte
squareh = P8ZP_SCRATCH_W2+1     ; square high byte
tempsq = P8ZP_SCRATCH_B1        ; temp byte for intermediate result

	sta  numberl
	sty  numberh

        lda     #$00        ; clear a
        sta     squarel     ; clear square low byte
                            ; (no need to clear the high byte, it gets shifted out)
        lda	numberl     ; get number low byte
	ldx	numberh     ; get number high  byte
	bpl	_nonneg      ; if +ve don't negate it
                            ; else do a two's complement
	eor	#$ff        ; invert
        sec	            ; +1
	adc	#$00        ; and add it

_nonneg:
	sta	tempsq      ; save abs(number)
	ldx	#$08        ; set bit count

_nextr2bit:
	asl	squarel     ; low byte *2
	rol	squareh     ; high byte *2+carry from low
	asl	a           ; shift number byte
	bcc	_nosqadd     ; don't do add if c = 0
	tay                 ; save a
	clc                 ; clear carry for add
	lda	tempsq      ; get number
	adc	squarel     ; add number^2 low byte
	sta	squarel     ; save number^2 low byte
	lda	#$00        ; clear a
	adc	squareh     ; add number^2 high byte
	sta	squareh     ; save number^2 high byte
	tya                 ; get a back

_nosqadd:
	dex                 ; decrement bit count
	bne	_nextr2bit   ; go do next bit

	lda  squarel
	ldy  squareh
	rts

		.pend
	.pend

; ---- block: 'prog8_lib' ----
prog8_lib	.proc
	; source: library:/prog8lib/prog8_lib.p8:3   prog8_lib {


	; source: library:/prog8lib/prog8_lib.p8:4   %option no_symbol_prefixing, ignore_unused
	; source: library:/prog8lib/prog8_lib.p8:6   %asminclude "library:prog8_lib.asm"
; Internal library routines - always included by the compiler
; Generic machine independent 6502 code.

		.section BSS_NOCLEAR
orig_stackpointer	.byte  ?	; stores the Stack pointer register at program start
		.send BSS_NOCLEAR

program_startup_clear_bss    .proc
	; this is always ran first thing from the start routine to clear out the BSS area
	.if  prog8_bss_section_size>0
		; reset all variables in BSS section to zero
		lda  #<prog8_bss_section_start
		ldy  #>prog8_bss_section_start
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldx  #<prog8_bss_section_size
		ldy  #>prog8_bss_section_size
		lda  #0
		jsr  prog8_lib.memset
	.endif
		rts
		.pend



read_byte_from_address_in_AY_into_A	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		rts
		.pend

read_byte_from_address_in_AY_into_A_65c02	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  (P8ZP_SCRATCH_W2)
		rts
		.pend


write_byte_X_to_address_in_AY	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		txa
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

write_byte_X_to_address_in_AY_65c02	.proc
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		txa
		sta  (P8ZP_SCRATCH_W2)
		rts
		.pend


reg_less_uw	.proc
		;  AY < P8ZP_SCRATCH_W2?
		cpy  P8ZP_SCRATCH_W2+1
		bcc  _true
		bne  _false
		cmp  P8ZP_SCRATCH_W2
		bcc  _true
_false		lda  #0
		rts
_true		lda  #1
		rts
		.pend

reg_less_w	.proc
		; -- AY < P8ZP_SCRATCH_W2?
		cmp  P8ZP_SCRATCH_W2
		tya
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bmi  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

reg_lesseq_uw	.proc
		; AY <= P8ZP_SCRATCH_W2?
		cpy  P8ZP_SCRATCH_W2+1
		beq  +
		bcc  _true
		lda  #0
		rts
+		cmp  P8ZP_SCRATCH_W2
		bcc  _true
		beq  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

reg_lesseq_w	.proc
		; -- P8ZP_SCRATCH_W2 <= AY ?   (note: order different from other routines)
		cmp  P8ZP_SCRATCH_W2
		tya
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bpl  +
		lda  #0
		rts
+		lda  #1
		rts
		.pend


memcopy16_up	.proc
	; -- copy memory UP from (P8ZP_SCRATCH_W1) to (P8ZP_SCRATCH_W2) of length X/Y (16-bit, X=lo, Y=hi)
	;    clobbers register A,X,Y
		source = P8ZP_SCRATCH_W1
		dest = P8ZP_SCRATCH_W2
		length = P8ZP_SCRATCH_B1   ; (and SCRATCH_ZPREG)

		stx  length
		sty  length+1

		ldx  length             ; move low byte of length into X
		bne  +                  ; jump to start if X > 0
		dec  length             ; subtract 1 from length
+		ldy  #0                 ; set Y to 0
-		lda  (source),y         ; set A to whatever (source) points to offset by Y
		sta  (dest),y           ; move A to location pointed to by (dest) offset by Y
		iny                     ; increment Y
		bne  +                  ; if Y<>0 then (rolled over) then still moving bytes
		inc  source+1           ; increment hi byte of source
		inc  dest+1             ; increment hi byte of dest
+		dex                     ; decrement X (lo byte counter)
		bne  -                  ; if X<>0 then move another byte
		dec  length             ; we've moved 255 bytes, dec length
		bpl  -                  ; if length is still positive go back and move more
		rts                     ; done
		.pend


memset          .proc
	; -- fill memory from (P8ZP_SCRATCH_W1), length XY, with value in A.
	;    clobbers X, Y
		stx  P8ZP_SCRATCH_B1
		sty  P8ZP_SCRATCH_REG
		ldy  #0
		ldx  P8ZP_SCRATCH_REG
		beq  _lastpage

_fullpage	sta  (P8ZP_SCRATCH_W1),y
		iny
		bne  _fullpage
		inc  P8ZP_SCRATCH_W1+1          ; next page
		dex
		bne  _fullpage

_lastpage	ldy  P8ZP_SCRATCH_B1
		beq  +
-         	dey
		sta  (P8ZP_SCRATCH_W1),y
		bne  -

+           	rts
		.pend


memsetw		.proc
	; -- fill memory from (P8ZP_SCRATCH_W1) number of words in P8ZP_SCRATCH_W2, with word value in AY.
	;    clobbers A, X, Y
		sta  _val
		sty  _val+1
		ldx  P8ZP_SCRATCH_W1
		stx  P8ZP_SCRATCH_B1
		ldx  P8ZP_SCRATCH_W1+1
		inx
		stx  P8ZP_SCRATCH_REG                ; second page

		ldy  #0
		ldx  P8ZP_SCRATCH_W2+1
		beq  _lastpage

_fullpage
		lda  _val
		sta  (P8ZP_SCRATCH_W1),y        ; first page
		sta  (P8ZP_SCRATCH_B1),y            ; second page
		iny
		lda  _val+1
		sta  (P8ZP_SCRATCH_W1),y        ; first page
		sta  (P8ZP_SCRATCH_B1),y            ; second page
		iny
		bne  _fullpage
		inc  P8ZP_SCRATCH_W1+1          ; next page pair
		inc  P8ZP_SCRATCH_W1+1          ; next page pair
		inc  P8ZP_SCRATCH_B1+1              ; next page pair
		inc  P8ZP_SCRATCH_B1+1              ; next page pair
		dex
		bne  _fullpage

_lastpage	ldx  P8ZP_SCRATCH_W2
		beq  _done

		ldy  #0
-
		lda  _val
		sta  (P8ZP_SCRATCH_W1), y
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+		lda  _val+1
		sta  (P8ZP_SCRATCH_W1), y
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+               dex
		bne  -
_done		rts
		.section BSS
_val	.word ?
		.send BSS
		.pend



ror2_mem_ub	.proc
		; -- in-place 8-bit ror of byte at memory location in AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		lsr  a
		bcc  +
		ora  #$80
+		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend

rol2_mem_ub	.proc
		; -- in-place 8-bit rol of byte at memory location in AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		cmp  #$80
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend


strcpy		.proc
		; copy a string (must be 0-terminated) from A/Y to (P8ZP_SCRATCH_W1)
		; it is assumed the target string is large enough.
		; returns the length of the string that was copied in Y.
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #$ff
-		iny
		lda  (P8ZP_SCRATCH_W2),y
		sta  (P8ZP_SCRATCH_W1),y
		bne  -
		rts
		.pend

strncpy		.proc
		; copy a string (must be 0-terminated) from A/Y to (P8ZP_SCRATCH_W1)
		; with maximum length to copy in X.
		; returns the length of the string that was copied in Y.
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #$ff
-		iny
		lda  (P8ZP_SCRATCH_W2),y
		sta  (P8ZP_SCRATCH_W1),y
		beq  +
		dex
		bne  -
		iny
		lda  #0
		sta  (P8ZP_SCRATCH_W1),y
+		rts
		.pend

strcmp_expression	.proc
		; -- compare strings, result in A
		lda  _arg_s2
		ldy  _arg_s2+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  _arg_s1
		ldy  _arg_s1+1
		jmp  strcmp_mem
		.section BSS
_arg_s1		.word  ?
_arg_s2		.word  ?
		.send BSS
		.pend

strcmp_mem	.proc
		; --   compares strings in s1 (AY) and s2 (P8ZP_SCRATCH_W2).
		;      Returns -1,0,1 in A, depending on the ordering. Clobbers Y.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
_loop           lda  (P8ZP_SCRATCH_W1),y
		beq  _c1_zero
		cmp  (P8ZP_SCRATCH_W2),y
		beq  _equal
		bmi  _less
		lda  #1
		rts
_less           lda  #-1
		rts
_equal          iny
		bne  _loop
_c1_zero        lda  (P8ZP_SCRATCH_W2),y
		beq  +
		lda  #-1
+		rts
		.pend

strncmp_mem	.proc
		; --   compares strings in s1 (AY) and s2 (P8ZP_SCRATCH_W2).
                ;      Compares up to maximum length specified in X.
		;      Returns -1,0,1 in A, depending on the ordering. Clobbers X & Y.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
_loop           lda  (P8ZP_SCRATCH_W1),y
		beq  _c1_zero
		cmp  (P8ZP_SCRATCH_W2),y
		beq  _equal
		bmi  _less
		lda  #1
		rts
_less           lda  #-1
		rts
_equal          dex
		bne +
		lda #0
		rts
+		iny
		bne  _loop
_c1_zero        lda  (P8ZP_SCRATCH_W2),y
		beq  +
		lda  #-1
+		rts
		.pend


strlen          .proc
        ; -- returns the number of bytes in the string in AY, in Y. Clobbers A.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  +
		iny
		bne  -
+		rts
		.pend


containment_bytearray	.proc
	; -- check if a value exists in a byte array.
	;    parameters: P8ZP_SCRATCH_W1: address of the byte array, A = byte to check, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
		dey
-		cmp  (P8ZP_SCRATCH_W1),y
		beq  +
		dey
		cpy  #255
		bne  -
		lda  #0
		rts
+		lda  #1
		rts
		.pend

containment_linearwordarray	.proc
	; -- check if a value exists in a linear word array.
	;    parameters: P8ZP_SCRATCH_W1: value to check, P8ZP_SCRATCH_W2: address of the word array, Y = number of elements in the array (>=1).
	;    returns boolean 0/1 in A.
		dey
		tya
		asl  a
		tay
-		lda  P8ZP_SCRATCH_W1
		cmp  (P8ZP_SCRATCH_W2),y
		bne  +
		lda  P8ZP_SCRATCH_W1+1
		iny
		cmp  (P8ZP_SCRATCH_W2),y
		beq  _found
		dey
+		dey
		dey
		cpy  #254
		bne  -
		lda  #0
		rts
_found		lda  #1
		rts
		.pend

containment_splitwordarray	.proc
	; -- check if a value exists in a split lsb/msb word array. (Assuming lsb array comes first, immediately followed by msb array)
	;    parameters: P8ZP_SCRATCH_W1: value to check, P8ZP_SCRATCH_W2: start address of the lsb word array, Y = number of elements in the array (>=1).
	;    returns boolean 0/1 in A.

	; store the needle value in SCRATCH_B1(lsb) and SCRATCH_REG(msb)
		lda  P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_REG

	; calculate where the msb array starts and put this in P8ZP_SCRATCH_W1  (_W2 is the start of the lsb array)
		tya
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W2+1
		adc  #0
		sta  P8ZP_SCRATCH_W1+1

	; search needle
		dey
-               lda  P8ZP_SCRATCH_REG
		cmp  (P8ZP_SCRATCH_W1),y
		bne  +
		lda  P8ZP_SCRATCH_B1
		cmp  (P8ZP_SCRATCH_W2),y
		beq  _found
+               dey
		cpy  #255
		bne  -
		lda  #0
		rts
_found          lda  #1
		rts
	.pend


memcopy_small   .proc
		; copy up to a single page (256 bytes) of memory.
		; note: only works for NON-OVERLAPPING memory regions!
		; P8ZP_SCRATCH_W1 = from address
		; P8ZP_SCRATCH_W2 = destination address
		; Y = number of bytes to copy  (where 0 means 256)
		cpy  #0
		beq  _fullpage
		dey
		beq  _lastbyte
_loop           lda  (P8ZP_SCRATCH_W1),y
                sta  (P8ZP_SCRATCH_W2),y
                dey
                bne  _loop
_lastbyte       lda  (P8ZP_SCRATCH_W1),y
                sta  (P8ZP_SCRATCH_W2),y
                rts
_fullpage       lda  (P8ZP_SCRATCH_W1),y
                sta  (P8ZP_SCRATCH_W2),y
                dey
                bne  _fullpage
                rts
		.pend


long_not_equals     .proc
		; checks if the 32 bits long value pointed to by AY is NOT equal to the one pointed to by P8ZP_SCRATCH_W1
		; returns A=1 if NOT equals otherwise A=0
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #3
-		lda  (P8ZP_SCRATCH_W1),y
		cmp  (P8ZP_SCRATCH_W2),y
		bne  _notequal
		dey
		bpl  -
		lda  #0
		rts
_notequal       lda  #1
		rts
		.pend


long_add_inplace        .proc
		; long pointed to by AY += long pointed to by P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		clc
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		adc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		adc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		adc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		adc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

long_sub_inplace    .proc
		; long pointed to by AY -= long pointed to by P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sec
		lda  (P8ZP_SCRATCH_W2),y
		sbc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		sbc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		sbc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		sbc  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

long_or_inplace       .proc
		; long pointed to by AY OR= long pointed to by P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		ora  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		ora  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		ora  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		ora  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

long_and_inplace       .proc
		; long pointed to by AY AND= long pointed to by P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		and  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		and  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		and  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		and  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

long_xor_inplace       .proc
		; long pointed to by AY XOR= long pointed to by P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		eor  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		eor  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		eor  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		iny
		lda  (P8ZP_SCRATCH_W2),y
		eor  (P8ZP_SCRATCH_W1),y
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend

long_shiftleftX_inplace         .proc
		; bit shift left X bits the long value pointed to by AY
		cpx  #0
		beq  _end
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
-		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		asl  a
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		dex
		bne  -
_end		rts
		.pend

long_shiftrightX_inplace        .proc
		; bit shift right X bits the long value pointed to by AY
		cpx  #0
		beq  _end
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
-		ldy  #3
		lda  (P8ZP_SCRATCH_W1),y
		asl  a  ; save sign bit
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		dey
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		dey
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		dey
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		dex
		bne  -
_end		rts
		.pend


compare_long_0_and_sign	        .proc
		; pointer to 32 bits signed long in P8ZP_SCRATCH_W1, carry Set=check NEGATIVE (<=0), carry Clear=check POSITIVE (>=0)
		; returns carry Set if comparison succeeded otherwise carry Clear
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		iny
		ora  (P8ZP_SCRATCH_W1),y
		iny
		ora  (P8ZP_SCRATCH_W1),y
		iny
		ora  (P8ZP_SCRATCH_W1),y
		beq  _success

		lda  (P8ZP_SCRATCH_W1),y
		bcc  _checkpositive
		bmi  _success
		bpl  _fail

_checkpositive	bpl  _success

_fail		clc
		rts

_success	sec
		rts
		.pend
	; source: library:/prog8lib/prog8_lib.p8:7   %asminclude "library:prog8_funcs.asm"
; ---- builtin functions

abs_b_into_A	.proc
	; -- A = abs(A)
		cmp  #0
		bmi  +
		rts
+		eor  #$ff
		clc
		adc  #1
		rts
		.pend

abs_w_into_AY	.proc
	; -- AY = abs(AY)
		cpy  #0
		bmi  +
		rts
+		eor  #$ff
		pha
		tya
		eor  #$ff
		tay
		pla
		clc
		adc  #1
		bcc  +
		iny
+		rts
		.pend

abs_l_into_R14R15	.proc
	; -- R14:R15 = abs(R14:R15)
    lda  cx16.r15H
    bmi  +   ; Negative if high bit of highest byte is set
    rts
+
    ; Invert all four bytes
    lda  cx16.r14L
    eor  #$FF
    sta  cx16.r14L
    lda  cx16.r14H
    eor  #$FF
    sta  cx16.r14H
    lda  cx16.r15L
    eor  #$FF
    sta  cx16.r15L
    lda  cx16.r15H
    eor  #$FF
    sta  cx16.r15H
    ; Add 1 to whole 32-bit value
    inc  cx16.r14L
    bne  +
    inc  cx16.r14H
    bne  +
    inc  cx16.r15L
    bne  +
    inc  cx16.r15H
+   rts
		.pend

func_sign_b_into_A	.proc
		cmp  #0
		beq  _zero
		bmi  _neg
		lda  #1
_zero		rts
_neg		lda  #-1
		rts
		.pend

func_sign_ub_into_A	.proc
		cmp  #0
		bne  _pos
		rts
_pos		lda  #1
		rts
		.pend

func_sign_uw_into_A	.proc
		cpy  #0
		beq  _possibly_zero
_pos		lda  #1
		rts
_possibly_zero	cmp  #0
		bne  _pos
		rts
		.pend

func_sign_w_into_A	.proc
		cpy  #0
		bmi  _negative
		bne  _positive
		cmp  #0
		beq  _zero
_positive	lda  #1
_zero		rts
_negative	lda  #-1
		rts
		.pend

func_sign_l_r14r15_into_A      .proc
    lda  cx16.r14+3              ; msb
    bmi  _negative
    bne  _positive
    lda  cx16.r14+2
    bne  _positive
    lda  cx16.r14+1
    bne  _positive
    lda  cx16.r14
    beq  _zero
    lda  #1
_zero
    rts
_negative
    lda  #-1
    rts
_positive
    lda  #1
    rts

.pend



func_sqrt16_into_A	.proc
		; integer square root
		; http://6502org.wikidot.com/software-math-sqrt
		; https://github.com/TobyLobster/sqrt_test/blob/main/sqrt/sqrt7.a
		; Tweaked by TobyLobster and 0xC0DE to be smaller and faster
_numl = P8ZP_SCRATCH_W1
_numh = P8ZP_SCRATCH_W1+1
_loop_counter = P8ZP_SCRATCH_REG
_root = P8ZP_SCRATCH_B1
            sta  _numl
            sty  _numh
            ldx  #$ff
            stx  _loop_counter
            inx
            stx  _root
            sec
_loop       lda  _numh
            sbc  #$40
            tay
            txa
            sbc  _root
            bcc  +
            sty  _numh
            bcs  ++
+           txa
+           rol  _root
            asl  _numl
            rol  _numh
            rol  a
            asl  _numl
            rol  _numh
            rol  a
            tax
            lsr  _loop_counter
            bne  _loop
            lda  _root
            rts
		.pend


func_sort_ub	.proc
		; 8bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in S
		; first, put pointer BEFORE array
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		bne  +
		dec  P8ZP_SCRATCH_W1+1
+		dec  P8ZP_SCRATCH_W1
_sortloop	ldy  P8ZP_SCRATCH_B1		;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y	;last value in (what is left of) sequence to be sorted
		sta  P8ZP_SCRATCH_REG		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2+1
		bcc  _l1
_l2		sty  P8ZP_SCRATCH_W2	;index of potentially largest value
		sta  P8ZP_SCRATCH_W2+1	;potentially largest value
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1		;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2+1	;the largest value
		sta  (P8ZP_SCRATCH_W1),y	;put largest value in place
		ldy  P8ZP_SCRATCH_W2	;index of free space
		lda  P8ZP_SCRATCH_REG		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y	;put the over-written value in the free space
		dec  P8ZP_SCRATCH_B1		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_b	.proc
		; 8bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first, put pointer BEFORE array
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		bne  +
		dec  P8ZP_SCRATCH_W1+1
+		dec  P8ZP_SCRATCH_W1
_sortloop	ldy  P8ZP_SCRATCH_B1		;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y	;last value in (what is left of) sequence to be sorted
		sta  P8ZP_SCRATCH_REG		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2+1
		bmi  _l1
_l2		sty  P8ZP_SCRATCH_W2	;index of potentially largest value
		sta  P8ZP_SCRATCH_W2+1	;potentially largest value
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1		;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2+1	;the largest value
		sta  (P8ZP_SCRATCH_W1),y	;put largest value in place
		ldy  P8ZP_SCRATCH_W2	;index of free space
		lda  P8ZP_SCRATCH_REG		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y	;put the over-written value in the free space
		dec  P8ZP_SCRATCH_B1		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_uw	.proc
		; 16bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		sec
		sbc  #2
		sta  P8ZP_SCRATCH_W1
		bcs  _sort_loop
		dec  P8ZP_SCRATCH_W1+1
_sort_loop	ldy  P8ZP_SCRATCH_B1    	;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		iny
		lda  (P8ZP_SCRATCH_W1),y
		dey
		cmp  P8ZP_SCRATCH_W2+1
		bne  +
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2
+		bcc  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2          ;potentially largest value
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2+1
		dey
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1           ;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2          ;the largest value
		sta  (P8ZP_SCRATCH_W1),y      ;put largest value in place
		iny
		lda  P8ZP_SCRATCH_W2+1
		sta  (P8ZP_SCRATCH_W1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (P8ZP_SCRATCH_W1),y
		dey
		dec  P8ZP_SCRATCH_B1           ;end of the shorter sequence still left
		dec  P8ZP_SCRATCH_B1
		bne  _sort_loop           ;start working with the shorter sequence
		rts
		.section BSS
_work1	.byte  ?
_work3	.word  ?
		.send BSS
		.pend


func_sort_w	.proc
		; 16bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		sec
		sbc  #2
		sta  P8ZP_SCRATCH_W1
		bcs  _sort_loop
		dec  P8ZP_SCRATCH_W1+1
_sort_loop	ldy  P8ZP_SCRATCH_B1    	;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2
		iny
		lda  (P8ZP_SCRATCH_W1),y
		dey
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bmi  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2          ;potentially largest value
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2+1
		dey
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1           ;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2          ;the largest value
		sta  (P8ZP_SCRATCH_W1),y      ;put largest value in place
		iny
		lda  P8ZP_SCRATCH_W2+1
		sta  (P8ZP_SCRATCH_W1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (P8ZP_SCRATCH_W1),y
		dey
		dec  P8ZP_SCRATCH_B1           ;end of the shorter sequence still left
		dec  P8ZP_SCRATCH_B1
		bne  _sort_loop           ;start working with the shorter sequence
		rts
		.section BSS
_work1	.byte  ?
_work3	.word  ?
		.send BSS
		.pend


func_reverse_b	.proc
		; --- reverse an array of bytes (in-place)
		; inputs:  pointer to array in P8ZP_SCRATCH_W1, length in A
_index_right = P8ZP_SCRATCH_W2
_index_left = P8ZP_SCRATCH_W2+1
_loop_count = P8ZP_SCRATCH_REG
		sta  _loop_count
		lsr  _loop_count
		sec
		sbc  #1
		sta  _index_right
		lda  #0
		sta  _index_left
_loop		ldy  _index_right
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_left
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_right
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_left
		sta  (P8ZP_SCRATCH_W1),y
		inc  _index_left
		dec  _index_right
		dec  _loop_count
		bne  _loop
		rts
		.pend


func_reverse_w	.proc
		; --- reverse an array of words (in-place)
		; inputs:  pointer to array in P8ZP_SCRATCH_W1, length in A
_index_first = P8ZP_SCRATCH_W2
_index_second = P8ZP_SCRATCH_W2+1
_loop_count = P8ZP_SCRATCH_REG
		pha
		asl  a     ; *2 because words
		sec
		sbc  #2
		sta  _index_first
		lda  #0
		sta  _index_second
		pla
		lsr  a
		pha
		sta  _loop_count
		; first reverse the lsbs
_loop_lo	ldy  _index_first
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_second
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_first
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_second
		sta  (P8ZP_SCRATCH_W1),y
		inc  _index_second
		inc  _index_second
		dec  _index_first
		dec  _index_first
		dec  _loop_count
		bne  _loop_lo
		; now reverse the msbs
		dec  _index_second
		inc  _index_first
		inc  _index_first
		inc  _index_first
		pla
		sta  _loop_count
_loop_hi	ldy  _index_first
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_second
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_first
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_second
		sta  (P8ZP_SCRATCH_W1),y
		dec  _index_second
		dec  _index_second
		inc  _index_first
		inc  _index_first
		dec  _loop_count
		bne  _loop_hi

		rts
		.pend


func_peek   .proc
	; -- read the byte value on the address in AY, into A
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
from_scratchW1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	rts
	.pend

func_peekw   .proc
	; -- read the word value on the address in AY, into AY
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
from_scratchW1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	pha
	iny
	lda  (P8ZP_SCRATCH_W1),y
	tay
	pla
	rts
	.pend

func_peekl   .proc
	; -- read the ;pmg value on the address in AY, into R14:R15
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
from_scratchW1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	sta  cx16.r14
	iny
	lda  (P8ZP_SCRATCH_W1),y
	sta  cx16.r14+1
	iny
	lda  (P8ZP_SCRATCH_W1),y
	sta  cx16.r14+2
	iny
	lda  (P8ZP_SCRATCH_W1),y
	sta  cx16.r14+3
	rts
	.pend


func_pokew   .proc
	; -- store the word value in AY in the address in P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_REG
	ldy  #0
	sta  (P8ZP_SCRATCH_W1),y
	iny
	lda  P8ZP_SCRATCH_REG
	sta  (P8ZP_SCRATCH_W1),y
	rts
	.pend

func_pokew_scratchW2   .proc
	; -- store the word value in AY in the address in P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_REG
	ldy  #0
	sta  (P8ZP_SCRATCH_W2),y
	iny
	lda  P8ZP_SCRATCH_REG
	sta  (P8ZP_SCRATCH_W2),y
	rts
	.pend

func_pokel   .proc
	; -- store the long value in R14:R15 in the address in AY
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	lda  cx16.r14
	sta  (P8ZP_SCRATCH_W1),y
	iny
	lda  cx16.r14+1
	sta  (P8ZP_SCRATCH_W1),y
	iny
	lda  cx16.r14+2
	sta  (P8ZP_SCRATCH_W1),y
	iny
	lda  cx16.r14+3
	sta  (P8ZP_SCRATCH_W1),y
	rts
	.pend

func_clamp_byte .proc
	; signed value in A, result in A
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W1+1
	tay
	sec
	sbc  P8ZP_SCRATCH_W1+1
	bvc  +
	eor  #$80
+       bmi  +
	lda  P8ZP_SCRATCH_W1+1
	tay
	jmp  ++
+       tya
+	sec
	sbc  P8ZP_SCRATCH_W1
	bvc  +
	eor  #$80
+       bmi  +
	tya
	rts
+       lda  P8ZP_SCRATCH_W1
	rts
	.pend


func_clamp_ubyte .proc
	; value in A, result in A
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W1+1
	cmp  P8ZP_SCRATCH_W1+1
	bcc  +
	lda  P8ZP_SCRATCH_W1+1
+       cmp  P8ZP_SCRATCH_W1
	bcc  +
	rts
+       lda  P8ZP_SCRATCH_W1
	rts
	.pend

func_clamp_word .proc
	; signed value in AY, result in AY
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W2
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
	ldy  P8ZP_SCRATCH_W2+1
	lda  P8ZP_SCRATCH_W2
	cmp  P8ZP_SCRATCH_B1
	tya
	sbc  P8ZP_SCRATCH_REG
	bvc  +
	eor  #$80
+       bpl  +
	lda  P8ZP_SCRATCH_W2
	ldy  P8ZP_SCRATCH_W2+1
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
+	ldy  P8ZP_SCRATCH_W1+1
	lda  P8ZP_SCRATCH_W1
	cmp  P8ZP_SCRATCH_B1
	tya
	sbc  P8ZP_SCRATCH_REG
	bvc  +
	eor  #$80
+       bpl  +
	ldy  P8ZP_SCRATCH_REG
	lda  P8ZP_SCRATCH_B1
	rts
+	ldy  P8ZP_SCRATCH_W1+1
	lda  P8ZP_SCRATCH_W1
	rts
	.pend

func_clamp_uword .proc
	; value in AY, result in AY
	; minimum in P8ZP_SCRATCH_W1
	; maximum in P8ZP_SCRATCH_W2
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
	cpy  P8ZP_SCRATCH_W2+1
	bcc  ++
	bne  +
	cmp  P8ZP_SCRATCH_W2
	bcc  ++
+       beq  +
	lda  P8ZP_SCRATCH_W2
	ldy  P8ZP_SCRATCH_W2+1
	sta  P8ZP_SCRATCH_B1
	sty  P8ZP_SCRATCH_REG
+	ldy  P8ZP_SCRATCH_REG
	lda  P8ZP_SCRATCH_B1
	cpy  P8ZP_SCRATCH_W1+1
	bcc  ++
	bne  +
	cmp  P8ZP_SCRATCH_W1
	bcc  ++
+       beq  +
	ldy  P8ZP_SCRATCH_REG
	lda  P8ZP_SCRATCH_B1
	rts
+	ldy  P8ZP_SCRATCH_W1+1
	lda  P8ZP_SCRATCH_W1
	rts

	.pend
	.pend
; global float constants
; struct types
; struct instances without initialization values, as BSS zeroed at startup
	.section BSS
prog8_struct_instances_bss  .block
	.endblock
	.send BSS
; struct instances with initialization values
	.section STRUCTINSTANCES
prog8_struct_instances  .block
	.endblock
	.send STRUCTINSTANCES
	.dsection STRUCTINSTANCES
; bss sections
PROG8_VARSHIGH_RAMBANK = 1
	.dsection BSS_NOCLEAR
prog8_bss_section_start
	.dsection BSS
prog8_bss_section_size = * - prog8_bss_section_start
	.dsection BSS_SLABS
prog8_program_end	; end of program label for progend()
	; memtop check
	.cerror * >= $c000, "Program too long by ", * - $bfff, " bytes, memtop=$c000"
